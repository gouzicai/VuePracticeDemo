/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/index.less":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/index.less ***!
  \*********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"ul {\\n  padding: 0;\\n  margin: 0;\\n}\\n\", \"\"]);\n\n\n//# sourceURL=webpack:///./src/css/index.less?./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./src/css/index.scss":
/*!***********************************************************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./src/css/index.scss ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Imports\nvar getUrl = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/getUrl.js */ \"./node_modules/css-loader/dist/runtime/getUrl.js\");\nvar ___CSS_LOADER_URL___0___ = getUrl(__webpack_require__(/*! ../images/timg.jpg */ \"./src/images/timg.jpg\"));\n// Module\nexports.push([module.i, \"html .box, body .box {\\n  width: 220px;\\n  height: 120px;\\n  background: url(\" + ___CSS_LOADER_URL___0___ + \");\\n  background-size: cover; }\\n\", \"\"]);\n\n\n//# sourceURL=webpack:///./src/css/index.scss?./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/cjs.js!./src/css/index.css":
/*!*****************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/css/index.css ***!
  \*****************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("exports = module.exports = __webpack_require__(/*! ../../node_modules/css-loader/dist/runtime/api.js */ \"./node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.i, \"li{\\r\\n    list-style:none;\\r\\n}\\r\\n\\r\\ndiv{\\r\\n    background-color:pink;\\r\\n}\", \"\"]);\n\n\n//# sourceURL=webpack:///./src/css/index.css?./node_modules/css-loader/dist/cjs.js");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\n// eslint-disable-next-line func-names\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return \"@media \".concat(item[2], \"{\").concat(content, \"}\");\n      }\n\n      return content;\n    }).join('');\n  }; // import a list of modules into the list\n  // eslint-disable-next-line func-names\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      // eslint-disable-next-line no-param-reassign\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      // eslint-disable-next-line prefer-destructuring\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (var _i = 0; _i < modules.length; _i++) {\n      var item = modules[_i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = \"(\".concat(item[2], \") and (\").concat(mediaQuery, \")\");\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || ''; // eslint-disable-next-line prefer-destructuring\n\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return \"/*# sourceURL=\".concat(cssMapping.sourceRoot).concat(source, \" */\");\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n  return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/api.js?");

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/getUrl.js":
/*!********************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/getUrl.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nmodule.exports = function (url, needQuotes) {\n  // eslint-disable-next-line no-underscore-dangle, no-param-reassign\n  url = url.__esModule ? url.default : url;\n\n  if (typeof url !== 'string') {\n    return url;\n  } // If url is already wrapped in quotes, remove them\n\n\n  if (/^['\"].*['\"]$/.test(url)) {\n    // eslint-disable-next-line no-param-reassign\n    url = url.slice(1, -1);\n  } // Should url be wrapped?\n  // See https://drafts.csswg.org/css-values-3/#urls\n\n\n  if (/[\"'() \\t\\n]/.test(url) || needQuotes) {\n    return \"\\\"\".concat(url.replace(/\"/g, '\\\\\"').replace(/\\n/g, '\\\\n'), \"\\\"\");\n  }\n\n  return url;\n};\n\n//# sourceURL=webpack:///./node_modules/css-loader/dist/runtime/getUrl.js?");

/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n\n//# sourceURL=webpack:///./node_modules/process/browser.js?");

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/*!***************************************************!*\
  !*** ./node_modules/setimmediate/setImmediate.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../process/browser.js */ \"./node_modules/process/browser.js\")))\n\n//# sourceURL=webpack:///./node_modules/setimmediate/setImmediate.js?");

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar stylesInDom = {};\n\nvar isOldIE = function isOldIE() {\n  var memo;\n  return function memorize() {\n    if (typeof memo === 'undefined') {\n      // Test for IE <= 9 as proposed by Browserhacks\n      // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n      // Tests for existence of standard globals is to allow style-loader\n      // to operate correctly into non-standard environments\n      // @see https://github.com/webpack-contrib/style-loader/issues/177\n      memo = Boolean(window && document && document.all && !window.atob);\n    }\n\n    return memo;\n  };\n}();\n\nvar getTarget = function getTarget() {\n  var memo = {};\n  return function memorize(target) {\n    if (typeof memo[target] === 'undefined') {\n      var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself\n\n      if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n        try {\n          // This will throw an exception if access to iframe is blocked\n          // due to cross-origin restrictions\n          styleTarget = styleTarget.contentDocument.head;\n        } catch (e) {\n          // istanbul ignore next\n          styleTarget = null;\n        }\n      }\n\n      memo[target] = styleTarget;\n    }\n\n    return memo[target];\n  };\n}();\n\nfunction listToStyles(list, options) {\n  var styles = [];\n  var newStyles = {};\n\n  for (var i = 0; i < list.length; i++) {\n    var item = list[i];\n    var id = options.base ? item[0] + options.base : item[0];\n    var css = item[1];\n    var media = item[2];\n    var sourceMap = item[3];\n    var part = {\n      css: css,\n      media: media,\n      sourceMap: sourceMap\n    };\n\n    if (!newStyles[id]) {\n      styles.push(newStyles[id] = {\n        id: id,\n        parts: [part]\n      });\n    } else {\n      newStyles[id].parts.push(part);\n    }\n  }\n\n  return styles;\n}\n\nfunction addStylesToDom(styles, options) {\n  for (var i = 0; i < styles.length; i++) {\n    var item = styles[i];\n    var domStyle = stylesInDom[item.id];\n    var j = 0;\n\n    if (domStyle) {\n      domStyle.refs++;\n\n      for (; j < domStyle.parts.length; j++) {\n        domStyle.parts[j](item.parts[j]);\n      }\n\n      for (; j < item.parts.length; j++) {\n        domStyle.parts.push(addStyle(item.parts[j], options));\n      }\n    } else {\n      var parts = [];\n\n      for (; j < item.parts.length; j++) {\n        parts.push(addStyle(item.parts[j], options));\n      }\n\n      stylesInDom[item.id] = {\n        id: item.id,\n        refs: 1,\n        parts: parts\n      };\n    }\n  }\n}\n\nfunction insertStyleElement(options) {\n  var style = document.createElement('style');\n\n  if (typeof options.attributes.nonce === 'undefined') {\n    var nonce =  true ? __webpack_require__.nc : undefined;\n\n    if (nonce) {\n      options.attributes.nonce = nonce;\n    }\n  }\n\n  Object.keys(options.attributes).forEach(function (key) {\n    style.setAttribute(key, options.attributes[key]);\n  });\n\n  if (typeof options.insert === 'function') {\n    options.insert(style);\n  } else {\n    var target = getTarget(options.insert || 'head');\n\n    if (!target) {\n      throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n    }\n\n    target.appendChild(style);\n  }\n\n  return style;\n}\n\nfunction removeStyleElement(style) {\n  // istanbul ignore if\n  if (style.parentNode === null) {\n    return false;\n  }\n\n  style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */\n\n\nvar replaceText = function replaceText() {\n  var textStore = [];\n  return function replace(index, replacement) {\n    textStore[index] = replacement;\n    return textStore.filter(Boolean).join('\\n');\n  };\n}();\n\nfunction applyToSingletonTag(style, index, remove, obj) {\n  var css = remove ? '' : obj.css; // For old IE\n\n  /* istanbul ignore if  */\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = replaceText(index, css);\n  } else {\n    var cssNode = document.createTextNode(css);\n    var childNodes = style.childNodes;\n\n    if (childNodes[index]) {\n      style.removeChild(childNodes[index]);\n    }\n\n    if (childNodes.length) {\n      style.insertBefore(cssNode, childNodes[index]);\n    } else {\n      style.appendChild(cssNode);\n    }\n  }\n}\n\nfunction applyToTag(style, options, obj) {\n  var css = obj.css;\n  var media = obj.media;\n  var sourceMap = obj.sourceMap;\n\n  if (media) {\n    style.setAttribute('media', media);\n  }\n\n  if (sourceMap && btoa) {\n    css += \"\\n/*# sourceMappingURL=data:application/json;base64,\".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), \" */\");\n  } // For old IE\n\n  /* istanbul ignore if  */\n\n\n  if (style.styleSheet) {\n    style.styleSheet.cssText = css;\n  } else {\n    while (style.firstChild) {\n      style.removeChild(style.firstChild);\n    }\n\n    style.appendChild(document.createTextNode(css));\n  }\n}\n\nvar singleton = null;\nvar singletonCounter = 0;\n\nfunction addStyle(obj, options) {\n  var style;\n  var update;\n  var remove;\n\n  if (options.singleton) {\n    var styleIndex = singletonCounter++;\n    style = singleton || (singleton = insertStyleElement(options));\n    update = applyToSingletonTag.bind(null, style, styleIndex, false);\n    remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n  } else {\n    style = insertStyleElement(options);\n    update = applyToTag.bind(null, style, options);\n\n    remove = function remove() {\n      removeStyleElement(style);\n    };\n  }\n\n  update(obj);\n  return function updateStyle(newObj) {\n    if (newObj) {\n      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n        return;\n      }\n\n      update(obj = newObj);\n    } else {\n      remove();\n    }\n  };\n}\n\nmodule.exports = function (list, options) {\n  options = options || {};\n  options.attributes = typeof options.attributes === 'object' ? options.attributes : {}; // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n  // tags it will allow on a page\n\n  if (!options.singleton && typeof options.singleton !== 'boolean') {\n    options.singleton = isOldIE();\n  }\n\n  var styles = listToStyles(list, options);\n  addStylesToDom(styles, options);\n  return function update(newList) {\n    var mayRemove = [];\n\n    for (var i = 0; i < styles.length; i++) {\n      var item = styles[i];\n      var domStyle = stylesInDom[item.id];\n\n      if (domStyle) {\n        domStyle.refs--;\n        mayRemove.push(domStyle);\n      }\n    }\n\n    if (newList) {\n      var newStyles = listToStyles(newList, options);\n      addStylesToDom(newStyles, options);\n    }\n\n    for (var _i = 0; _i < mayRemove.length; _i++) {\n      var _domStyle = mayRemove[_i];\n\n      if (_domStyle.refs === 0) {\n        for (var j = 0; j < _domStyle.parts.length; j++) {\n          _domStyle.parts[j]();\n        }\n\n        delete stylesInDom[_domStyle.id];\n      }\n    }\n  };\n};\n\n//# sourceURL=webpack:///./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js?");

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/*!************************************************!*\
  !*** ./node_modules/timers-browserify/main.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\n__webpack_require__(/*! setimmediate */ \"./node_modules/setimmediate/setImmediate.js\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\")))\n\n//# sourceURL=webpack:///./node_modules/timers-browserify/main.js?");

/***/ }),

/***/ "./node_modules/vue/dist/vue.js":
/*!**************************************!*\
  !*** ./node_modules/vue/dist/vue.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!\n * Vue.js v2.6.10\n * (c) 2014-2019 Evan You\n * Released under the MIT License.\n */\n(function (global, factory) {\n   true ? module.exports = factory() :\n  undefined;\n}(this, function () { 'use strict';\n\n  /*  */\n\n  var emptyObject = Object.freeze({});\n\n  // These helpers produce better VM code in JS engines due to their\n  // explicitness and function inlining.\n  function isUndef (v) {\n    return v === undefined || v === null\n  }\n\n  function isDef (v) {\n    return v !== undefined && v !== null\n  }\n\n  function isTrue (v) {\n    return v === true\n  }\n\n  function isFalse (v) {\n    return v === false\n  }\n\n  /**\n   * Check if value is primitive.\n   */\n  function isPrimitive (value) {\n    return (\n      typeof value === 'string' ||\n      typeof value === 'number' ||\n      // $flow-disable-line\n      typeof value === 'symbol' ||\n      typeof value === 'boolean'\n    )\n  }\n\n  /**\n   * Quick object check - this is primarily used to tell\n   * Objects from primitive values when we know the value\n   * is a JSON-compliant type.\n   */\n  function isObject (obj) {\n    return obj !== null && typeof obj === 'object'\n  }\n\n  /**\n   * Get the raw type string of a value, e.g., [object Object].\n   */\n  var _toString = Object.prototype.toString;\n\n  function toRawType (value) {\n    return _toString.call(value).slice(8, -1)\n  }\n\n  /**\n   * Strict object type check. Only returns true\n   * for plain JavaScript objects.\n   */\n  function isPlainObject (obj) {\n    return _toString.call(obj) === '[object Object]'\n  }\n\n  function isRegExp (v) {\n    return _toString.call(v) === '[object RegExp]'\n  }\n\n  /**\n   * Check if val is a valid array index.\n   */\n  function isValidArrayIndex (val) {\n    var n = parseFloat(String(val));\n    return n >= 0 && Math.floor(n) === n && isFinite(val)\n  }\n\n  function isPromise (val) {\n    return (\n      isDef(val) &&\n      typeof val.then === 'function' &&\n      typeof val.catch === 'function'\n    )\n  }\n\n  /**\n   * Convert a value to a string that is actually rendered.\n   */\n  function toString (val) {\n    return val == null\n      ? ''\n      : Array.isArray(val) || (isPlainObject(val) && val.toString === _toString)\n        ? JSON.stringify(val, null, 2)\n        : String(val)\n  }\n\n  /**\n   * Convert an input value to a number for persistence.\n   * If the conversion fails, return original string.\n   */\n  function toNumber (val) {\n    var n = parseFloat(val);\n    return isNaN(n) ? val : n\n  }\n\n  /**\n   * Make a map and return a function for checking if a key\n   * is in that map.\n   */\n  function makeMap (\n    str,\n    expectsLowerCase\n  ) {\n    var map = Object.create(null);\n    var list = str.split(',');\n    for (var i = 0; i < list.length; i++) {\n      map[list[i]] = true;\n    }\n    return expectsLowerCase\n      ? function (val) { return map[val.toLowerCase()]; }\n      : function (val) { return map[val]; }\n  }\n\n  /**\n   * Check if a tag is a built-in tag.\n   */\n  var isBuiltInTag = makeMap('slot,component', true);\n\n  /**\n   * Check if an attribute is a reserved attribute.\n   */\n  var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');\n\n  /**\n   * Remove an item from an array.\n   */\n  function remove (arr, item) {\n    if (arr.length) {\n      var index = arr.indexOf(item);\n      if (index > -1) {\n        return arr.splice(index, 1)\n      }\n    }\n  }\n\n  /**\n   * Check whether an object has the property.\n   */\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  function hasOwn (obj, key) {\n    return hasOwnProperty.call(obj, key)\n  }\n\n  /**\n   * Create a cached version of a pure function.\n   */\n  function cached (fn) {\n    var cache = Object.create(null);\n    return (function cachedFn (str) {\n      var hit = cache[str];\n      return hit || (cache[str] = fn(str))\n    })\n  }\n\n  /**\n   * Camelize a hyphen-delimited string.\n   */\n  var camelizeRE = /-(\\w)/g;\n  var camelize = cached(function (str) {\n    return str.replace(camelizeRE, function (_, c) { return c ? c.toUpperCase() : ''; })\n  });\n\n  /**\n   * Capitalize a string.\n   */\n  var capitalize = cached(function (str) {\n    return str.charAt(0).toUpperCase() + str.slice(1)\n  });\n\n  /**\n   * Hyphenate a camelCase string.\n   */\n  var hyphenateRE = /\\B([A-Z])/g;\n  var hyphenate = cached(function (str) {\n    return str.replace(hyphenateRE, '-$1').toLowerCase()\n  });\n\n  /**\n   * Simple bind polyfill for environments that do not support it,\n   * e.g., PhantomJS 1.x. Technically, we don't need this anymore\n   * since native bind is now performant enough in most browsers.\n   * But removing it would mean breaking code that was able to run in\n   * PhantomJS 1.x, so this must be kept for backward compatibility.\n   */\n\n  /* istanbul ignore next */\n  function polyfillBind (fn, ctx) {\n    function boundFn (a) {\n      var l = arguments.length;\n      return l\n        ? l > 1\n          ? fn.apply(ctx, arguments)\n          : fn.call(ctx, a)\n        : fn.call(ctx)\n    }\n\n    boundFn._length = fn.length;\n    return boundFn\n  }\n\n  function nativeBind (fn, ctx) {\n    return fn.bind(ctx)\n  }\n\n  var bind = Function.prototype.bind\n    ? nativeBind\n    : polyfillBind;\n\n  /**\n   * Convert an Array-like object to a real Array.\n   */\n  function toArray (list, start) {\n    start = start || 0;\n    var i = list.length - start;\n    var ret = new Array(i);\n    while (i--) {\n      ret[i] = list[i + start];\n    }\n    return ret\n  }\n\n  /**\n   * Mix properties into target object.\n   */\n  function extend (to, _from) {\n    for (var key in _from) {\n      to[key] = _from[key];\n    }\n    return to\n  }\n\n  /**\n   * Merge an Array of Objects into a single Object.\n   */\n  function toObject (arr) {\n    var res = {};\n    for (var i = 0; i < arr.length; i++) {\n      if (arr[i]) {\n        extend(res, arr[i]);\n      }\n    }\n    return res\n  }\n\n  /* eslint-disable no-unused-vars */\n\n  /**\n   * Perform no operation.\n   * Stubbing args to make Flow happy without leaving useless transpiled code\n   * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/).\n   */\n  function noop (a, b, c) {}\n\n  /**\n   * Always return false.\n   */\n  var no = function (a, b, c) { return false; };\n\n  /* eslint-enable no-unused-vars */\n\n  /**\n   * Return the same value.\n   */\n  var identity = function (_) { return _; };\n\n  /**\n   * Generate a string containing static keys from compiler modules.\n   */\n  function genStaticKeys (modules) {\n    return modules.reduce(function (keys, m) {\n      return keys.concat(m.staticKeys || [])\n    }, []).join(',')\n  }\n\n  /**\n   * Check if two values are loosely equal - that is,\n   * if they are plain objects, do they have the same shape?\n   */\n  function looseEqual (a, b) {\n    if (a === b) { return true }\n    var isObjectA = isObject(a);\n    var isObjectB = isObject(b);\n    if (isObjectA && isObjectB) {\n      try {\n        var isArrayA = Array.isArray(a);\n        var isArrayB = Array.isArray(b);\n        if (isArrayA && isArrayB) {\n          return a.length === b.length && a.every(function (e, i) {\n            return looseEqual(e, b[i])\n          })\n        } else if (a instanceof Date && b instanceof Date) {\n          return a.getTime() === b.getTime()\n        } else if (!isArrayA && !isArrayB) {\n          var keysA = Object.keys(a);\n          var keysB = Object.keys(b);\n          return keysA.length === keysB.length && keysA.every(function (key) {\n            return looseEqual(a[key], b[key])\n          })\n        } else {\n          /* istanbul ignore next */\n          return false\n        }\n      } catch (e) {\n        /* istanbul ignore next */\n        return false\n      }\n    } else if (!isObjectA && !isObjectB) {\n      return String(a) === String(b)\n    } else {\n      return false\n    }\n  }\n\n  /**\n   * Return the first index at which a loosely equal value can be\n   * found in the array (if value is a plain object, the array must\n   * contain an object of the same shape), or -1 if it is not present.\n   */\n  function looseIndexOf (arr, val) {\n    for (var i = 0; i < arr.length; i++) {\n      if (looseEqual(arr[i], val)) { return i }\n    }\n    return -1\n  }\n\n  /**\n   * Ensure a function is called only once.\n   */\n  function once (fn) {\n    var called = false;\n    return function () {\n      if (!called) {\n        called = true;\n        fn.apply(this, arguments);\n      }\n    }\n  }\n\n  var SSR_ATTR = 'data-server-rendered';\n\n  var ASSET_TYPES = [\n    'component',\n    'directive',\n    'filter'\n  ];\n\n  var LIFECYCLE_HOOKS = [\n    'beforeCreate',\n    'created',\n    'beforeMount',\n    'mounted',\n    'beforeUpdate',\n    'updated',\n    'beforeDestroy',\n    'destroyed',\n    'activated',\n    'deactivated',\n    'errorCaptured',\n    'serverPrefetch'\n  ];\n\n  /*  */\n\n\n\n  var config = ({\n    /**\n     * Option merge strategies (used in core/util/options)\n     */\n    // $flow-disable-line\n    optionMergeStrategies: Object.create(null),\n\n    /**\n     * Whether to suppress warnings.\n     */\n    silent: false,\n\n    /**\n     * Show production mode tip message on boot?\n     */\n    productionTip: \"development\" !== 'production',\n\n    /**\n     * Whether to enable devtools\n     */\n    devtools: \"development\" !== 'production',\n\n    /**\n     * Whether to record perf\n     */\n    performance: false,\n\n    /**\n     * Error handler for watcher errors\n     */\n    errorHandler: null,\n\n    /**\n     * Warn handler for watcher warns\n     */\n    warnHandler: null,\n\n    /**\n     * Ignore certain custom elements\n     */\n    ignoredElements: [],\n\n    /**\n     * Custom user key aliases for v-on\n     */\n    // $flow-disable-line\n    keyCodes: Object.create(null),\n\n    /**\n     * Check if a tag is reserved so that it cannot be registered as a\n     * component. This is platform-dependent and may be overwritten.\n     */\n    isReservedTag: no,\n\n    /**\n     * Check if an attribute is reserved so that it cannot be used as a component\n     * prop. This is platform-dependent and may be overwritten.\n     */\n    isReservedAttr: no,\n\n    /**\n     * Check if a tag is an unknown element.\n     * Platform-dependent.\n     */\n    isUnknownElement: no,\n\n    /**\n     * Get the namespace of an element\n     */\n    getTagNamespace: noop,\n\n    /**\n     * Parse the real tag name for the specific platform.\n     */\n    parsePlatformTagName: identity,\n\n    /**\n     * Check if an attribute must be bound using property, e.g. value\n     * Platform-dependent.\n     */\n    mustUseProp: no,\n\n    /**\n     * Perform updates asynchronously. Intended to be used by Vue Test Utils\n     * This will significantly reduce performance if set to false.\n     */\n    async: true,\n\n    /**\n     * Exposed for legacy reasons\n     */\n    _lifecycleHooks: LIFECYCLE_HOOKS\n  });\n\n  /*  */\n\n  /**\n   * unicode letters used for parsing html tags, component names and property paths.\n   * using https://www.w3.org/TR/html53/semantics-scripting.html#potentialcustomelementname\n   * skipping \\u10000-\\uEFFFF due to it freezing up PhantomJS\n   */\n  var unicodeRegExp = /a-zA-Z\\u00B7\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u203F-\\u2040\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD/;\n\n  /**\n   * Check if a string starts with $ or _\n   */\n  function isReserved (str) {\n    var c = (str + '').charCodeAt(0);\n    return c === 0x24 || c === 0x5F\n  }\n\n  /**\n   * Define a property.\n   */\n  function def (obj, key, val, enumerable) {\n    Object.defineProperty(obj, key, {\n      value: val,\n      enumerable: !!enumerable,\n      writable: true,\n      configurable: true\n    });\n  }\n\n  /**\n   * Parse simple path.\n   */\n  var bailRE = new RegExp((\"[^\" + (unicodeRegExp.source) + \".$_\\\\d]\"));\n  function parsePath (path) {\n    if (bailRE.test(path)) {\n      return\n    }\n    var segments = path.split('.');\n    return function (obj) {\n      for (var i = 0; i < segments.length; i++) {\n        if (!obj) { return }\n        obj = obj[segments[i]];\n      }\n      return obj\n    }\n  }\n\n  /*  */\n\n  // can we use __proto__?\n  var hasProto = '__proto__' in {};\n\n  // Browser environment sniffing\n  var inBrowser = typeof window !== 'undefined';\n  var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;\n  var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();\n  var UA = inBrowser && window.navigator.userAgent.toLowerCase();\n  var isIE = UA && /msie|trident/.test(UA);\n  var isIE9 = UA && UA.indexOf('msie 9.0') > 0;\n  var isEdge = UA && UA.indexOf('edge/') > 0;\n  var isAndroid = (UA && UA.indexOf('android') > 0) || (weexPlatform === 'android');\n  var isIOS = (UA && /iphone|ipad|ipod|ios/.test(UA)) || (weexPlatform === 'ios');\n  var isChrome = UA && /chrome\\/\\d+/.test(UA) && !isEdge;\n  var isPhantomJS = UA && /phantomjs/.test(UA);\n  var isFF = UA && UA.match(/firefox\\/(\\d+)/);\n\n  // Firefox has a \"watch\" function on Object.prototype...\n  var nativeWatch = ({}).watch;\n\n  var supportsPassive = false;\n  if (inBrowser) {\n    try {\n      var opts = {};\n      Object.defineProperty(opts, 'passive', ({\n        get: function get () {\n          /* istanbul ignore next */\n          supportsPassive = true;\n        }\n      })); // https://github.com/facebook/flow/issues/285\n      window.addEventListener('test-passive', null, opts);\n    } catch (e) {}\n  }\n\n  // this needs to be lazy-evaled because vue may be required before\n  // vue-server-renderer can set VUE_ENV\n  var _isServer;\n  var isServerRendering = function () {\n    if (_isServer === undefined) {\n      /* istanbul ignore if */\n      if (!inBrowser && !inWeex && typeof global !== 'undefined') {\n        // detect presence of vue-server-renderer and avoid\n        // Webpack shimming the process\n        _isServer = global['process'] && global['process'].env.VUE_ENV === 'server';\n      } else {\n        _isServer = false;\n      }\n    }\n    return _isServer\n  };\n\n  // detect devtools\n  var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;\n\n  /* istanbul ignore next */\n  function isNative (Ctor) {\n    return typeof Ctor === 'function' && /native code/.test(Ctor.toString())\n  }\n\n  var hasSymbol =\n    typeof Symbol !== 'undefined' && isNative(Symbol) &&\n    typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);\n\n  var _Set;\n  /* istanbul ignore if */ // $flow-disable-line\n  if (typeof Set !== 'undefined' && isNative(Set)) {\n    // use native Set when available.\n    _Set = Set;\n  } else {\n    // a non-standard Set polyfill that only works with primitive keys.\n    _Set = /*@__PURE__*/(function () {\n      function Set () {\n        this.set = Object.create(null);\n      }\n      Set.prototype.has = function has (key) {\n        return this.set[key] === true\n      };\n      Set.prototype.add = function add (key) {\n        this.set[key] = true;\n      };\n      Set.prototype.clear = function clear () {\n        this.set = Object.create(null);\n      };\n\n      return Set;\n    }());\n  }\n\n  /*  */\n\n  var warn = noop;\n  var tip = noop;\n  var generateComponentTrace = (noop); // work around flow check\n  var formatComponentName = (noop);\n\n  {\n    var hasConsole = typeof console !== 'undefined';\n    var classifyRE = /(?:^|[-_])(\\w)/g;\n    var classify = function (str) { return str\n      .replace(classifyRE, function (c) { return c.toUpperCase(); })\n      .replace(/[-_]/g, ''); };\n\n    warn = function (msg, vm) {\n      var trace = vm ? generateComponentTrace(vm) : '';\n\n      if (config.warnHandler) {\n        config.warnHandler.call(null, msg, vm, trace);\n      } else if (hasConsole && (!config.silent)) {\n        console.error((\"[Vue warn]: \" + msg + trace));\n      }\n    };\n\n    tip = function (msg, vm) {\n      if (hasConsole && (!config.silent)) {\n        console.warn(\"[Vue tip]: \" + msg + (\n          vm ? generateComponentTrace(vm) : ''\n        ));\n      }\n    };\n\n    formatComponentName = function (vm, includeFile) {\n      if (vm.$root === vm) {\n        return '<Root>'\n      }\n      var options = typeof vm === 'function' && vm.cid != null\n        ? vm.options\n        : vm._isVue\n          ? vm.$options || vm.constructor.options\n          : vm;\n      var name = options.name || options._componentTag;\n      var file = options.__file;\n      if (!name && file) {\n        var match = file.match(/([^/\\\\]+)\\.vue$/);\n        name = match && match[1];\n      }\n\n      return (\n        (name ? (\"<\" + (classify(name)) + \">\") : \"<Anonymous>\") +\n        (file && includeFile !== false ? (\" at \" + file) : '')\n      )\n    };\n\n    var repeat = function (str, n) {\n      var res = '';\n      while (n) {\n        if (n % 2 === 1) { res += str; }\n        if (n > 1) { str += str; }\n        n >>= 1;\n      }\n      return res\n    };\n\n    generateComponentTrace = function (vm) {\n      if (vm._isVue && vm.$parent) {\n        var tree = [];\n        var currentRecursiveSequence = 0;\n        while (vm) {\n          if (tree.length > 0) {\n            var last = tree[tree.length - 1];\n            if (last.constructor === vm.constructor) {\n              currentRecursiveSequence++;\n              vm = vm.$parent;\n              continue\n            } else if (currentRecursiveSequence > 0) {\n              tree[tree.length - 1] = [last, currentRecursiveSequence];\n              currentRecursiveSequence = 0;\n            }\n          }\n          tree.push(vm);\n          vm = vm.$parent;\n        }\n        return '\\n\\nfound in\\n\\n' + tree\n          .map(function (vm, i) { return (\"\" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm)\n              ? ((formatComponentName(vm[0])) + \"... (\" + (vm[1]) + \" recursive calls)\")\n              : formatComponentName(vm))); })\n          .join('\\n')\n      } else {\n        return (\"\\n\\n(found in \" + (formatComponentName(vm)) + \")\")\n      }\n    };\n  }\n\n  /*  */\n\n  var uid = 0;\n\n  /**\n   * A dep is an observable that can have multiple\n   * directives subscribing to it.\n   */\n  var Dep = function Dep () {\n    this.id = uid++;\n    this.subs = [];\n  };\n\n  Dep.prototype.addSub = function addSub (sub) {\n    this.subs.push(sub);\n  };\n\n  Dep.prototype.removeSub = function removeSub (sub) {\n    remove(this.subs, sub);\n  };\n\n  Dep.prototype.depend = function depend () {\n    if (Dep.target) {\n      Dep.target.addDep(this);\n    }\n  };\n\n  Dep.prototype.notify = function notify () {\n    // stabilize the subscriber list first\n    var subs = this.subs.slice();\n    if (!config.async) {\n      // subs aren't sorted in scheduler if not running async\n      // we need to sort them now to make sure they fire in correct\n      // order\n      subs.sort(function (a, b) { return a.id - b.id; });\n    }\n    for (var i = 0, l = subs.length; i < l; i++) {\n      subs[i].update();\n    }\n  };\n\n  // The current target watcher being evaluated.\n  // This is globally unique because only one watcher\n  // can be evaluated at a time.\n  Dep.target = null;\n  var targetStack = [];\n\n  function pushTarget (target) {\n    targetStack.push(target);\n    Dep.target = target;\n  }\n\n  function popTarget () {\n    targetStack.pop();\n    Dep.target = targetStack[targetStack.length - 1];\n  }\n\n  /*  */\n\n  var VNode = function VNode (\n    tag,\n    data,\n    children,\n    text,\n    elm,\n    context,\n    componentOptions,\n    asyncFactory\n  ) {\n    this.tag = tag;\n    this.data = data;\n    this.children = children;\n    this.text = text;\n    this.elm = elm;\n    this.ns = undefined;\n    this.context = context;\n    this.fnContext = undefined;\n    this.fnOptions = undefined;\n    this.fnScopeId = undefined;\n    this.key = data && data.key;\n    this.componentOptions = componentOptions;\n    this.componentInstance = undefined;\n    this.parent = undefined;\n    this.raw = false;\n    this.isStatic = false;\n    this.isRootInsert = true;\n    this.isComment = false;\n    this.isCloned = false;\n    this.isOnce = false;\n    this.asyncFactory = asyncFactory;\n    this.asyncMeta = undefined;\n    this.isAsyncPlaceholder = false;\n  };\n\n  var prototypeAccessors = { child: { configurable: true } };\n\n  // DEPRECATED: alias for componentInstance for backwards compat.\n  /* istanbul ignore next */\n  prototypeAccessors.child.get = function () {\n    return this.componentInstance\n  };\n\n  Object.defineProperties( VNode.prototype, prototypeAccessors );\n\n  var createEmptyVNode = function (text) {\n    if ( text === void 0 ) text = '';\n\n    var node = new VNode();\n    node.text = text;\n    node.isComment = true;\n    return node\n  };\n\n  function createTextVNode (val) {\n    return new VNode(undefined, undefined, undefined, String(val))\n  }\n\n  // optimized shallow clone\n  // used for static nodes and slot nodes because they may be reused across\n  // multiple renders, cloning them avoids errors when DOM manipulations rely\n  // on their elm reference.\n  function cloneVNode (vnode) {\n    var cloned = new VNode(\n      vnode.tag,\n      vnode.data,\n      // #7975\n      // clone children array to avoid mutating original in case of cloning\n      // a child.\n      vnode.children && vnode.children.slice(),\n      vnode.text,\n      vnode.elm,\n      vnode.context,\n      vnode.componentOptions,\n      vnode.asyncFactory\n    );\n    cloned.ns = vnode.ns;\n    cloned.isStatic = vnode.isStatic;\n    cloned.key = vnode.key;\n    cloned.isComment = vnode.isComment;\n    cloned.fnContext = vnode.fnContext;\n    cloned.fnOptions = vnode.fnOptions;\n    cloned.fnScopeId = vnode.fnScopeId;\n    cloned.asyncMeta = vnode.asyncMeta;\n    cloned.isCloned = true;\n    return cloned\n  }\n\n  /*\n   * not type checking this file because flow doesn't play well with\n   * dynamically accessing methods on Array prototype\n   */\n\n  var arrayProto = Array.prototype;\n  var arrayMethods = Object.create(arrayProto);\n\n  var methodsToPatch = [\n    'push',\n    'pop',\n    'shift',\n    'unshift',\n    'splice',\n    'sort',\n    'reverse'\n  ];\n\n  /**\n   * Intercept mutating methods and emit events\n   */\n  methodsToPatch.forEach(function (method) {\n    // cache original method\n    var original = arrayProto[method];\n    def(arrayMethods, method, function mutator () {\n      var args = [], len = arguments.length;\n      while ( len-- ) args[ len ] = arguments[ len ];\n\n      var result = original.apply(this, args);\n      var ob = this.__ob__;\n      var inserted;\n      switch (method) {\n        case 'push':\n        case 'unshift':\n          inserted = args;\n          break\n        case 'splice':\n          inserted = args.slice(2);\n          break\n      }\n      if (inserted) { ob.observeArray(inserted); }\n      // notify change\n      ob.dep.notify();\n      return result\n    });\n  });\n\n  /*  */\n\n  var arrayKeys = Object.getOwnPropertyNames(arrayMethods);\n\n  /**\n   * In some cases we may want to disable observation inside a component's\n   * update computation.\n   */\n  var shouldObserve = true;\n\n  function toggleObserving (value) {\n    shouldObserve = value;\n  }\n\n  /**\n   * Observer class that is attached to each observed\n   * object. Once attached, the observer converts the target\n   * object's property keys into getter/setters that\n   * collect dependencies and dispatch updates.\n   */\n  var Observer = function Observer (value) {\n    this.value = value;\n    this.dep = new Dep();\n    this.vmCount = 0;\n    def(value, '__ob__', this);\n    if (Array.isArray(value)) {\n      if (hasProto) {\n        protoAugment(value, arrayMethods);\n      } else {\n        copyAugment(value, arrayMethods, arrayKeys);\n      }\n      this.observeArray(value);\n    } else {\n      this.walk(value);\n    }\n  };\n\n  /**\n   * Walk through all properties and convert them into\n   * getter/setters. This method should only be called when\n   * value type is Object.\n   */\n  Observer.prototype.walk = function walk (obj) {\n    var keys = Object.keys(obj);\n    for (var i = 0; i < keys.length; i++) {\n      defineReactive$$1(obj, keys[i]);\n    }\n  };\n\n  /**\n   * Observe a list of Array items.\n   */\n  Observer.prototype.observeArray = function observeArray (items) {\n    for (var i = 0, l = items.length; i < l; i++) {\n      observe(items[i]);\n    }\n  };\n\n  // helpers\n\n  /**\n   * Augment a target Object or Array by intercepting\n   * the prototype chain using __proto__\n   */\n  function protoAugment (target, src) {\n    /* eslint-disable no-proto */\n    target.__proto__ = src;\n    /* eslint-enable no-proto */\n  }\n\n  /**\n   * Augment a target Object or Array by defining\n   * hidden properties.\n   */\n  /* istanbul ignore next */\n  function copyAugment (target, src, keys) {\n    for (var i = 0, l = keys.length; i < l; i++) {\n      var key = keys[i];\n      def(target, key, src[key]);\n    }\n  }\n\n  /**\n   * Attempt to create an observer instance for a value,\n   * returns the new observer if successfully observed,\n   * or the existing observer if the value already has one.\n   */\n  function observe (value, asRootData) {\n    if (!isObject(value) || value instanceof VNode) {\n      return\n    }\n    var ob;\n    if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {\n      ob = value.__ob__;\n    } else if (\n      shouldObserve &&\n      !isServerRendering() &&\n      (Array.isArray(value) || isPlainObject(value)) &&\n      Object.isExtensible(value) &&\n      !value._isVue\n    ) {\n      ob = new Observer(value);\n    }\n    if (asRootData && ob) {\n      ob.vmCount++;\n    }\n    return ob\n  }\n\n  /**\n   * Define a reactive property on an Object.\n   */\n  function defineReactive$$1 (\n    obj,\n    key,\n    val,\n    customSetter,\n    shallow\n  ) {\n    var dep = new Dep();\n\n    var property = Object.getOwnPropertyDescriptor(obj, key);\n    if (property && property.configurable === false) {\n      return\n    }\n\n    // cater for pre-defined getter/setters\n    var getter = property && property.get;\n    var setter = property && property.set;\n    if ((!getter || setter) && arguments.length === 2) {\n      val = obj[key];\n    }\n\n    var childOb = !shallow && observe(val);\n    Object.defineProperty(obj, key, {\n      enumerable: true,\n      configurable: true,\n      get: function reactiveGetter () {\n        var value = getter ? getter.call(obj) : val;\n        if (Dep.target) {\n          dep.depend();\n          if (childOb) {\n            childOb.dep.depend();\n            if (Array.isArray(value)) {\n              dependArray(value);\n            }\n          }\n        }\n        return value\n      },\n      set: function reactiveSetter (newVal) {\n        var value = getter ? getter.call(obj) : val;\n        /* eslint-disable no-self-compare */\n        if (newVal === value || (newVal !== newVal && value !== value)) {\n          return\n        }\n        /* eslint-enable no-self-compare */\n        if (customSetter) {\n          customSetter();\n        }\n        // #7981: for accessor properties without setter\n        if (getter && !setter) { return }\n        if (setter) {\n          setter.call(obj, newVal);\n        } else {\n          val = newVal;\n        }\n        childOb = !shallow && observe(newVal);\n        dep.notify();\n      }\n    });\n  }\n\n  /**\n   * Set a property on an object. Adds the new property and\n   * triggers change notification if the property doesn't\n   * already exist.\n   */\n  function set (target, key, val) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot set reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.length = Math.max(target.length, key);\n      target.splice(key, 1, val);\n      return val\n    }\n    if (key in target && !(key in Object.prototype)) {\n      target[key] = val;\n      return val\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid adding reactive properties to a Vue instance or its root $data ' +\n        'at runtime - declare it upfront in the data option.'\n      );\n      return val\n    }\n    if (!ob) {\n      target[key] = val;\n      return val\n    }\n    defineReactive$$1(ob.value, key, val);\n    ob.dep.notify();\n    return val\n  }\n\n  /**\n   * Delete a property and trigger change if necessary.\n   */\n  function del (target, key) {\n    if (isUndef(target) || isPrimitive(target)\n    ) {\n      warn((\"Cannot delete reactive property on undefined, null, or primitive value: \" + ((target))));\n    }\n    if (Array.isArray(target) && isValidArrayIndex(key)) {\n      target.splice(key, 1);\n      return\n    }\n    var ob = (target).__ob__;\n    if (target._isVue || (ob && ob.vmCount)) {\n      warn(\n        'Avoid deleting properties on a Vue instance or its root $data ' +\n        '- just set it to null.'\n      );\n      return\n    }\n    if (!hasOwn(target, key)) {\n      return\n    }\n    delete target[key];\n    if (!ob) {\n      return\n    }\n    ob.dep.notify();\n  }\n\n  /**\n   * Collect dependencies on array elements when the array is touched, since\n   * we cannot intercept array element access like property getters.\n   */\n  function dependArray (value) {\n    for (var e = (void 0), i = 0, l = value.length; i < l; i++) {\n      e = value[i];\n      e && e.__ob__ && e.__ob__.dep.depend();\n      if (Array.isArray(e)) {\n        dependArray(e);\n      }\n    }\n  }\n\n  /*  */\n\n  /**\n   * Option overwriting strategies are functions that handle\n   * how to merge a parent option value and a child option\n   * value into the final value.\n   */\n  var strats = config.optionMergeStrategies;\n\n  /**\n   * Options with restrictions\n   */\n  {\n    strats.el = strats.propsData = function (parent, child, vm, key) {\n      if (!vm) {\n        warn(\n          \"option \\\"\" + key + \"\\\" can only be used during instance \" +\n          'creation with the `new` keyword.'\n        );\n      }\n      return defaultStrat(parent, child)\n    };\n  }\n\n  /**\n   * Helper that recursively merges two data objects together.\n   */\n  function mergeData (to, from) {\n    if (!from) { return to }\n    var key, toVal, fromVal;\n\n    var keys = hasSymbol\n      ? Reflect.ownKeys(from)\n      : Object.keys(from);\n\n    for (var i = 0; i < keys.length; i++) {\n      key = keys[i];\n      // in case the object is already observed...\n      if (key === '__ob__') { continue }\n      toVal = to[key];\n      fromVal = from[key];\n      if (!hasOwn(to, key)) {\n        set(to, key, fromVal);\n      } else if (\n        toVal !== fromVal &&\n        isPlainObject(toVal) &&\n        isPlainObject(fromVal)\n      ) {\n        mergeData(toVal, fromVal);\n      }\n    }\n    return to\n  }\n\n  /**\n   * Data\n   */\n  function mergeDataOrFn (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      // in a Vue.extend merge, both should be functions\n      if (!childVal) {\n        return parentVal\n      }\n      if (!parentVal) {\n        return childVal\n      }\n      // when parentVal & childVal are both present,\n      // we need to return a function that returns the\n      // merged result of both functions... no need to\n      // check if parentVal is a function here because\n      // it has to be a function to pass previous merges.\n      return function mergedDataFn () {\n        return mergeData(\n          typeof childVal === 'function' ? childVal.call(this, this) : childVal,\n          typeof parentVal === 'function' ? parentVal.call(this, this) : parentVal\n        )\n      }\n    } else {\n      return function mergedInstanceDataFn () {\n        // instance merge\n        var instanceData = typeof childVal === 'function'\n          ? childVal.call(vm, vm)\n          : childVal;\n        var defaultData = typeof parentVal === 'function'\n          ? parentVal.call(vm, vm)\n          : parentVal;\n        if (instanceData) {\n          return mergeData(instanceData, defaultData)\n        } else {\n          return defaultData\n        }\n      }\n    }\n  }\n\n  strats.data = function (\n    parentVal,\n    childVal,\n    vm\n  ) {\n    if (!vm) {\n      if (childVal && typeof childVal !== 'function') {\n        warn(\n          'The \"data\" option should be a function ' +\n          'that returns a per-instance value in component ' +\n          'definitions.',\n          vm\n        );\n\n        return parentVal\n      }\n      return mergeDataOrFn(parentVal, childVal)\n    }\n\n    return mergeDataOrFn(parentVal, childVal, vm)\n  };\n\n  /**\n   * Hooks and props are merged as arrays.\n   */\n  function mergeHook (\n    parentVal,\n    childVal\n  ) {\n    var res = childVal\n      ? parentVal\n        ? parentVal.concat(childVal)\n        : Array.isArray(childVal)\n          ? childVal\n          : [childVal]\n      : parentVal;\n    return res\n      ? dedupeHooks(res)\n      : res\n  }\n\n  function dedupeHooks (hooks) {\n    var res = [];\n    for (var i = 0; i < hooks.length; i++) {\n      if (res.indexOf(hooks[i]) === -1) {\n        res.push(hooks[i]);\n      }\n    }\n    return res\n  }\n\n  LIFECYCLE_HOOKS.forEach(function (hook) {\n    strats[hook] = mergeHook;\n  });\n\n  /**\n   * Assets\n   *\n   * When a vm is present (instance creation), we need to do\n   * a three-way merge between constructor options, instance\n   * options and parent options.\n   */\n  function mergeAssets (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    var res = Object.create(parentVal || null);\n    if (childVal) {\n      assertObjectType(key, childVal, vm);\n      return extend(res, childVal)\n    } else {\n      return res\n    }\n  }\n\n  ASSET_TYPES.forEach(function (type) {\n    strats[type + 's'] = mergeAssets;\n  });\n\n  /**\n   * Watchers.\n   *\n   * Watchers hashes should not overwrite one\n   * another, so we merge them as arrays.\n   */\n  strats.watch = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    // work around Firefox's Object.prototype.watch...\n    if (parentVal === nativeWatch) { parentVal = undefined; }\n    if (childVal === nativeWatch) { childVal = undefined; }\n    /* istanbul ignore if */\n    if (!childVal) { return Object.create(parentVal || null) }\n    {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = {};\n    extend(ret, parentVal);\n    for (var key$1 in childVal) {\n      var parent = ret[key$1];\n      var child = childVal[key$1];\n      if (parent && !Array.isArray(parent)) {\n        parent = [parent];\n      }\n      ret[key$1] = parent\n        ? parent.concat(child)\n        : Array.isArray(child) ? child : [child];\n    }\n    return ret\n  };\n\n  /**\n   * Other object hashes.\n   */\n  strats.props =\n  strats.methods =\n  strats.inject =\n  strats.computed = function (\n    parentVal,\n    childVal,\n    vm,\n    key\n  ) {\n    if (childVal && \"development\" !== 'production') {\n      assertObjectType(key, childVal, vm);\n    }\n    if (!parentVal) { return childVal }\n    var ret = Object.create(null);\n    extend(ret, parentVal);\n    if (childVal) { extend(ret, childVal); }\n    return ret\n  };\n  strats.provide = mergeDataOrFn;\n\n  /**\n   * Default strategy.\n   */\n  var defaultStrat = function (parentVal, childVal) {\n    return childVal === undefined\n      ? parentVal\n      : childVal\n  };\n\n  /**\n   * Validate component names\n   */\n  function checkComponents (options) {\n    for (var key in options.components) {\n      validateComponentName(key);\n    }\n  }\n\n  function validateComponentName (name) {\n    if (!new RegExp((\"^[a-zA-Z][\\\\-\\\\.0-9_\" + (unicodeRegExp.source) + \"]*$\")).test(name)) {\n      warn(\n        'Invalid component name: \"' + name + '\". Component names ' +\n        'should conform to valid custom element name in html5 specification.'\n      );\n    }\n    if (isBuiltInTag(name) || config.isReservedTag(name)) {\n      warn(\n        'Do not use built-in or reserved HTML elements as component ' +\n        'id: ' + name\n      );\n    }\n  }\n\n  /**\n   * Ensure all props option syntax are normalized into the\n   * Object-based format.\n   */\n  function normalizeProps (options, vm) {\n    var props = options.props;\n    if (!props) { return }\n    var res = {};\n    var i, val, name;\n    if (Array.isArray(props)) {\n      i = props.length;\n      while (i--) {\n        val = props[i];\n        if (typeof val === 'string') {\n          name = camelize(val);\n          res[name] = { type: null };\n        } else {\n          warn('props must be strings when using array syntax.');\n        }\n      }\n    } else if (isPlainObject(props)) {\n      for (var key in props) {\n        val = props[key];\n        name = camelize(key);\n        res[name] = isPlainObject(val)\n          ? val\n          : { type: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"props\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(props)) + \".\",\n        vm\n      );\n    }\n    options.props = res;\n  }\n\n  /**\n   * Normalize all injections into Object-based format\n   */\n  function normalizeInject (options, vm) {\n    var inject = options.inject;\n    if (!inject) { return }\n    var normalized = options.inject = {};\n    if (Array.isArray(inject)) {\n      for (var i = 0; i < inject.length; i++) {\n        normalized[inject[i]] = { from: inject[i] };\n      }\n    } else if (isPlainObject(inject)) {\n      for (var key in inject) {\n        var val = inject[key];\n        normalized[key] = isPlainObject(val)\n          ? extend({ from: key }, val)\n          : { from: val };\n      }\n    } else {\n      warn(\n        \"Invalid value for option \\\"inject\\\": expected an Array or an Object, \" +\n        \"but got \" + (toRawType(inject)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Normalize raw function directives into object format.\n   */\n  function normalizeDirectives (options) {\n    var dirs = options.directives;\n    if (dirs) {\n      for (var key in dirs) {\n        var def$$1 = dirs[key];\n        if (typeof def$$1 === 'function') {\n          dirs[key] = { bind: def$$1, update: def$$1 };\n        }\n      }\n    }\n  }\n\n  function assertObjectType (name, value, vm) {\n    if (!isPlainObject(value)) {\n      warn(\n        \"Invalid value for option \\\"\" + name + \"\\\": expected an Object, \" +\n        \"but got \" + (toRawType(value)) + \".\",\n        vm\n      );\n    }\n  }\n\n  /**\n   * Merge two option objects into a new one.\n   * Core utility used in both instantiation and inheritance.\n   */\n  function mergeOptions (\n    parent,\n    child,\n    vm\n  ) {\n    {\n      checkComponents(child);\n    }\n\n    if (typeof child === 'function') {\n      child = child.options;\n    }\n\n    normalizeProps(child, vm);\n    normalizeInject(child, vm);\n    normalizeDirectives(child);\n\n    // Apply extends and mixins on the child options,\n    // but only if it is a raw options object that isn't\n    // the result of another mergeOptions call.\n    // Only merged options has the _base property.\n    if (!child._base) {\n      if (child.extends) {\n        parent = mergeOptions(parent, child.extends, vm);\n      }\n      if (child.mixins) {\n        for (var i = 0, l = child.mixins.length; i < l; i++) {\n          parent = mergeOptions(parent, child.mixins[i], vm);\n        }\n      }\n    }\n\n    var options = {};\n    var key;\n    for (key in parent) {\n      mergeField(key);\n    }\n    for (key in child) {\n      if (!hasOwn(parent, key)) {\n        mergeField(key);\n      }\n    }\n    function mergeField (key) {\n      var strat = strats[key] || defaultStrat;\n      options[key] = strat(parent[key], child[key], vm, key);\n    }\n    return options\n  }\n\n  /**\n   * Resolve an asset.\n   * This function is used because child instances need access\n   * to assets defined in its ancestor chain.\n   */\n  function resolveAsset (\n    options,\n    type,\n    id,\n    warnMissing\n  ) {\n    /* istanbul ignore if */\n    if (typeof id !== 'string') {\n      return\n    }\n    var assets = options[type];\n    // check local registration variations first\n    if (hasOwn(assets, id)) { return assets[id] }\n    var camelizedId = camelize(id);\n    if (hasOwn(assets, camelizedId)) { return assets[camelizedId] }\n    var PascalCaseId = capitalize(camelizedId);\n    if (hasOwn(assets, PascalCaseId)) { return assets[PascalCaseId] }\n    // fallback to prototype chain\n    var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];\n    if (warnMissing && !res) {\n      warn(\n        'Failed to resolve ' + type.slice(0, -1) + ': ' + id,\n        options\n      );\n    }\n    return res\n  }\n\n  /*  */\n\n\n\n  function validateProp (\n    key,\n    propOptions,\n    propsData,\n    vm\n  ) {\n    var prop = propOptions[key];\n    var absent = !hasOwn(propsData, key);\n    var value = propsData[key];\n    // boolean casting\n    var booleanIndex = getTypeIndex(Boolean, prop.type);\n    if (booleanIndex > -1) {\n      if (absent && !hasOwn(prop, 'default')) {\n        value = false;\n      } else if (value === '' || value === hyphenate(key)) {\n        // only cast empty string / same name to boolean if\n        // boolean has higher priority\n        var stringIndex = getTypeIndex(String, prop.type);\n        if (stringIndex < 0 || booleanIndex < stringIndex) {\n          value = true;\n        }\n      }\n    }\n    // check default value\n    if (value === undefined) {\n      value = getPropDefaultValue(vm, prop, key);\n      // since the default value is a fresh copy,\n      // make sure to observe it.\n      var prevShouldObserve = shouldObserve;\n      toggleObserving(true);\n      observe(value);\n      toggleObserving(prevShouldObserve);\n    }\n    {\n      assertProp(prop, key, value, vm, absent);\n    }\n    return value\n  }\n\n  /**\n   * Get the default value of a prop.\n   */\n  function getPropDefaultValue (vm, prop, key) {\n    // no default, return undefined\n    if (!hasOwn(prop, 'default')) {\n      return undefined\n    }\n    var def = prop.default;\n    // warn against non-factory defaults for Object & Array\n    if (isObject(def)) {\n      warn(\n        'Invalid default value for prop \"' + key + '\": ' +\n        'Props with type Object/Array must use a factory function ' +\n        'to return the default value.',\n        vm\n      );\n    }\n    // the raw prop value was also undefined from previous render,\n    // return previous default value to avoid unnecessary watcher trigger\n    if (vm && vm.$options.propsData &&\n      vm.$options.propsData[key] === undefined &&\n      vm._props[key] !== undefined\n    ) {\n      return vm._props[key]\n    }\n    // call factory function for non-Function types\n    // a value is Function if its prototype is function even across different execution context\n    return typeof def === 'function' && getType(prop.type) !== 'Function'\n      ? def.call(vm)\n      : def\n  }\n\n  /**\n   * Assert whether a prop is valid.\n   */\n  function assertProp (\n    prop,\n    name,\n    value,\n    vm,\n    absent\n  ) {\n    if (prop.required && absent) {\n      warn(\n        'Missing required prop: \"' + name + '\"',\n        vm\n      );\n      return\n    }\n    if (value == null && !prop.required) {\n      return\n    }\n    var type = prop.type;\n    var valid = !type || type === true;\n    var expectedTypes = [];\n    if (type) {\n      if (!Array.isArray(type)) {\n        type = [type];\n      }\n      for (var i = 0; i < type.length && !valid; i++) {\n        var assertedType = assertType(value, type[i]);\n        expectedTypes.push(assertedType.expectedType || '');\n        valid = assertedType.valid;\n      }\n    }\n\n    if (!valid) {\n      warn(\n        getInvalidTypeMessage(name, value, expectedTypes),\n        vm\n      );\n      return\n    }\n    var validator = prop.validator;\n    if (validator) {\n      if (!validator(value)) {\n        warn(\n          'Invalid prop: custom validator check failed for prop \"' + name + '\".',\n          vm\n        );\n      }\n    }\n  }\n\n  var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;\n\n  function assertType (value, type) {\n    var valid;\n    var expectedType = getType(type);\n    if (simpleCheckRE.test(expectedType)) {\n      var t = typeof value;\n      valid = t === expectedType.toLowerCase();\n      // for primitive wrapper objects\n      if (!valid && t === 'object') {\n        valid = value instanceof type;\n      }\n    } else if (expectedType === 'Object') {\n      valid = isPlainObject(value);\n    } else if (expectedType === 'Array') {\n      valid = Array.isArray(value);\n    } else {\n      valid = value instanceof type;\n    }\n    return {\n      valid: valid,\n      expectedType: expectedType\n    }\n  }\n\n  /**\n   * Use function string name to check built-in types,\n   * because a simple equality check will fail when running\n   * across different vms / iframes.\n   */\n  function getType (fn) {\n    var match = fn && fn.toString().match(/^\\s*function (\\w+)/);\n    return match ? match[1] : ''\n  }\n\n  function isSameType (a, b) {\n    return getType(a) === getType(b)\n  }\n\n  function getTypeIndex (type, expectedTypes) {\n    if (!Array.isArray(expectedTypes)) {\n      return isSameType(expectedTypes, type) ? 0 : -1\n    }\n    for (var i = 0, len = expectedTypes.length; i < len; i++) {\n      if (isSameType(expectedTypes[i], type)) {\n        return i\n      }\n    }\n    return -1\n  }\n\n  function getInvalidTypeMessage (name, value, expectedTypes) {\n    var message = \"Invalid prop: type check failed for prop \\\"\" + name + \"\\\".\" +\n      \" Expected \" + (expectedTypes.map(capitalize).join(', '));\n    var expectedType = expectedTypes[0];\n    var receivedType = toRawType(value);\n    var expectedValue = styleValue(value, expectedType);\n    var receivedValue = styleValue(value, receivedType);\n    // check if we need to specify expected value\n    if (expectedTypes.length === 1 &&\n        isExplicable(expectedType) &&\n        !isBoolean(expectedType, receivedType)) {\n      message += \" with value \" + expectedValue;\n    }\n    message += \", got \" + receivedType + \" \";\n    // check if we need to specify received value\n    if (isExplicable(receivedType)) {\n      message += \"with value \" + receivedValue + \".\";\n    }\n    return message\n  }\n\n  function styleValue (value, type) {\n    if (type === 'String') {\n      return (\"\\\"\" + value + \"\\\"\")\n    } else if (type === 'Number') {\n      return (\"\" + (Number(value)))\n    } else {\n      return (\"\" + value)\n    }\n  }\n\n  function isExplicable (value) {\n    var explicitTypes = ['string', 'number', 'boolean'];\n    return explicitTypes.some(function (elem) { return value.toLowerCase() === elem; })\n  }\n\n  function isBoolean () {\n    var args = [], len = arguments.length;\n    while ( len-- ) args[ len ] = arguments[ len ];\n\n    return args.some(function (elem) { return elem.toLowerCase() === 'boolean'; })\n  }\n\n  /*  */\n\n  function handleError (err, vm, info) {\n    // Deactivate deps tracking while processing error handler to avoid possible infinite rendering.\n    // See: https://github.com/vuejs/vuex/issues/1505\n    pushTarget();\n    try {\n      if (vm) {\n        var cur = vm;\n        while ((cur = cur.$parent)) {\n          var hooks = cur.$options.errorCaptured;\n          if (hooks) {\n            for (var i = 0; i < hooks.length; i++) {\n              try {\n                var capture = hooks[i].call(cur, err, vm, info) === false;\n                if (capture) { return }\n              } catch (e) {\n                globalHandleError(e, cur, 'errorCaptured hook');\n              }\n            }\n          }\n        }\n      }\n      globalHandleError(err, vm, info);\n    } finally {\n      popTarget();\n    }\n  }\n\n  function invokeWithErrorHandling (\n    handler,\n    context,\n    args,\n    vm,\n    info\n  ) {\n    var res;\n    try {\n      res = args ? handler.apply(context, args) : handler.call(context);\n      if (res && !res._isVue && isPromise(res) && !res._handled) {\n        res.catch(function (e) { return handleError(e, vm, info + \" (Promise/async)\"); });\n        // issue #9511\n        // avoid catch triggering multiple times when nested calls\n        res._handled = true;\n      }\n    } catch (e) {\n      handleError(e, vm, info);\n    }\n    return res\n  }\n\n  function globalHandleError (err, vm, info) {\n    if (config.errorHandler) {\n      try {\n        return config.errorHandler.call(null, err, vm, info)\n      } catch (e) {\n        // if the user intentionally throws the original error in the handler,\n        // do not log it twice\n        if (e !== err) {\n          logError(e, null, 'config.errorHandler');\n        }\n      }\n    }\n    logError(err, vm, info);\n  }\n\n  function logError (err, vm, info) {\n    {\n      warn((\"Error in \" + info + \": \\\"\" + (err.toString()) + \"\\\"\"), vm);\n    }\n    /* istanbul ignore else */\n    if ((inBrowser || inWeex) && typeof console !== 'undefined') {\n      console.error(err);\n    } else {\n      throw err\n    }\n  }\n\n  /*  */\n\n  var isUsingMicroTask = false;\n\n  var callbacks = [];\n  var pending = false;\n\n  function flushCallbacks () {\n    pending = false;\n    var copies = callbacks.slice(0);\n    callbacks.length = 0;\n    for (var i = 0; i < copies.length; i++) {\n      copies[i]();\n    }\n  }\n\n  // Here we have async deferring wrappers using microtasks.\n  // In 2.5 we used (macro) tasks (in combination with microtasks).\n  // However, it has subtle problems when state is changed right before repaint\n  // (e.g. #6813, out-in transitions).\n  // Also, using (macro) tasks in event handler would cause some weird behaviors\n  // that cannot be circumvented (e.g. #7109, #7153, #7546, #7834, #8109).\n  // So we now use microtasks everywhere, again.\n  // A major drawback of this tradeoff is that there are some scenarios\n  // where microtasks have too high a priority and fire in between supposedly\n  // sequential events (e.g. #4521, #6690, which have workarounds)\n  // or even between bubbling of the same event (#6566).\n  var timerFunc;\n\n  // The nextTick behavior leverages the microtask queue, which can be accessed\n  // via either native Promise.then or MutationObserver.\n  // MutationObserver has wider support, however it is seriously bugged in\n  // UIWebView in iOS >= 9.3.3 when triggered in touch event handlers. It\n  // completely stops working after triggering a few times... so, if native\n  // Promise is available, we will use it:\n  /* istanbul ignore next, $flow-disable-line */\n  if (typeof Promise !== 'undefined' && isNative(Promise)) {\n    var p = Promise.resolve();\n    timerFunc = function () {\n      p.then(flushCallbacks);\n      // In problematic UIWebViews, Promise.then doesn't completely break, but\n      // it can get stuck in a weird state where callbacks are pushed into the\n      // microtask queue but the queue isn't being flushed, until the browser\n      // needs to do some other work, e.g. handle a timer. Therefore we can\n      // \"force\" the microtask queue to be flushed by adding an empty timer.\n      if (isIOS) { setTimeout(noop); }\n    };\n    isUsingMicroTask = true;\n  } else if (!isIE && typeof MutationObserver !== 'undefined' && (\n    isNative(MutationObserver) ||\n    // PhantomJS and iOS 7.x\n    MutationObserver.toString() === '[object MutationObserverConstructor]'\n  )) {\n    // Use MutationObserver where native Promise is not available,\n    // e.g. PhantomJS, iOS7, Android 4.4\n    // (#6466 MutationObserver is unreliable in IE11)\n    var counter = 1;\n    var observer = new MutationObserver(flushCallbacks);\n    var textNode = document.createTextNode(String(counter));\n    observer.observe(textNode, {\n      characterData: true\n    });\n    timerFunc = function () {\n      counter = (counter + 1) % 2;\n      textNode.data = String(counter);\n    };\n    isUsingMicroTask = true;\n  } else if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {\n    // Fallback to setImmediate.\n    // Techinically it leverages the (macro) task queue,\n    // but it is still a better choice than setTimeout.\n    timerFunc = function () {\n      setImmediate(flushCallbacks);\n    };\n  } else {\n    // Fallback to setTimeout.\n    timerFunc = function () {\n      setTimeout(flushCallbacks, 0);\n    };\n  }\n\n  function nextTick (cb, ctx) {\n    var _resolve;\n    callbacks.push(function () {\n      if (cb) {\n        try {\n          cb.call(ctx);\n        } catch (e) {\n          handleError(e, ctx, 'nextTick');\n        }\n      } else if (_resolve) {\n        _resolve(ctx);\n      }\n    });\n    if (!pending) {\n      pending = true;\n      timerFunc();\n    }\n    // $flow-disable-line\n    if (!cb && typeof Promise !== 'undefined') {\n      return new Promise(function (resolve) {\n        _resolve = resolve;\n      })\n    }\n  }\n\n  /*  */\n\n  var mark;\n  var measure;\n\n  {\n    var perf = inBrowser && window.performance;\n    /* istanbul ignore if */\n    if (\n      perf &&\n      perf.mark &&\n      perf.measure &&\n      perf.clearMarks &&\n      perf.clearMeasures\n    ) {\n      mark = function (tag) { return perf.mark(tag); };\n      measure = function (name, startTag, endTag) {\n        perf.measure(name, startTag, endTag);\n        perf.clearMarks(startTag);\n        perf.clearMarks(endTag);\n        // perf.clearMeasures(name)\n      };\n    }\n  }\n\n  /* not type checking this file because flow doesn't play well with Proxy */\n\n  var initProxy;\n\n  {\n    var allowedGlobals = makeMap(\n      'Infinity,undefined,NaN,isFinite,isNaN,' +\n      'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' +\n      'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' +\n      'require' // for Webpack/Browserify\n    );\n\n    var warnNonPresent = function (target, key) {\n      warn(\n        \"Property or method \\\"\" + key + \"\\\" is not defined on the instance but \" +\n        'referenced during render. Make sure that this property is reactive, ' +\n        'either in the data option, or for class-based components, by ' +\n        'initializing the property. ' +\n        'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.',\n        target\n      );\n    };\n\n    var warnReservedPrefix = function (target, key) {\n      warn(\n        \"Property \\\"\" + key + \"\\\" must be accessed with \\\"$data.\" + key + \"\\\" because \" +\n        'properties starting with \"$\" or \"_\" are not proxied in the Vue instance to ' +\n        'prevent conflicts with Vue internals' +\n        'See: https://vuejs.org/v2/api/#data',\n        target\n      );\n    };\n\n    var hasProxy =\n      typeof Proxy !== 'undefined' && isNative(Proxy);\n\n    if (hasProxy) {\n      var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');\n      config.keyCodes = new Proxy(config.keyCodes, {\n        set: function set (target, key, value) {\n          if (isBuiltInModifier(key)) {\n            warn((\"Avoid overwriting built-in modifier in config.keyCodes: .\" + key));\n            return false\n          } else {\n            target[key] = value;\n            return true\n          }\n        }\n      });\n    }\n\n    var hasHandler = {\n      has: function has (target, key) {\n        var has = key in target;\n        var isAllowed = allowedGlobals(key) ||\n          (typeof key === 'string' && key.charAt(0) === '_' && !(key in target.$data));\n        if (!has && !isAllowed) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return has || !isAllowed\n      }\n    };\n\n    var getHandler = {\n      get: function get (target, key) {\n        if (typeof key === 'string' && !(key in target)) {\n          if (key in target.$data) { warnReservedPrefix(target, key); }\n          else { warnNonPresent(target, key); }\n        }\n        return target[key]\n      }\n    };\n\n    initProxy = function initProxy (vm) {\n      if (hasProxy) {\n        // determine which proxy handler to use\n        var options = vm.$options;\n        var handlers = options.render && options.render._withStripped\n          ? getHandler\n          : hasHandler;\n        vm._renderProxy = new Proxy(vm, handlers);\n      } else {\n        vm._renderProxy = vm;\n      }\n    };\n  }\n\n  /*  */\n\n  var seenObjects = new _Set();\n\n  /**\n   * Recursively traverse an object to evoke all converted\n   * getters, so that every nested property inside the object\n   * is collected as a \"deep\" dependency.\n   */\n  function traverse (val) {\n    _traverse(val, seenObjects);\n    seenObjects.clear();\n  }\n\n  function _traverse (val, seen) {\n    var i, keys;\n    var isA = Array.isArray(val);\n    if ((!isA && !isObject(val)) || Object.isFrozen(val) || val instanceof VNode) {\n      return\n    }\n    if (val.__ob__) {\n      var depId = val.__ob__.dep.id;\n      if (seen.has(depId)) {\n        return\n      }\n      seen.add(depId);\n    }\n    if (isA) {\n      i = val.length;\n      while (i--) { _traverse(val[i], seen); }\n    } else {\n      keys = Object.keys(val);\n      i = keys.length;\n      while (i--) { _traverse(val[keys[i]], seen); }\n    }\n  }\n\n  /*  */\n\n  var normalizeEvent = cached(function (name) {\n    var passive = name.charAt(0) === '&';\n    name = passive ? name.slice(1) : name;\n    var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first\n    name = once$$1 ? name.slice(1) : name;\n    var capture = name.charAt(0) === '!';\n    name = capture ? name.slice(1) : name;\n    return {\n      name: name,\n      once: once$$1,\n      capture: capture,\n      passive: passive\n    }\n  });\n\n  function createFnInvoker (fns, vm) {\n    function invoker () {\n      var arguments$1 = arguments;\n\n      var fns = invoker.fns;\n      if (Array.isArray(fns)) {\n        var cloned = fns.slice();\n        for (var i = 0; i < cloned.length; i++) {\n          invokeWithErrorHandling(cloned[i], null, arguments$1, vm, \"v-on handler\");\n        }\n      } else {\n        // return handler return value for single handlers\n        return invokeWithErrorHandling(fns, null, arguments, vm, \"v-on handler\")\n      }\n    }\n    invoker.fns = fns;\n    return invoker\n  }\n\n  function updateListeners (\n    on,\n    oldOn,\n    add,\n    remove$$1,\n    createOnceHandler,\n    vm\n  ) {\n    var name, def$$1, cur, old, event;\n    for (name in on) {\n      def$$1 = cur = on[name];\n      old = oldOn[name];\n      event = normalizeEvent(name);\n      if (isUndef(cur)) {\n        warn(\n          \"Invalid handler for event \\\"\" + (event.name) + \"\\\": got \" + String(cur),\n          vm\n        );\n      } else if (isUndef(old)) {\n        if (isUndef(cur.fns)) {\n          cur = on[name] = createFnInvoker(cur, vm);\n        }\n        if (isTrue(event.once)) {\n          cur = on[name] = createOnceHandler(event.name, cur, event.capture);\n        }\n        add(event.name, cur, event.capture, event.passive, event.params);\n      } else if (cur !== old) {\n        old.fns = cur;\n        on[name] = old;\n      }\n    }\n    for (name in oldOn) {\n      if (isUndef(on[name])) {\n        event = normalizeEvent(name);\n        remove$$1(event.name, oldOn[name], event.capture);\n      }\n    }\n  }\n\n  /*  */\n\n  function mergeVNodeHook (def, hookKey, hook) {\n    if (def instanceof VNode) {\n      def = def.data.hook || (def.data.hook = {});\n    }\n    var invoker;\n    var oldHook = def[hookKey];\n\n    function wrappedHook () {\n      hook.apply(this, arguments);\n      // important: remove merged hook to ensure it's called only once\n      // and prevent memory leak\n      remove(invoker.fns, wrappedHook);\n    }\n\n    if (isUndef(oldHook)) {\n      // no existing hook\n      invoker = createFnInvoker([wrappedHook]);\n    } else {\n      /* istanbul ignore if */\n      if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {\n        // already a merged invoker\n        invoker = oldHook;\n        invoker.fns.push(wrappedHook);\n      } else {\n        // existing plain hook\n        invoker = createFnInvoker([oldHook, wrappedHook]);\n      }\n    }\n\n    invoker.merged = true;\n    def[hookKey] = invoker;\n  }\n\n  /*  */\n\n  function extractPropsFromVNodeData (\n    data,\n    Ctor,\n    tag\n  ) {\n    // we are only extracting raw values here.\n    // validation and default values are handled in the child\n    // component itself.\n    var propOptions = Ctor.options.props;\n    if (isUndef(propOptions)) {\n      return\n    }\n    var res = {};\n    var attrs = data.attrs;\n    var props = data.props;\n    if (isDef(attrs) || isDef(props)) {\n      for (var key in propOptions) {\n        var altKey = hyphenate(key);\n        {\n          var keyInLowerCase = key.toLowerCase();\n          if (\n            key !== keyInLowerCase &&\n            attrs && hasOwn(attrs, keyInLowerCase)\n          ) {\n            tip(\n              \"Prop \\\"\" + keyInLowerCase + \"\\\" is passed to component \" +\n              (formatComponentName(tag || Ctor)) + \", but the declared prop name is\" +\n              \" \\\"\" + key + \"\\\". \" +\n              \"Note that HTML attributes are case-insensitive and camelCased \" +\n              \"props need to use their kebab-case equivalents when using in-DOM \" +\n              \"templates. You should probably use \\\"\" + altKey + \"\\\" instead of \\\"\" + key + \"\\\".\"\n            );\n          }\n        }\n        checkProp(res, props, key, altKey, true) ||\n        checkProp(res, attrs, key, altKey, false);\n      }\n    }\n    return res\n  }\n\n  function checkProp (\n    res,\n    hash,\n    key,\n    altKey,\n    preserve\n  ) {\n    if (isDef(hash)) {\n      if (hasOwn(hash, key)) {\n        res[key] = hash[key];\n        if (!preserve) {\n          delete hash[key];\n        }\n        return true\n      } else if (hasOwn(hash, altKey)) {\n        res[key] = hash[altKey];\n        if (!preserve) {\n          delete hash[altKey];\n        }\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  // The template compiler attempts to minimize the need for normalization by\n  // statically analyzing the template at compile time.\n  //\n  // For plain HTML markup, normalization can be completely skipped because the\n  // generated render function is guaranteed to return Array<VNode>. There are\n  // two cases where extra normalization is needed:\n\n  // 1. When the children contains components - because a functional component\n  // may return an Array instead of a single root. In this case, just a simple\n  // normalization is needed - if any child is an Array, we flatten the whole\n  // thing with Array.prototype.concat. It is guaranteed to be only 1-level deep\n  // because functional components already normalize their own children.\n  function simpleNormalizeChildren (children) {\n    for (var i = 0; i < children.length; i++) {\n      if (Array.isArray(children[i])) {\n        return Array.prototype.concat.apply([], children)\n      }\n    }\n    return children\n  }\n\n  // 2. When the children contains constructs that always generated nested Arrays,\n  // e.g. <template>, <slot>, v-for, or when the children is provided by user\n  // with hand-written render functions / JSX. In such cases a full normalization\n  // is needed to cater to all possible types of children values.\n  function normalizeChildren (children) {\n    return isPrimitive(children)\n      ? [createTextVNode(children)]\n      : Array.isArray(children)\n        ? normalizeArrayChildren(children)\n        : undefined\n  }\n\n  function isTextNode (node) {\n    return isDef(node) && isDef(node.text) && isFalse(node.isComment)\n  }\n\n  function normalizeArrayChildren (children, nestedIndex) {\n    var res = [];\n    var i, c, lastIndex, last;\n    for (i = 0; i < children.length; i++) {\n      c = children[i];\n      if (isUndef(c) || typeof c === 'boolean') { continue }\n      lastIndex = res.length - 1;\n      last = res[lastIndex];\n      //  nested\n      if (Array.isArray(c)) {\n        if (c.length > 0) {\n          c = normalizeArrayChildren(c, ((nestedIndex || '') + \"_\" + i));\n          // merge adjacent text nodes\n          if (isTextNode(c[0]) && isTextNode(last)) {\n            res[lastIndex] = createTextVNode(last.text + (c[0]).text);\n            c.shift();\n          }\n          res.push.apply(res, c);\n        }\n      } else if (isPrimitive(c)) {\n        if (isTextNode(last)) {\n          // merge adjacent text nodes\n          // this is necessary for SSR hydration because text nodes are\n          // essentially merged when rendered to HTML strings\n          res[lastIndex] = createTextVNode(last.text + c);\n        } else if (c !== '') {\n          // convert primitive to vnode\n          res.push(createTextVNode(c));\n        }\n      } else {\n        if (isTextNode(c) && isTextNode(last)) {\n          // merge adjacent text nodes\n          res[lastIndex] = createTextVNode(last.text + c.text);\n        } else {\n          // default key for nested array children (likely generated by v-for)\n          if (isTrue(children._isVList) &&\n            isDef(c.tag) &&\n            isUndef(c.key) &&\n            isDef(nestedIndex)) {\n            c.key = \"__vlist\" + nestedIndex + \"_\" + i + \"__\";\n          }\n          res.push(c);\n        }\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  function initProvide (vm) {\n    var provide = vm.$options.provide;\n    if (provide) {\n      vm._provided = typeof provide === 'function'\n        ? provide.call(vm)\n        : provide;\n    }\n  }\n\n  function initInjections (vm) {\n    var result = resolveInject(vm.$options.inject, vm);\n    if (result) {\n      toggleObserving(false);\n      Object.keys(result).forEach(function (key) {\n        /* istanbul ignore else */\n        {\n          defineReactive$$1(vm, key, result[key], function () {\n            warn(\n              \"Avoid mutating an injected value directly since the changes will be \" +\n              \"overwritten whenever the provided component re-renders. \" +\n              \"injection being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          });\n        }\n      });\n      toggleObserving(true);\n    }\n  }\n\n  function resolveInject (inject, vm) {\n    if (inject) {\n      // inject is :any because flow is not smart enough to figure out cached\n      var result = Object.create(null);\n      var keys = hasSymbol\n        ? Reflect.ownKeys(inject)\n        : Object.keys(inject);\n\n      for (var i = 0; i < keys.length; i++) {\n        var key = keys[i];\n        // #6574 in case the inject object is observed...\n        if (key === '__ob__') { continue }\n        var provideKey = inject[key].from;\n        var source = vm;\n        while (source) {\n          if (source._provided && hasOwn(source._provided, provideKey)) {\n            result[key] = source._provided[provideKey];\n            break\n          }\n          source = source.$parent;\n        }\n        if (!source) {\n          if ('default' in inject[key]) {\n            var provideDefault = inject[key].default;\n            result[key] = typeof provideDefault === 'function'\n              ? provideDefault.call(vm)\n              : provideDefault;\n          } else {\n            warn((\"Injection \\\"\" + key + \"\\\" not found\"), vm);\n          }\n        }\n      }\n      return result\n    }\n  }\n\n  /*  */\n\n\n\n  /**\n   * Runtime helper for resolving raw children VNodes into a slot object.\n   */\n  function resolveSlots (\n    children,\n    context\n  ) {\n    if (!children || !children.length) {\n      return {}\n    }\n    var slots = {};\n    for (var i = 0, l = children.length; i < l; i++) {\n      var child = children[i];\n      var data = child.data;\n      // remove slot attribute if the node is resolved as a Vue slot node\n      if (data && data.attrs && data.attrs.slot) {\n        delete data.attrs.slot;\n      }\n      // named slots should only be respected if the vnode was rendered in the\n      // same context.\n      if ((child.context === context || child.fnContext === context) &&\n        data && data.slot != null\n      ) {\n        var name = data.slot;\n        var slot = (slots[name] || (slots[name] = []));\n        if (child.tag === 'template') {\n          slot.push.apply(slot, child.children || []);\n        } else {\n          slot.push(child);\n        }\n      } else {\n        (slots.default || (slots.default = [])).push(child);\n      }\n    }\n    // ignore slots that contains only whitespace\n    for (var name$1 in slots) {\n      if (slots[name$1].every(isWhitespace)) {\n        delete slots[name$1];\n      }\n    }\n    return slots\n  }\n\n  function isWhitespace (node) {\n    return (node.isComment && !node.asyncFactory) || node.text === ' '\n  }\n\n  /*  */\n\n  function normalizeScopedSlots (\n    slots,\n    normalSlots,\n    prevSlots\n  ) {\n    var res;\n    var hasNormalSlots = Object.keys(normalSlots).length > 0;\n    var isStable = slots ? !!slots.$stable : !hasNormalSlots;\n    var key = slots && slots.$key;\n    if (!slots) {\n      res = {};\n    } else if (slots._normalized) {\n      // fast path 1: child component re-render only, parent did not change\n      return slots._normalized\n    } else if (\n      isStable &&\n      prevSlots &&\n      prevSlots !== emptyObject &&\n      key === prevSlots.$key &&\n      !hasNormalSlots &&\n      !prevSlots.$hasNormal\n    ) {\n      // fast path 2: stable scoped slots w/ no normal slots to proxy,\n      // only need to normalize once\n      return prevSlots\n    } else {\n      res = {};\n      for (var key$1 in slots) {\n        if (slots[key$1] && key$1[0] !== '$') {\n          res[key$1] = normalizeScopedSlot(normalSlots, key$1, slots[key$1]);\n        }\n      }\n    }\n    // expose normal slots on scopedSlots\n    for (var key$2 in normalSlots) {\n      if (!(key$2 in res)) {\n        res[key$2] = proxyNormalSlot(normalSlots, key$2);\n      }\n    }\n    // avoriaz seems to mock a non-extensible $scopedSlots object\n    // and when that is passed down this would cause an error\n    if (slots && Object.isExtensible(slots)) {\n      (slots)._normalized = res;\n    }\n    def(res, '$stable', isStable);\n    def(res, '$key', key);\n    def(res, '$hasNormal', hasNormalSlots);\n    return res\n  }\n\n  function normalizeScopedSlot(normalSlots, key, fn) {\n    var normalized = function () {\n      var res = arguments.length ? fn.apply(null, arguments) : fn({});\n      res = res && typeof res === 'object' && !Array.isArray(res)\n        ? [res] // single vnode\n        : normalizeChildren(res);\n      return res && (\n        res.length === 0 ||\n        (res.length === 1 && res[0].isComment) // #9658\n      ) ? undefined\n        : res\n    };\n    // this is a slot using the new v-slot syntax without scope. although it is\n    // compiled as a scoped slot, render fn users would expect it to be present\n    // on this.$slots because the usage is semantically a normal slot.\n    if (fn.proxy) {\n      Object.defineProperty(normalSlots, key, {\n        get: normalized,\n        enumerable: true,\n        configurable: true\n      });\n    }\n    return normalized\n  }\n\n  function proxyNormalSlot(slots, key) {\n    return function () { return slots[key]; }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering v-for lists.\n   */\n  function renderList (\n    val,\n    render\n  ) {\n    var ret, i, l, keys, key;\n    if (Array.isArray(val) || typeof val === 'string') {\n      ret = new Array(val.length);\n      for (i = 0, l = val.length; i < l; i++) {\n        ret[i] = render(val[i], i);\n      }\n    } else if (typeof val === 'number') {\n      ret = new Array(val);\n      for (i = 0; i < val; i++) {\n        ret[i] = render(i + 1, i);\n      }\n    } else if (isObject(val)) {\n      if (hasSymbol && val[Symbol.iterator]) {\n        ret = [];\n        var iterator = val[Symbol.iterator]();\n        var result = iterator.next();\n        while (!result.done) {\n          ret.push(render(result.value, ret.length));\n          result = iterator.next();\n        }\n      } else {\n        keys = Object.keys(val);\n        ret = new Array(keys.length);\n        for (i = 0, l = keys.length; i < l; i++) {\n          key = keys[i];\n          ret[i] = render(val[key], key, i);\n        }\n      }\n    }\n    if (!isDef(ret)) {\n      ret = [];\n    }\n    (ret)._isVList = true;\n    return ret\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering <slot>\n   */\n  function renderSlot (\n    name,\n    fallback,\n    props,\n    bindObject\n  ) {\n    var scopedSlotFn = this.$scopedSlots[name];\n    var nodes;\n    if (scopedSlotFn) { // scoped slot\n      props = props || {};\n      if (bindObject) {\n        if (!isObject(bindObject)) {\n          warn(\n            'slot v-bind without argument expects an Object',\n            this\n          );\n        }\n        props = extend(extend({}, bindObject), props);\n      }\n      nodes = scopedSlotFn(props) || fallback;\n    } else {\n      nodes = this.$slots[name] || fallback;\n    }\n\n    var target = props && props.slot;\n    if (target) {\n      return this.$createElement('template', { slot: target }, nodes)\n    } else {\n      return nodes\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for resolving filters\n   */\n  function resolveFilter (id) {\n    return resolveAsset(this.$options, 'filters', id, true) || identity\n  }\n\n  /*  */\n\n  function isKeyNotMatch (expect, actual) {\n    if (Array.isArray(expect)) {\n      return expect.indexOf(actual) === -1\n    } else {\n      return expect !== actual\n    }\n  }\n\n  /**\n   * Runtime helper for checking keyCodes from config.\n   * exposed as Vue.prototype._k\n   * passing in eventKeyName as last argument separately for backwards compat\n   */\n  function checkKeyCodes (\n    eventKeyCode,\n    key,\n    builtInKeyCode,\n    eventKeyName,\n    builtInKeyName\n  ) {\n    var mappedKeyCode = config.keyCodes[key] || builtInKeyCode;\n    if (builtInKeyName && eventKeyName && !config.keyCodes[key]) {\n      return isKeyNotMatch(builtInKeyName, eventKeyName)\n    } else if (mappedKeyCode) {\n      return isKeyNotMatch(mappedKeyCode, eventKeyCode)\n    } else if (eventKeyName) {\n      return hyphenate(eventKeyName) !== key\n    }\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for merging v-bind=\"object\" into a VNode's data.\n   */\n  function bindObjectProps (\n    data,\n    tag,\n    value,\n    asProp,\n    isSync\n  ) {\n    if (value) {\n      if (!isObject(value)) {\n        warn(\n          'v-bind without argument expects an Object or Array value',\n          this\n        );\n      } else {\n        if (Array.isArray(value)) {\n          value = toObject(value);\n        }\n        var hash;\n        var loop = function ( key ) {\n          if (\n            key === 'class' ||\n            key === 'style' ||\n            isReservedAttribute(key)\n          ) {\n            hash = data;\n          } else {\n            var type = data.attrs && data.attrs.type;\n            hash = asProp || config.mustUseProp(tag, type, key)\n              ? data.domProps || (data.domProps = {})\n              : data.attrs || (data.attrs = {});\n          }\n          var camelizedKey = camelize(key);\n          var hyphenatedKey = hyphenate(key);\n          if (!(camelizedKey in hash) && !(hyphenatedKey in hash)) {\n            hash[key] = value[key];\n\n            if (isSync) {\n              var on = data.on || (data.on = {});\n              on[(\"update:\" + key)] = function ($event) {\n                value[key] = $event;\n              };\n            }\n          }\n        };\n\n        for (var key in value) loop( key );\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  /**\n   * Runtime helper for rendering static trees.\n   */\n  function renderStatic (\n    index,\n    isInFor\n  ) {\n    var cached = this._staticTrees || (this._staticTrees = []);\n    var tree = cached[index];\n    // if has already-rendered static tree and not inside v-for,\n    // we can reuse the same tree.\n    if (tree && !isInFor) {\n      return tree\n    }\n    // otherwise, render a fresh tree.\n    tree = cached[index] = this.$options.staticRenderFns[index].call(\n      this._renderProxy,\n      null,\n      this // for render fns generated for functional component templates\n    );\n    markStatic(tree, (\"__static__\" + index), false);\n    return tree\n  }\n\n  /**\n   * Runtime helper for v-once.\n   * Effectively it means marking the node as static with a unique key.\n   */\n  function markOnce (\n    tree,\n    index,\n    key\n  ) {\n    markStatic(tree, (\"__once__\" + index + (key ? (\"_\" + key) : \"\")), true);\n    return tree\n  }\n\n  function markStatic (\n    tree,\n    key,\n    isOnce\n  ) {\n    if (Array.isArray(tree)) {\n      for (var i = 0; i < tree.length; i++) {\n        if (tree[i] && typeof tree[i] !== 'string') {\n          markStaticNode(tree[i], (key + \"_\" + i), isOnce);\n        }\n      }\n    } else {\n      markStaticNode(tree, key, isOnce);\n    }\n  }\n\n  function markStaticNode (node, key, isOnce) {\n    node.isStatic = true;\n    node.key = key;\n    node.isOnce = isOnce;\n  }\n\n  /*  */\n\n  function bindObjectListeners (data, value) {\n    if (value) {\n      if (!isPlainObject(value)) {\n        warn(\n          'v-on without argument expects an Object value',\n          this\n        );\n      } else {\n        var on = data.on = data.on ? extend({}, data.on) : {};\n        for (var key in value) {\n          var existing = on[key];\n          var ours = value[key];\n          on[key] = existing ? [].concat(existing, ours) : ours;\n        }\n      }\n    }\n    return data\n  }\n\n  /*  */\n\n  function resolveScopedSlots (\n    fns, // see flow/vnode\n    res,\n    // the following are added in 2.6\n    hasDynamicKeys,\n    contentHashKey\n  ) {\n    res = res || { $stable: !hasDynamicKeys };\n    for (var i = 0; i < fns.length; i++) {\n      var slot = fns[i];\n      if (Array.isArray(slot)) {\n        resolveScopedSlots(slot, res, hasDynamicKeys);\n      } else if (slot) {\n        // marker for reverse proxying v-slot without scope on this.$slots\n        if (slot.proxy) {\n          slot.fn.proxy = true;\n        }\n        res[slot.key] = slot.fn;\n      }\n    }\n    if (contentHashKey) {\n      (res).$key = contentHashKey;\n    }\n    return res\n  }\n\n  /*  */\n\n  function bindDynamicKeys (baseObj, values) {\n    for (var i = 0; i < values.length; i += 2) {\n      var key = values[i];\n      if (typeof key === 'string' && key) {\n        baseObj[values[i]] = values[i + 1];\n      } else if (key !== '' && key !== null) {\n        // null is a speical value for explicitly removing a binding\n        warn(\n          (\"Invalid value for dynamic directive argument (expected string or null): \" + key),\n          this\n        );\n      }\n    }\n    return baseObj\n  }\n\n  // helper to dynamically append modifier runtime markers to event names.\n  // ensure only append when value is already string, otherwise it will be cast\n  // to string and cause the type check to miss.\n  function prependModifier (value, symbol) {\n    return typeof value === 'string' ? symbol + value : value\n  }\n\n  /*  */\n\n  function installRenderHelpers (target) {\n    target._o = markOnce;\n    target._n = toNumber;\n    target._s = toString;\n    target._l = renderList;\n    target._t = renderSlot;\n    target._q = looseEqual;\n    target._i = looseIndexOf;\n    target._m = renderStatic;\n    target._f = resolveFilter;\n    target._k = checkKeyCodes;\n    target._b = bindObjectProps;\n    target._v = createTextVNode;\n    target._e = createEmptyVNode;\n    target._u = resolveScopedSlots;\n    target._g = bindObjectListeners;\n    target._d = bindDynamicKeys;\n    target._p = prependModifier;\n  }\n\n  /*  */\n\n  function FunctionalRenderContext (\n    data,\n    props,\n    children,\n    parent,\n    Ctor\n  ) {\n    var this$1 = this;\n\n    var options = Ctor.options;\n    // ensure the createElement function in functional components\n    // gets a unique context - this is necessary for correct named slot check\n    var contextVm;\n    if (hasOwn(parent, '_uid')) {\n      contextVm = Object.create(parent);\n      // $flow-disable-line\n      contextVm._original = parent;\n    } else {\n      // the context vm passed in is a functional context as well.\n      // in this case we want to make sure we are able to get a hold to the\n      // real context instance.\n      contextVm = parent;\n      // $flow-disable-line\n      parent = parent._original;\n    }\n    var isCompiled = isTrue(options._compiled);\n    var needNormalization = !isCompiled;\n\n    this.data = data;\n    this.props = props;\n    this.children = children;\n    this.parent = parent;\n    this.listeners = data.on || emptyObject;\n    this.injections = resolveInject(options.inject, parent);\n    this.slots = function () {\n      if (!this$1.$slots) {\n        normalizeScopedSlots(\n          data.scopedSlots,\n          this$1.$slots = resolveSlots(children, parent)\n        );\n      }\n      return this$1.$slots\n    };\n\n    Object.defineProperty(this, 'scopedSlots', ({\n      enumerable: true,\n      get: function get () {\n        return normalizeScopedSlots(data.scopedSlots, this.slots())\n      }\n    }));\n\n    // support for compiled functional template\n    if (isCompiled) {\n      // exposing $options for renderStatic()\n      this.$options = options;\n      // pre-resolve slots for renderSlot()\n      this.$slots = this.slots();\n      this.$scopedSlots = normalizeScopedSlots(data.scopedSlots, this.$slots);\n    }\n\n    if (options._scopeId) {\n      this._c = function (a, b, c, d) {\n        var vnode = createElement(contextVm, a, b, c, d, needNormalization);\n        if (vnode && !Array.isArray(vnode)) {\n          vnode.fnScopeId = options._scopeId;\n          vnode.fnContext = parent;\n        }\n        return vnode\n      };\n    } else {\n      this._c = function (a, b, c, d) { return createElement(contextVm, a, b, c, d, needNormalization); };\n    }\n  }\n\n  installRenderHelpers(FunctionalRenderContext.prototype);\n\n  function createFunctionalComponent (\n    Ctor,\n    propsData,\n    data,\n    contextVm,\n    children\n  ) {\n    var options = Ctor.options;\n    var props = {};\n    var propOptions = options.props;\n    if (isDef(propOptions)) {\n      for (var key in propOptions) {\n        props[key] = validateProp(key, propOptions, propsData || emptyObject);\n      }\n    } else {\n      if (isDef(data.attrs)) { mergeProps(props, data.attrs); }\n      if (isDef(data.props)) { mergeProps(props, data.props); }\n    }\n\n    var renderContext = new FunctionalRenderContext(\n      data,\n      props,\n      children,\n      contextVm,\n      Ctor\n    );\n\n    var vnode = options.render.call(null, renderContext._c, renderContext);\n\n    if (vnode instanceof VNode) {\n      return cloneAndMarkFunctionalResult(vnode, data, renderContext.parent, options, renderContext)\n    } else if (Array.isArray(vnode)) {\n      var vnodes = normalizeChildren(vnode) || [];\n      var res = new Array(vnodes.length);\n      for (var i = 0; i < vnodes.length; i++) {\n        res[i] = cloneAndMarkFunctionalResult(vnodes[i], data, renderContext.parent, options, renderContext);\n      }\n      return res\n    }\n  }\n\n  function cloneAndMarkFunctionalResult (vnode, data, contextVm, options, renderContext) {\n    // #7817 clone node before setting fnContext, otherwise if the node is reused\n    // (e.g. it was from a cached normal slot) the fnContext causes named slots\n    // that should not be matched to match.\n    var clone = cloneVNode(vnode);\n    clone.fnContext = contextVm;\n    clone.fnOptions = options;\n    {\n      (clone.devtoolsMeta = clone.devtoolsMeta || {}).renderContext = renderContext;\n    }\n    if (data.slot) {\n      (clone.data || (clone.data = {})).slot = data.slot;\n    }\n    return clone\n  }\n\n  function mergeProps (to, from) {\n    for (var key in from) {\n      to[camelize(key)] = from[key];\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  /*  */\n\n  // inline hooks to be invoked on component VNodes during patch\n  var componentVNodeHooks = {\n    init: function init (vnode, hydrating) {\n      if (\n        vnode.componentInstance &&\n        !vnode.componentInstance._isDestroyed &&\n        vnode.data.keepAlive\n      ) {\n        // kept-alive components, treat as a patch\n        var mountedNode = vnode; // work around flow\n        componentVNodeHooks.prepatch(mountedNode, mountedNode);\n      } else {\n        var child = vnode.componentInstance = createComponentInstanceForVnode(\n          vnode,\n          activeInstance\n        );\n        child.$mount(hydrating ? vnode.elm : undefined, hydrating);\n      }\n    },\n\n    prepatch: function prepatch (oldVnode, vnode) {\n      var options = vnode.componentOptions;\n      var child = vnode.componentInstance = oldVnode.componentInstance;\n      updateChildComponent(\n        child,\n        options.propsData, // updated props\n        options.listeners, // updated listeners\n        vnode, // new parent vnode\n        options.children // new children\n      );\n    },\n\n    insert: function insert (vnode) {\n      var context = vnode.context;\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isMounted) {\n        componentInstance._isMounted = true;\n        callHook(componentInstance, 'mounted');\n      }\n      if (vnode.data.keepAlive) {\n        if (context._isMounted) {\n          // vue-router#1212\n          // During updates, a kept-alive component's child components may\n          // change, so directly walking the tree here may call activated hooks\n          // on incorrect children. Instead we push them into a queue which will\n          // be processed after the whole patch process ended.\n          queueActivatedComponent(componentInstance);\n        } else {\n          activateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    },\n\n    destroy: function destroy (vnode) {\n      var componentInstance = vnode.componentInstance;\n      if (!componentInstance._isDestroyed) {\n        if (!vnode.data.keepAlive) {\n          componentInstance.$destroy();\n        } else {\n          deactivateChildComponent(componentInstance, true /* direct */);\n        }\n      }\n    }\n  };\n\n  var hooksToMerge = Object.keys(componentVNodeHooks);\n\n  function createComponent (\n    Ctor,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    if (isUndef(Ctor)) {\n      return\n    }\n\n    var baseCtor = context.$options._base;\n\n    // plain options object: turn it into a constructor\n    if (isObject(Ctor)) {\n      Ctor = baseCtor.extend(Ctor);\n    }\n\n    // if at this stage it's not a constructor or an async component factory,\n    // reject.\n    if (typeof Ctor !== 'function') {\n      {\n        warn((\"Invalid Component definition: \" + (String(Ctor))), context);\n      }\n      return\n    }\n\n    // async component\n    var asyncFactory;\n    if (isUndef(Ctor.cid)) {\n      asyncFactory = Ctor;\n      Ctor = resolveAsyncComponent(asyncFactory, baseCtor);\n      if (Ctor === undefined) {\n        // return a placeholder node for async component, which is rendered\n        // as a comment node but preserves all the raw information for the node.\n        // the information will be used for async server-rendering and hydration.\n        return createAsyncPlaceholder(\n          asyncFactory,\n          data,\n          context,\n          children,\n          tag\n        )\n      }\n    }\n\n    data = data || {};\n\n    // resolve constructor options in case global mixins are applied after\n    // component constructor creation\n    resolveConstructorOptions(Ctor);\n\n    // transform component v-model data into props & events\n    if (isDef(data.model)) {\n      transformModel(Ctor.options, data);\n    }\n\n    // extract props\n    var propsData = extractPropsFromVNodeData(data, Ctor, tag);\n\n    // functional component\n    if (isTrue(Ctor.options.functional)) {\n      return createFunctionalComponent(Ctor, propsData, data, context, children)\n    }\n\n    // extract listeners, since these needs to be treated as\n    // child component listeners instead of DOM listeners\n    var listeners = data.on;\n    // replace with listeners with .native modifier\n    // so it gets processed during parent component patch.\n    data.on = data.nativeOn;\n\n    if (isTrue(Ctor.options.abstract)) {\n      // abstract components do not keep anything\n      // other than props & listeners & slot\n\n      // work around flow\n      var slot = data.slot;\n      data = {};\n      if (slot) {\n        data.slot = slot;\n      }\n    }\n\n    // install component management hooks onto the placeholder node\n    installComponentHooks(data);\n\n    // return a placeholder vnode\n    var name = Ctor.options.name || tag;\n    var vnode = new VNode(\n      (\"vue-component-\" + (Ctor.cid) + (name ? (\"-\" + name) : '')),\n      data, undefined, undefined, undefined, context,\n      { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children },\n      asyncFactory\n    );\n\n    return vnode\n  }\n\n  function createComponentInstanceForVnode (\n    vnode, // we know it's MountedComponentVNode but flow doesn't\n    parent // activeInstance in lifecycle state\n  ) {\n    var options = {\n      _isComponent: true,\n      _parentVnode: vnode,\n      parent: parent\n    };\n    // check inline-template render functions\n    var inlineTemplate = vnode.data.inlineTemplate;\n    if (isDef(inlineTemplate)) {\n      options.render = inlineTemplate.render;\n      options.staticRenderFns = inlineTemplate.staticRenderFns;\n    }\n    return new vnode.componentOptions.Ctor(options)\n  }\n\n  function installComponentHooks (data) {\n    var hooks = data.hook || (data.hook = {});\n    for (var i = 0; i < hooksToMerge.length; i++) {\n      var key = hooksToMerge[i];\n      var existing = hooks[key];\n      var toMerge = componentVNodeHooks[key];\n      if (existing !== toMerge && !(existing && existing._merged)) {\n        hooks[key] = existing ? mergeHook$1(toMerge, existing) : toMerge;\n      }\n    }\n  }\n\n  function mergeHook$1 (f1, f2) {\n    var merged = function (a, b) {\n      // flow complains about extra args which is why we use any\n      f1(a, b);\n      f2(a, b);\n    };\n    merged._merged = true;\n    return merged\n  }\n\n  // transform component v-model info (value and callback) into\n  // prop and event handler respectively.\n  function transformModel (options, data) {\n    var prop = (options.model && options.model.prop) || 'value';\n    var event = (options.model && options.model.event) || 'input'\n    ;(data.attrs || (data.attrs = {}))[prop] = data.model.value;\n    var on = data.on || (data.on = {});\n    var existing = on[event];\n    var callback = data.model.callback;\n    if (isDef(existing)) {\n      if (\n        Array.isArray(existing)\n          ? existing.indexOf(callback) === -1\n          : existing !== callback\n      ) {\n        on[event] = [callback].concat(existing);\n      }\n    } else {\n      on[event] = callback;\n    }\n  }\n\n  /*  */\n\n  var SIMPLE_NORMALIZE = 1;\n  var ALWAYS_NORMALIZE = 2;\n\n  // wrapper function for providing a more flexible interface\n  // without getting yelled at by flow\n  function createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType,\n    alwaysNormalize\n  ) {\n    if (Array.isArray(data) || isPrimitive(data)) {\n      normalizationType = children;\n      children = data;\n      data = undefined;\n    }\n    if (isTrue(alwaysNormalize)) {\n      normalizationType = ALWAYS_NORMALIZE;\n    }\n    return _createElement(context, tag, data, children, normalizationType)\n  }\n\n  function _createElement (\n    context,\n    tag,\n    data,\n    children,\n    normalizationType\n  ) {\n    if (isDef(data) && isDef((data).__ob__)) {\n      warn(\n        \"Avoid using observed data object as vnode data: \" + (JSON.stringify(data)) + \"\\n\" +\n        'Always create fresh vnode data objects in each render!',\n        context\n      );\n      return createEmptyVNode()\n    }\n    // object syntax in v-bind\n    if (isDef(data) && isDef(data.is)) {\n      tag = data.is;\n    }\n    if (!tag) {\n      // in case of component :is set to falsy value\n      return createEmptyVNode()\n    }\n    // warn against non-primitive key\n    if (isDef(data) && isDef(data.key) && !isPrimitive(data.key)\n    ) {\n      {\n        warn(\n          'Avoid using non-primitive value as key, ' +\n          'use string/number value instead.',\n          context\n        );\n      }\n    }\n    // support single function children as default scoped slot\n    if (Array.isArray(children) &&\n      typeof children[0] === 'function'\n    ) {\n      data = data || {};\n      data.scopedSlots = { default: children[0] };\n      children.length = 0;\n    }\n    if (normalizationType === ALWAYS_NORMALIZE) {\n      children = normalizeChildren(children);\n    } else if (normalizationType === SIMPLE_NORMALIZE) {\n      children = simpleNormalizeChildren(children);\n    }\n    var vnode, ns;\n    if (typeof tag === 'string') {\n      var Ctor;\n      ns = (context.$vnode && context.$vnode.ns) || config.getTagNamespace(tag);\n      if (config.isReservedTag(tag)) {\n        // platform built-in elements\n        vnode = new VNode(\n          config.parsePlatformTagName(tag), data, children,\n          undefined, undefined, context\n        );\n      } else if ((!data || !data.pre) && isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {\n        // component\n        vnode = createComponent(Ctor, data, context, children, tag);\n      } else {\n        // unknown or unlisted namespaced elements\n        // check at runtime because it may get assigned a namespace when its\n        // parent normalizes children\n        vnode = new VNode(\n          tag, data, children,\n          undefined, undefined, context\n        );\n      }\n    } else {\n      // direct component options / constructor\n      vnode = createComponent(tag, data, context, children);\n    }\n    if (Array.isArray(vnode)) {\n      return vnode\n    } else if (isDef(vnode)) {\n      if (isDef(ns)) { applyNS(vnode, ns); }\n      if (isDef(data)) { registerDeepBindings(data); }\n      return vnode\n    } else {\n      return createEmptyVNode()\n    }\n  }\n\n  function applyNS (vnode, ns, force) {\n    vnode.ns = ns;\n    if (vnode.tag === 'foreignObject') {\n      // use default namespace inside foreignObject\n      ns = undefined;\n      force = true;\n    }\n    if (isDef(vnode.children)) {\n      for (var i = 0, l = vnode.children.length; i < l; i++) {\n        var child = vnode.children[i];\n        if (isDef(child.tag) && (\n          isUndef(child.ns) || (isTrue(force) && child.tag !== 'svg'))) {\n          applyNS(child, ns, force);\n        }\n      }\n    }\n  }\n\n  // ref #5318\n  // necessary to ensure parent re-render when deep bindings like :style and\n  // :class are used on slot nodes\n  function registerDeepBindings (data) {\n    if (isObject(data.style)) {\n      traverse(data.style);\n    }\n    if (isObject(data.class)) {\n      traverse(data.class);\n    }\n  }\n\n  /*  */\n\n  function initRender (vm) {\n    vm._vnode = null; // the root of the child tree\n    vm._staticTrees = null; // v-once cached trees\n    var options = vm.$options;\n    var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree\n    var renderContext = parentVnode && parentVnode.context;\n    vm.$slots = resolveSlots(options._renderChildren, renderContext);\n    vm.$scopedSlots = emptyObject;\n    // bind the createElement fn to this instance\n    // so that we get proper render context inside it.\n    // args order: tag, data, children, normalizationType, alwaysNormalize\n    // internal version is used by render functions compiled from templates\n    vm._c = function (a, b, c, d) { return createElement(vm, a, b, c, d, false); };\n    // normalization is always applied for the public version, used in\n    // user-written render functions.\n    vm.$createElement = function (a, b, c, d) { return createElement(vm, a, b, c, d, true); };\n\n    // $attrs & $listeners are exposed for easier HOC creation.\n    // they need to be reactive so that HOCs using them are always updated\n    var parentData = parentVnode && parentVnode.data;\n\n    /* istanbul ignore else */\n    {\n      defineReactive$$1(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$attrs is readonly.\", vm);\n      }, true);\n      defineReactive$$1(vm, '$listeners', options._parentListeners || emptyObject, function () {\n        !isUpdatingChildComponent && warn(\"$listeners is readonly.\", vm);\n      }, true);\n    }\n  }\n\n  var currentRenderingInstance = null;\n\n  function renderMixin (Vue) {\n    // install runtime convenience helpers\n    installRenderHelpers(Vue.prototype);\n\n    Vue.prototype.$nextTick = function (fn) {\n      return nextTick(fn, this)\n    };\n\n    Vue.prototype._render = function () {\n      var vm = this;\n      var ref = vm.$options;\n      var render = ref.render;\n      var _parentVnode = ref._parentVnode;\n\n      if (_parentVnode) {\n        vm.$scopedSlots = normalizeScopedSlots(\n          _parentVnode.data.scopedSlots,\n          vm.$slots,\n          vm.$scopedSlots\n        );\n      }\n\n      // set parent vnode. this allows render functions to have access\n      // to the data on the placeholder node.\n      vm.$vnode = _parentVnode;\n      // render self\n      var vnode;\n      try {\n        // There's no need to maintain a stack becaues all render fns are called\n        // separately from one another. Nested component's render fns are called\n        // when parent component is patched.\n        currentRenderingInstance = vm;\n        vnode = render.call(vm._renderProxy, vm.$createElement);\n      } catch (e) {\n        handleError(e, vm, \"render\");\n        // return error render result,\n        // or previous vnode to prevent render error causing blank component\n        /* istanbul ignore else */\n        if (vm.$options.renderError) {\n          try {\n            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);\n          } catch (e) {\n            handleError(e, vm, \"renderError\");\n            vnode = vm._vnode;\n          }\n        } else {\n          vnode = vm._vnode;\n        }\n      } finally {\n        currentRenderingInstance = null;\n      }\n      // if the returned array contains only a single node, allow it\n      if (Array.isArray(vnode) && vnode.length === 1) {\n        vnode = vnode[0];\n      }\n      // return empty vnode in case the render function errored out\n      if (!(vnode instanceof VNode)) {\n        if (Array.isArray(vnode)) {\n          warn(\n            'Multiple root nodes returned from render function. Render function ' +\n            'should return a single root node.',\n            vm\n          );\n        }\n        vnode = createEmptyVNode();\n      }\n      // set parent\n      vnode.parent = _parentVnode;\n      return vnode\n    };\n  }\n\n  /*  */\n\n  function ensureCtor (comp, base) {\n    if (\n      comp.__esModule ||\n      (hasSymbol && comp[Symbol.toStringTag] === 'Module')\n    ) {\n      comp = comp.default;\n    }\n    return isObject(comp)\n      ? base.extend(comp)\n      : comp\n  }\n\n  function createAsyncPlaceholder (\n    factory,\n    data,\n    context,\n    children,\n    tag\n  ) {\n    var node = createEmptyVNode();\n    node.asyncFactory = factory;\n    node.asyncMeta = { data: data, context: context, children: children, tag: tag };\n    return node\n  }\n\n  function resolveAsyncComponent (\n    factory,\n    baseCtor\n  ) {\n    if (isTrue(factory.error) && isDef(factory.errorComp)) {\n      return factory.errorComp\n    }\n\n    if (isDef(factory.resolved)) {\n      return factory.resolved\n    }\n\n    var owner = currentRenderingInstance;\n    if (owner && isDef(factory.owners) && factory.owners.indexOf(owner) === -1) {\n      // already pending\n      factory.owners.push(owner);\n    }\n\n    if (isTrue(factory.loading) && isDef(factory.loadingComp)) {\n      return factory.loadingComp\n    }\n\n    if (owner && !isDef(factory.owners)) {\n      var owners = factory.owners = [owner];\n      var sync = true;\n      var timerLoading = null;\n      var timerTimeout = null\n\n      ;(owner).$on('hook:destroyed', function () { return remove(owners, owner); });\n\n      var forceRender = function (renderCompleted) {\n        for (var i = 0, l = owners.length; i < l; i++) {\n          (owners[i]).$forceUpdate();\n        }\n\n        if (renderCompleted) {\n          owners.length = 0;\n          if (timerLoading !== null) {\n            clearTimeout(timerLoading);\n            timerLoading = null;\n          }\n          if (timerTimeout !== null) {\n            clearTimeout(timerTimeout);\n            timerTimeout = null;\n          }\n        }\n      };\n\n      var resolve = once(function (res) {\n        // cache resolved\n        factory.resolved = ensureCtor(res, baseCtor);\n        // invoke callbacks only if this is not a synchronous resolve\n        // (async resolves are shimmed as synchronous during SSR)\n        if (!sync) {\n          forceRender(true);\n        } else {\n          owners.length = 0;\n        }\n      });\n\n      var reject = once(function (reason) {\n        warn(\n          \"Failed to resolve async component: \" + (String(factory)) +\n          (reason ? (\"\\nReason: \" + reason) : '')\n        );\n        if (isDef(factory.errorComp)) {\n          factory.error = true;\n          forceRender(true);\n        }\n      });\n\n      var res = factory(resolve, reject);\n\n      if (isObject(res)) {\n        if (isPromise(res)) {\n          // () => Promise\n          if (isUndef(factory.resolved)) {\n            res.then(resolve, reject);\n          }\n        } else if (isPromise(res.component)) {\n          res.component.then(resolve, reject);\n\n          if (isDef(res.error)) {\n            factory.errorComp = ensureCtor(res.error, baseCtor);\n          }\n\n          if (isDef(res.loading)) {\n            factory.loadingComp = ensureCtor(res.loading, baseCtor);\n            if (res.delay === 0) {\n              factory.loading = true;\n            } else {\n              timerLoading = setTimeout(function () {\n                timerLoading = null;\n                if (isUndef(factory.resolved) && isUndef(factory.error)) {\n                  factory.loading = true;\n                  forceRender(false);\n                }\n              }, res.delay || 200);\n            }\n          }\n\n          if (isDef(res.timeout)) {\n            timerTimeout = setTimeout(function () {\n              timerTimeout = null;\n              if (isUndef(factory.resolved)) {\n                reject(\n                  \"timeout (\" + (res.timeout) + \"ms)\"\n                );\n              }\n            }, res.timeout);\n          }\n        }\n      }\n\n      sync = false;\n      // return in case resolved synchronously\n      return factory.loading\n        ? factory.loadingComp\n        : factory.resolved\n    }\n  }\n\n  /*  */\n\n  function isAsyncPlaceholder (node) {\n    return node.isComment && node.asyncFactory\n  }\n\n  /*  */\n\n  function getFirstComponentChild (children) {\n    if (Array.isArray(children)) {\n      for (var i = 0; i < children.length; i++) {\n        var c = children[i];\n        if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {\n          return c\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  /*  */\n\n  function initEvents (vm) {\n    vm._events = Object.create(null);\n    vm._hasHookEvent = false;\n    // init parent attached events\n    var listeners = vm.$options._parentListeners;\n    if (listeners) {\n      updateComponentListeners(vm, listeners);\n    }\n  }\n\n  var target;\n\n  function add (event, fn) {\n    target.$on(event, fn);\n  }\n\n  function remove$1 (event, fn) {\n    target.$off(event, fn);\n  }\n\n  function createOnceHandler (event, fn) {\n    var _target = target;\n    return function onceHandler () {\n      var res = fn.apply(null, arguments);\n      if (res !== null) {\n        _target.$off(event, onceHandler);\n      }\n    }\n  }\n\n  function updateComponentListeners (\n    vm,\n    listeners,\n    oldListeners\n  ) {\n    target = vm;\n    updateListeners(listeners, oldListeners || {}, add, remove$1, createOnceHandler, vm);\n    target = undefined;\n  }\n\n  function eventsMixin (Vue) {\n    var hookRE = /^hook:/;\n    Vue.prototype.$on = function (event, fn) {\n      var vm = this;\n      if (Array.isArray(event)) {\n        for (var i = 0, l = event.length; i < l; i++) {\n          vm.$on(event[i], fn);\n        }\n      } else {\n        (vm._events[event] || (vm._events[event] = [])).push(fn);\n        // optimize hook:event cost by using a boolean flag marked at registration\n        // instead of a hash lookup\n        if (hookRE.test(event)) {\n          vm._hasHookEvent = true;\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$once = function (event, fn) {\n      var vm = this;\n      function on () {\n        vm.$off(event, on);\n        fn.apply(vm, arguments);\n      }\n      on.fn = fn;\n      vm.$on(event, on);\n      return vm\n    };\n\n    Vue.prototype.$off = function (event, fn) {\n      var vm = this;\n      // all\n      if (!arguments.length) {\n        vm._events = Object.create(null);\n        return vm\n      }\n      // array of events\n      if (Array.isArray(event)) {\n        for (var i$1 = 0, l = event.length; i$1 < l; i$1++) {\n          vm.$off(event[i$1], fn);\n        }\n        return vm\n      }\n      // specific event\n      var cbs = vm._events[event];\n      if (!cbs) {\n        return vm\n      }\n      if (!fn) {\n        vm._events[event] = null;\n        return vm\n      }\n      // specific handler\n      var cb;\n      var i = cbs.length;\n      while (i--) {\n        cb = cbs[i];\n        if (cb === fn || cb.fn === fn) {\n          cbs.splice(i, 1);\n          break\n        }\n      }\n      return vm\n    };\n\n    Vue.prototype.$emit = function (event) {\n      var vm = this;\n      {\n        var lowerCaseEvent = event.toLowerCase();\n        if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {\n          tip(\n            \"Event \\\"\" + lowerCaseEvent + \"\\\" is emitted in component \" +\n            (formatComponentName(vm)) + \" but the handler is registered for \\\"\" + event + \"\\\". \" +\n            \"Note that HTML attributes are case-insensitive and you cannot use \" +\n            \"v-on to listen to camelCase events when using in-DOM templates. \" +\n            \"You should probably use \\\"\" + (hyphenate(event)) + \"\\\" instead of \\\"\" + event + \"\\\".\"\n          );\n        }\n      }\n      var cbs = vm._events[event];\n      if (cbs) {\n        cbs = cbs.length > 1 ? toArray(cbs) : cbs;\n        var args = toArray(arguments, 1);\n        var info = \"event handler for \\\"\" + event + \"\\\"\";\n        for (var i = 0, l = cbs.length; i < l; i++) {\n          invokeWithErrorHandling(cbs[i], vm, args, vm, info);\n        }\n      }\n      return vm\n    };\n  }\n\n  /*  */\n\n  var activeInstance = null;\n  var isUpdatingChildComponent = false;\n\n  function setActiveInstance(vm) {\n    var prevActiveInstance = activeInstance;\n    activeInstance = vm;\n    return function () {\n      activeInstance = prevActiveInstance;\n    }\n  }\n\n  function initLifecycle (vm) {\n    var options = vm.$options;\n\n    // locate first non-abstract parent\n    var parent = options.parent;\n    if (parent && !options.abstract) {\n      while (parent.$options.abstract && parent.$parent) {\n        parent = parent.$parent;\n      }\n      parent.$children.push(vm);\n    }\n\n    vm.$parent = parent;\n    vm.$root = parent ? parent.$root : vm;\n\n    vm.$children = [];\n    vm.$refs = {};\n\n    vm._watcher = null;\n    vm._inactive = null;\n    vm._directInactive = false;\n    vm._isMounted = false;\n    vm._isDestroyed = false;\n    vm._isBeingDestroyed = false;\n  }\n\n  function lifecycleMixin (Vue) {\n    Vue.prototype._update = function (vnode, hydrating) {\n      var vm = this;\n      var prevEl = vm.$el;\n      var prevVnode = vm._vnode;\n      var restoreActiveInstance = setActiveInstance(vm);\n      vm._vnode = vnode;\n      // Vue.prototype.__patch__ is injected in entry points\n      // based on the rendering backend used.\n      if (!prevVnode) {\n        // initial render\n        vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */);\n      } else {\n        // updates\n        vm.$el = vm.__patch__(prevVnode, vnode);\n      }\n      restoreActiveInstance();\n      // update __vue__ reference\n      if (prevEl) {\n        prevEl.__vue__ = null;\n      }\n      if (vm.$el) {\n        vm.$el.__vue__ = vm;\n      }\n      // if parent is an HOC, update its $el as well\n      if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {\n        vm.$parent.$el = vm.$el;\n      }\n      // updated hook is called by the scheduler to ensure that children are\n      // updated in a parent's updated hook.\n    };\n\n    Vue.prototype.$forceUpdate = function () {\n      var vm = this;\n      if (vm._watcher) {\n        vm._watcher.update();\n      }\n    };\n\n    Vue.prototype.$destroy = function () {\n      var vm = this;\n      if (vm._isBeingDestroyed) {\n        return\n      }\n      callHook(vm, 'beforeDestroy');\n      vm._isBeingDestroyed = true;\n      // remove self from parent\n      var parent = vm.$parent;\n      if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {\n        remove(parent.$children, vm);\n      }\n      // teardown watchers\n      if (vm._watcher) {\n        vm._watcher.teardown();\n      }\n      var i = vm._watchers.length;\n      while (i--) {\n        vm._watchers[i].teardown();\n      }\n      // remove reference from data ob\n      // frozen object may not have observer.\n      if (vm._data.__ob__) {\n        vm._data.__ob__.vmCount--;\n      }\n      // call the last hook...\n      vm._isDestroyed = true;\n      // invoke destroy hooks on current rendered tree\n      vm.__patch__(vm._vnode, null);\n      // fire destroyed hook\n      callHook(vm, 'destroyed');\n      // turn off all instance listeners.\n      vm.$off();\n      // remove __vue__ reference\n      if (vm.$el) {\n        vm.$el.__vue__ = null;\n      }\n      // release circular reference (#6759)\n      if (vm.$vnode) {\n        vm.$vnode.parent = null;\n      }\n    };\n  }\n\n  function mountComponent (\n    vm,\n    el,\n    hydrating\n  ) {\n    vm.$el = el;\n    if (!vm.$options.render) {\n      vm.$options.render = createEmptyVNode;\n      {\n        /* istanbul ignore if */\n        if ((vm.$options.template && vm.$options.template.charAt(0) !== '#') ||\n          vm.$options.el || el) {\n          warn(\n            'You are using the runtime-only build of Vue where the template ' +\n            'compiler is not available. Either pre-compile the templates into ' +\n            'render functions, or use the compiler-included build.',\n            vm\n          );\n        } else {\n          warn(\n            'Failed to mount component: template or render function not defined.',\n            vm\n          );\n        }\n      }\n    }\n    callHook(vm, 'beforeMount');\n\n    var updateComponent;\n    /* istanbul ignore if */\n    if (config.performance && mark) {\n      updateComponent = function () {\n        var name = vm._name;\n        var id = vm._uid;\n        var startTag = \"vue-perf-start:\" + id;\n        var endTag = \"vue-perf-end:\" + id;\n\n        mark(startTag);\n        var vnode = vm._render();\n        mark(endTag);\n        measure((\"vue \" + name + \" render\"), startTag, endTag);\n\n        mark(startTag);\n        vm._update(vnode, hydrating);\n        mark(endTag);\n        measure((\"vue \" + name + \" patch\"), startTag, endTag);\n      };\n    } else {\n      updateComponent = function () {\n        vm._update(vm._render(), hydrating);\n      };\n    }\n\n    // we set this to vm._watcher inside the watcher's constructor\n    // since the watcher's initial patch may call $forceUpdate (e.g. inside child\n    // component's mounted hook), which relies on vm._watcher being already defined\n    new Watcher(vm, updateComponent, noop, {\n      before: function before () {\n        if (vm._isMounted && !vm._isDestroyed) {\n          callHook(vm, 'beforeUpdate');\n        }\n      }\n    }, true /* isRenderWatcher */);\n    hydrating = false;\n\n    // manually mounted instance, call mounted on self\n    // mounted is called for render-created child components in its inserted hook\n    if (vm.$vnode == null) {\n      vm._isMounted = true;\n      callHook(vm, 'mounted');\n    }\n    return vm\n  }\n\n  function updateChildComponent (\n    vm,\n    propsData,\n    listeners,\n    parentVnode,\n    renderChildren\n  ) {\n    {\n      isUpdatingChildComponent = true;\n    }\n\n    // determine whether component has slot children\n    // we need to do this before overwriting $options._renderChildren.\n\n    // check if there are dynamic scopedSlots (hand-written or compiled but with\n    // dynamic slot names). Static scoped slots compiled from template has the\n    // \"$stable\" marker.\n    var newScopedSlots = parentVnode.data.scopedSlots;\n    var oldScopedSlots = vm.$scopedSlots;\n    var hasDynamicScopedSlot = !!(\n      (newScopedSlots && !newScopedSlots.$stable) ||\n      (oldScopedSlots !== emptyObject && !oldScopedSlots.$stable) ||\n      (newScopedSlots && vm.$scopedSlots.$key !== newScopedSlots.$key)\n    );\n\n    // Any static slot children from the parent may have changed during parent's\n    // update. Dynamic scoped slots may also have changed. In such cases, a forced\n    // update is necessary to ensure correctness.\n    var needsForceUpdate = !!(\n      renderChildren ||               // has new static slots\n      vm.$options._renderChildren ||  // has old static slots\n      hasDynamicScopedSlot\n    );\n\n    vm.$options._parentVnode = parentVnode;\n    vm.$vnode = parentVnode; // update vm's placeholder node without re-render\n\n    if (vm._vnode) { // update child tree's parent\n      vm._vnode.parent = parentVnode;\n    }\n    vm.$options._renderChildren = renderChildren;\n\n    // update $attrs and $listeners hash\n    // these are also reactive so they may trigger child update if the child\n    // used them during render\n    vm.$attrs = parentVnode.data.attrs || emptyObject;\n    vm.$listeners = listeners || emptyObject;\n\n    // update props\n    if (propsData && vm.$options.props) {\n      toggleObserving(false);\n      var props = vm._props;\n      var propKeys = vm.$options._propKeys || [];\n      for (var i = 0; i < propKeys.length; i++) {\n        var key = propKeys[i];\n        var propOptions = vm.$options.props; // wtf flow?\n        props[key] = validateProp(key, propOptions, propsData, vm);\n      }\n      toggleObserving(true);\n      // keep a copy of raw propsData\n      vm.$options.propsData = propsData;\n    }\n\n    // update listeners\n    listeners = listeners || emptyObject;\n    var oldListeners = vm.$options._parentListeners;\n    vm.$options._parentListeners = listeners;\n    updateComponentListeners(vm, listeners, oldListeners);\n\n    // resolve slots + force update if has children\n    if (needsForceUpdate) {\n      vm.$slots = resolveSlots(renderChildren, parentVnode.context);\n      vm.$forceUpdate();\n    }\n\n    {\n      isUpdatingChildComponent = false;\n    }\n  }\n\n  function isInInactiveTree (vm) {\n    while (vm && (vm = vm.$parent)) {\n      if (vm._inactive) { return true }\n    }\n    return false\n  }\n\n  function activateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = false;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    } else if (vm._directInactive) {\n      return\n    }\n    if (vm._inactive || vm._inactive === null) {\n      vm._inactive = false;\n      for (var i = 0; i < vm.$children.length; i++) {\n        activateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'activated');\n    }\n  }\n\n  function deactivateChildComponent (vm, direct) {\n    if (direct) {\n      vm._directInactive = true;\n      if (isInInactiveTree(vm)) {\n        return\n      }\n    }\n    if (!vm._inactive) {\n      vm._inactive = true;\n      for (var i = 0; i < vm.$children.length; i++) {\n        deactivateChildComponent(vm.$children[i]);\n      }\n      callHook(vm, 'deactivated');\n    }\n  }\n\n  function callHook (vm, hook) {\n    // #7573 disable dep collection when invoking lifecycle hooks\n    pushTarget();\n    var handlers = vm.$options[hook];\n    var info = hook + \" hook\";\n    if (handlers) {\n      for (var i = 0, j = handlers.length; i < j; i++) {\n        invokeWithErrorHandling(handlers[i], vm, null, vm, info);\n      }\n    }\n    if (vm._hasHookEvent) {\n      vm.$emit('hook:' + hook);\n    }\n    popTarget();\n  }\n\n  /*  */\n\n  var MAX_UPDATE_COUNT = 100;\n\n  var queue = [];\n  var activatedChildren = [];\n  var has = {};\n  var circular = {};\n  var waiting = false;\n  var flushing = false;\n  var index = 0;\n\n  /**\n   * Reset the scheduler's state.\n   */\n  function resetSchedulerState () {\n    index = queue.length = activatedChildren.length = 0;\n    has = {};\n    {\n      circular = {};\n    }\n    waiting = flushing = false;\n  }\n\n  // Async edge case #6566 requires saving the timestamp when event listeners are\n  // attached. However, calling performance.now() has a perf overhead especially\n  // if the page has thousands of event listeners. Instead, we take a timestamp\n  // every time the scheduler flushes and use that for all event listeners\n  // attached during that flush.\n  var currentFlushTimestamp = 0;\n\n  // Async edge case fix requires storing an event listener's attach timestamp.\n  var getNow = Date.now;\n\n  // Determine what event timestamp the browser is using. Annoyingly, the\n  // timestamp can either be hi-res (relative to page load) or low-res\n  // (relative to UNIX epoch), so in order to compare time we have to use the\n  // same timestamp type when saving the flush timestamp.\n  // All IE versions use low-res event timestamps, and have problematic clock\n  // implementations (#9632)\n  if (inBrowser && !isIE) {\n    var performance = window.performance;\n    if (\n      performance &&\n      typeof performance.now === 'function' &&\n      getNow() > document.createEvent('Event').timeStamp\n    ) {\n      // if the event timestamp, although evaluated AFTER the Date.now(), is\n      // smaller than it, it means the event is using a hi-res timestamp,\n      // and we need to use the hi-res version for event listener timestamps as\n      // well.\n      getNow = function () { return performance.now(); };\n    }\n  }\n\n  /**\n   * Flush both queues and run the watchers.\n   */\n  function flushSchedulerQueue () {\n    currentFlushTimestamp = getNow();\n    flushing = true;\n    var watcher, id;\n\n    // Sort queue before flush.\n    // This ensures that:\n    // 1. Components are updated from parent to child. (because parent is always\n    //    created before the child)\n    // 2. A component's user watchers are run before its render watcher (because\n    //    user watchers are created before the render watcher)\n    // 3. If a component is destroyed during a parent component's watcher run,\n    //    its watchers can be skipped.\n    queue.sort(function (a, b) { return a.id - b.id; });\n\n    // do not cache length because more watchers might be pushed\n    // as we run existing watchers\n    for (index = 0; index < queue.length; index++) {\n      watcher = queue[index];\n      if (watcher.before) {\n        watcher.before();\n      }\n      id = watcher.id;\n      has[id] = null;\n      watcher.run();\n      // in dev build, check and stop circular updates.\n      if (has[id] != null) {\n        circular[id] = (circular[id] || 0) + 1;\n        if (circular[id] > MAX_UPDATE_COUNT) {\n          warn(\n            'You may have an infinite update loop ' + (\n              watcher.user\n                ? (\"in watcher with expression \\\"\" + (watcher.expression) + \"\\\"\")\n                : \"in a component render function.\"\n            ),\n            watcher.vm\n          );\n          break\n        }\n      }\n    }\n\n    // keep copies of post queues before resetting state\n    var activatedQueue = activatedChildren.slice();\n    var updatedQueue = queue.slice();\n\n    resetSchedulerState();\n\n    // call component updated and activated hooks\n    callActivatedHooks(activatedQueue);\n    callUpdatedHooks(updatedQueue);\n\n    // devtool hook\n    /* istanbul ignore if */\n    if (devtools && config.devtools) {\n      devtools.emit('flush');\n    }\n  }\n\n  function callUpdatedHooks (queue) {\n    var i = queue.length;\n    while (i--) {\n      var watcher = queue[i];\n      var vm = watcher.vm;\n      if (vm._watcher === watcher && vm._isMounted && !vm._isDestroyed) {\n        callHook(vm, 'updated');\n      }\n    }\n  }\n\n  /**\n   * Queue a kept-alive component that was activated during patch.\n   * The queue will be processed after the entire tree has been patched.\n   */\n  function queueActivatedComponent (vm) {\n    // setting _inactive to false here so that a render function can\n    // rely on checking whether it's in an inactive tree (e.g. router-view)\n    vm._inactive = false;\n    activatedChildren.push(vm);\n  }\n\n  function callActivatedHooks (queue) {\n    for (var i = 0; i < queue.length; i++) {\n      queue[i]._inactive = true;\n      activateChildComponent(queue[i], true /* true */);\n    }\n  }\n\n  /**\n   * Push a watcher into the watcher queue.\n   * Jobs with duplicate IDs will be skipped unless it's\n   * pushed when the queue is being flushed.\n   */\n  function queueWatcher (watcher) {\n    var id = watcher.id;\n    if (has[id] == null) {\n      has[id] = true;\n      if (!flushing) {\n        queue.push(watcher);\n      } else {\n        // if already flushing, splice the watcher based on its id\n        // if already past its id, it will be run next immediately.\n        var i = queue.length - 1;\n        while (i > index && queue[i].id > watcher.id) {\n          i--;\n        }\n        queue.splice(i + 1, 0, watcher);\n      }\n      // queue the flush\n      if (!waiting) {\n        waiting = true;\n\n        if (!config.async) {\n          flushSchedulerQueue();\n          return\n        }\n        nextTick(flushSchedulerQueue);\n      }\n    }\n  }\n\n  /*  */\n\n\n\n  var uid$2 = 0;\n\n  /**\n   * A watcher parses an expression, collects dependencies,\n   * and fires callback when the expression value changes.\n   * This is used for both the $watch() api and directives.\n   */\n  var Watcher = function Watcher (\n    vm,\n    expOrFn,\n    cb,\n    options,\n    isRenderWatcher\n  ) {\n    this.vm = vm;\n    if (isRenderWatcher) {\n      vm._watcher = this;\n    }\n    vm._watchers.push(this);\n    // options\n    if (options) {\n      this.deep = !!options.deep;\n      this.user = !!options.user;\n      this.lazy = !!options.lazy;\n      this.sync = !!options.sync;\n      this.before = options.before;\n    } else {\n      this.deep = this.user = this.lazy = this.sync = false;\n    }\n    this.cb = cb;\n    this.id = ++uid$2; // uid for batching\n    this.active = true;\n    this.dirty = this.lazy; // for lazy watchers\n    this.deps = [];\n    this.newDeps = [];\n    this.depIds = new _Set();\n    this.newDepIds = new _Set();\n    this.expression = expOrFn.toString();\n    // parse expression for getter\n    if (typeof expOrFn === 'function') {\n      this.getter = expOrFn;\n    } else {\n      this.getter = parsePath(expOrFn);\n      if (!this.getter) {\n        this.getter = noop;\n        warn(\n          \"Failed watching path: \\\"\" + expOrFn + \"\\\" \" +\n          'Watcher only accepts simple dot-delimited paths. ' +\n          'For full control, use a function instead.',\n          vm\n        );\n      }\n    }\n    this.value = this.lazy\n      ? undefined\n      : this.get();\n  };\n\n  /**\n   * Evaluate the getter, and re-collect dependencies.\n   */\n  Watcher.prototype.get = function get () {\n    pushTarget(this);\n    var value;\n    var vm = this.vm;\n    try {\n      value = this.getter.call(vm, vm);\n    } catch (e) {\n      if (this.user) {\n        handleError(e, vm, (\"getter for watcher \\\"\" + (this.expression) + \"\\\"\"));\n      } else {\n        throw e\n      }\n    } finally {\n      // \"touch\" every property so they are all tracked as\n      // dependencies for deep watching\n      if (this.deep) {\n        traverse(value);\n      }\n      popTarget();\n      this.cleanupDeps();\n    }\n    return value\n  };\n\n  /**\n   * Add a dependency to this directive.\n   */\n  Watcher.prototype.addDep = function addDep (dep) {\n    var id = dep.id;\n    if (!this.newDepIds.has(id)) {\n      this.newDepIds.add(id);\n      this.newDeps.push(dep);\n      if (!this.depIds.has(id)) {\n        dep.addSub(this);\n      }\n    }\n  };\n\n  /**\n   * Clean up for dependency collection.\n   */\n  Watcher.prototype.cleanupDeps = function cleanupDeps () {\n    var i = this.deps.length;\n    while (i--) {\n      var dep = this.deps[i];\n      if (!this.newDepIds.has(dep.id)) {\n        dep.removeSub(this);\n      }\n    }\n    var tmp = this.depIds;\n    this.depIds = this.newDepIds;\n    this.newDepIds = tmp;\n    this.newDepIds.clear();\n    tmp = this.deps;\n    this.deps = this.newDeps;\n    this.newDeps = tmp;\n    this.newDeps.length = 0;\n  };\n\n  /**\n   * Subscriber interface.\n   * Will be called when a dependency changes.\n   */\n  Watcher.prototype.update = function update () {\n    /* istanbul ignore else */\n    if (this.lazy) {\n      this.dirty = true;\n    } else if (this.sync) {\n      this.run();\n    } else {\n      queueWatcher(this);\n    }\n  };\n\n  /**\n   * Scheduler job interface.\n   * Will be called by the scheduler.\n   */\n  Watcher.prototype.run = function run () {\n    if (this.active) {\n      var value = this.get();\n      if (\n        value !== this.value ||\n        // Deep watchers and watchers on Object/Arrays should fire even\n        // when the value is the same, because the value may\n        // have mutated.\n        isObject(value) ||\n        this.deep\n      ) {\n        // set new value\n        var oldValue = this.value;\n        this.value = value;\n        if (this.user) {\n          try {\n            this.cb.call(this.vm, value, oldValue);\n          } catch (e) {\n            handleError(e, this.vm, (\"callback for watcher \\\"\" + (this.expression) + \"\\\"\"));\n          }\n        } else {\n          this.cb.call(this.vm, value, oldValue);\n        }\n      }\n    }\n  };\n\n  /**\n   * Evaluate the value of the watcher.\n   * This only gets called for lazy watchers.\n   */\n  Watcher.prototype.evaluate = function evaluate () {\n    this.value = this.get();\n    this.dirty = false;\n  };\n\n  /**\n   * Depend on all deps collected by this watcher.\n   */\n  Watcher.prototype.depend = function depend () {\n    var i = this.deps.length;\n    while (i--) {\n      this.deps[i].depend();\n    }\n  };\n\n  /**\n   * Remove self from all dependencies' subscriber list.\n   */\n  Watcher.prototype.teardown = function teardown () {\n    if (this.active) {\n      // remove self from vm's watcher list\n      // this is a somewhat expensive operation so we skip it\n      // if the vm is being destroyed.\n      if (!this.vm._isBeingDestroyed) {\n        remove(this.vm._watchers, this);\n      }\n      var i = this.deps.length;\n      while (i--) {\n        this.deps[i].removeSub(this);\n      }\n      this.active = false;\n    }\n  };\n\n  /*  */\n\n  var sharedPropertyDefinition = {\n    enumerable: true,\n    configurable: true,\n    get: noop,\n    set: noop\n  };\n\n  function proxy (target, sourceKey, key) {\n    sharedPropertyDefinition.get = function proxyGetter () {\n      return this[sourceKey][key]\n    };\n    sharedPropertyDefinition.set = function proxySetter (val) {\n      this[sourceKey][key] = val;\n    };\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function initState (vm) {\n    vm._watchers = [];\n    var opts = vm.$options;\n    if (opts.props) { initProps(vm, opts.props); }\n    if (opts.methods) { initMethods(vm, opts.methods); }\n    if (opts.data) {\n      initData(vm);\n    } else {\n      observe(vm._data = {}, true /* asRootData */);\n    }\n    if (opts.computed) { initComputed(vm, opts.computed); }\n    if (opts.watch && opts.watch !== nativeWatch) {\n      initWatch(vm, opts.watch);\n    }\n  }\n\n  function initProps (vm, propsOptions) {\n    var propsData = vm.$options.propsData || {};\n    var props = vm._props = {};\n    // cache prop keys so that future props updates can iterate using Array\n    // instead of dynamic object key enumeration.\n    var keys = vm.$options._propKeys = [];\n    var isRoot = !vm.$parent;\n    // root instance props should be converted\n    if (!isRoot) {\n      toggleObserving(false);\n    }\n    var loop = function ( key ) {\n      keys.push(key);\n      var value = validateProp(key, propsOptions, propsData, vm);\n      /* istanbul ignore else */\n      {\n        var hyphenatedKey = hyphenate(key);\n        if (isReservedAttribute(hyphenatedKey) ||\n            config.isReservedAttr(hyphenatedKey)) {\n          warn(\n            (\"\\\"\" + hyphenatedKey + \"\\\" is a reserved attribute and cannot be used as component prop.\"),\n            vm\n          );\n        }\n        defineReactive$$1(props, key, value, function () {\n          if (!isRoot && !isUpdatingChildComponent) {\n            warn(\n              \"Avoid mutating a prop directly since the value will be \" +\n              \"overwritten whenever the parent component re-renders. \" +\n              \"Instead, use a data or computed property based on the prop's \" +\n              \"value. Prop being mutated: \\\"\" + key + \"\\\"\",\n              vm\n            );\n          }\n        });\n      }\n      // static props are already proxied on the component's prototype\n      // during Vue.extend(). We only need to proxy props defined at\n      // instantiation here.\n      if (!(key in vm)) {\n        proxy(vm, \"_props\", key);\n      }\n    };\n\n    for (var key in propsOptions) loop( key );\n    toggleObserving(true);\n  }\n\n  function initData (vm) {\n    var data = vm.$options.data;\n    data = vm._data = typeof data === 'function'\n      ? getData(data, vm)\n      : data || {};\n    if (!isPlainObject(data)) {\n      data = {};\n      warn(\n        'data functions should return an object:\\n' +\n        'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function',\n        vm\n      );\n    }\n    // proxy data on instance\n    var keys = Object.keys(data);\n    var props = vm.$options.props;\n    var methods = vm.$options.methods;\n    var i = keys.length;\n    while (i--) {\n      var key = keys[i];\n      {\n        if (methods && hasOwn(methods, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a data property.\"),\n            vm\n          );\n        }\n      }\n      if (props && hasOwn(props, key)) {\n        warn(\n          \"The data property \\\"\" + key + \"\\\" is already declared as a prop. \" +\n          \"Use prop default value instead.\",\n          vm\n        );\n      } else if (!isReserved(key)) {\n        proxy(vm, \"_data\", key);\n      }\n    }\n    // observe data\n    observe(data, true /* asRootData */);\n  }\n\n  function getData (data, vm) {\n    // #7573 disable dep collection when invoking data getters\n    pushTarget();\n    try {\n      return data.call(vm, vm)\n    } catch (e) {\n      handleError(e, vm, \"data()\");\n      return {}\n    } finally {\n      popTarget();\n    }\n  }\n\n  var computedWatcherOptions = { lazy: true };\n\n  function initComputed (vm, computed) {\n    // $flow-disable-line\n    var watchers = vm._computedWatchers = Object.create(null);\n    // computed properties are just getters during SSR\n    var isSSR = isServerRendering();\n\n    for (var key in computed) {\n      var userDef = computed[key];\n      var getter = typeof userDef === 'function' ? userDef : userDef.get;\n      if (getter == null) {\n        warn(\n          (\"Getter is missing for computed property \\\"\" + key + \"\\\".\"),\n          vm\n        );\n      }\n\n      if (!isSSR) {\n        // create internal watcher for the computed property.\n        watchers[key] = new Watcher(\n          vm,\n          getter || noop,\n          noop,\n          computedWatcherOptions\n        );\n      }\n\n      // component-defined computed properties are already defined on the\n      // component prototype. We only need to define computed properties defined\n      // at instantiation here.\n      if (!(key in vm)) {\n        defineComputed(vm, key, userDef);\n      } else {\n        if (key in vm.$data) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined in data.\"), vm);\n        } else if (vm.$options.props && key in vm.$options.props) {\n          warn((\"The computed property \\\"\" + key + \"\\\" is already defined as a prop.\"), vm);\n        }\n      }\n    }\n  }\n\n  function defineComputed (\n    target,\n    key,\n    userDef\n  ) {\n    var shouldCache = !isServerRendering();\n    if (typeof userDef === 'function') {\n      sharedPropertyDefinition.get = shouldCache\n        ? createComputedGetter(key)\n        : createGetterInvoker(userDef);\n      sharedPropertyDefinition.set = noop;\n    } else {\n      sharedPropertyDefinition.get = userDef.get\n        ? shouldCache && userDef.cache !== false\n          ? createComputedGetter(key)\n          : createGetterInvoker(userDef.get)\n        : noop;\n      sharedPropertyDefinition.set = userDef.set || noop;\n    }\n    if (sharedPropertyDefinition.set === noop) {\n      sharedPropertyDefinition.set = function () {\n        warn(\n          (\"Computed property \\\"\" + key + \"\\\" was assigned to but it has no setter.\"),\n          this\n        );\n      };\n    }\n    Object.defineProperty(target, key, sharedPropertyDefinition);\n  }\n\n  function createComputedGetter (key) {\n    return function computedGetter () {\n      var watcher = this._computedWatchers && this._computedWatchers[key];\n      if (watcher) {\n        if (watcher.dirty) {\n          watcher.evaluate();\n        }\n        if (Dep.target) {\n          watcher.depend();\n        }\n        return watcher.value\n      }\n    }\n  }\n\n  function createGetterInvoker(fn) {\n    return function computedGetter () {\n      return fn.call(this, this)\n    }\n  }\n\n  function initMethods (vm, methods) {\n    var props = vm.$options.props;\n    for (var key in methods) {\n      {\n        if (typeof methods[key] !== 'function') {\n          warn(\n            \"Method \\\"\" + key + \"\\\" has type \\\"\" + (typeof methods[key]) + \"\\\" in the component definition. \" +\n            \"Did you reference the function correctly?\",\n            vm\n          );\n        }\n        if (props && hasOwn(props, key)) {\n          warn(\n            (\"Method \\\"\" + key + \"\\\" has already been defined as a prop.\"),\n            vm\n          );\n        }\n        if ((key in vm) && isReserved(key)) {\n          warn(\n            \"Method \\\"\" + key + \"\\\" conflicts with an existing Vue instance method. \" +\n            \"Avoid defining component methods that start with _ or $.\"\n          );\n        }\n      }\n      vm[key] = typeof methods[key] !== 'function' ? noop : bind(methods[key], vm);\n    }\n  }\n\n  function initWatch (vm, watch) {\n    for (var key in watch) {\n      var handler = watch[key];\n      if (Array.isArray(handler)) {\n        for (var i = 0; i < handler.length; i++) {\n          createWatcher(vm, key, handler[i]);\n        }\n      } else {\n        createWatcher(vm, key, handler);\n      }\n    }\n  }\n\n  function createWatcher (\n    vm,\n    expOrFn,\n    handler,\n    options\n  ) {\n    if (isPlainObject(handler)) {\n      options = handler;\n      handler = handler.handler;\n    }\n    if (typeof handler === 'string') {\n      handler = vm[handler];\n    }\n    return vm.$watch(expOrFn, handler, options)\n  }\n\n  function stateMixin (Vue) {\n    // flow somehow has problems with directly declared definition object\n    // when using Object.defineProperty, so we have to procedurally build up\n    // the object here.\n    var dataDef = {};\n    dataDef.get = function () { return this._data };\n    var propsDef = {};\n    propsDef.get = function () { return this._props };\n    {\n      dataDef.set = function () {\n        warn(\n          'Avoid replacing instance root $data. ' +\n          'Use nested data properties instead.',\n          this\n        );\n      };\n      propsDef.set = function () {\n        warn(\"$props is readonly.\", this);\n      };\n    }\n    Object.defineProperty(Vue.prototype, '$data', dataDef);\n    Object.defineProperty(Vue.prototype, '$props', propsDef);\n\n    Vue.prototype.$set = set;\n    Vue.prototype.$delete = del;\n\n    Vue.prototype.$watch = function (\n      expOrFn,\n      cb,\n      options\n    ) {\n      var vm = this;\n      if (isPlainObject(cb)) {\n        return createWatcher(vm, expOrFn, cb, options)\n      }\n      options = options || {};\n      options.user = true;\n      var watcher = new Watcher(vm, expOrFn, cb, options);\n      if (options.immediate) {\n        try {\n          cb.call(vm, watcher.value);\n        } catch (error) {\n          handleError(error, vm, (\"callback for immediate watcher \\\"\" + (watcher.expression) + \"\\\"\"));\n        }\n      }\n      return function unwatchFn () {\n        watcher.teardown();\n      }\n    };\n  }\n\n  /*  */\n\n  var uid$3 = 0;\n\n  function initMixin (Vue) {\n    Vue.prototype._init = function (options) {\n      var vm = this;\n      // a uid\n      vm._uid = uid$3++;\n\n      var startTag, endTag;\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        startTag = \"vue-perf-start:\" + (vm._uid);\n        endTag = \"vue-perf-end:\" + (vm._uid);\n        mark(startTag);\n      }\n\n      // a flag to avoid this being observed\n      vm._isVue = true;\n      // merge options\n      if (options && options._isComponent) {\n        // optimize internal component instantiation\n        // since dynamic options merging is pretty slow, and none of the\n        // internal component options needs special treatment.\n        initInternalComponent(vm, options);\n      } else {\n        vm.$options = mergeOptions(\n          resolveConstructorOptions(vm.constructor),\n          options || {},\n          vm\n        );\n      }\n      /* istanbul ignore else */\n      {\n        initProxy(vm);\n      }\n      // expose real self\n      vm._self = vm;\n      initLifecycle(vm);\n      initEvents(vm);\n      initRender(vm);\n      callHook(vm, 'beforeCreate');\n      initInjections(vm); // resolve injections before data/props\n      initState(vm);\n      initProvide(vm); // resolve provide after data/props\n      callHook(vm, 'created');\n\n      /* istanbul ignore if */\n      if (config.performance && mark) {\n        vm._name = formatComponentName(vm, false);\n        mark(endTag);\n        measure((\"vue \" + (vm._name) + \" init\"), startTag, endTag);\n      }\n\n      if (vm.$options.el) {\n        vm.$mount(vm.$options.el);\n      }\n    };\n  }\n\n  function initInternalComponent (vm, options) {\n    var opts = vm.$options = Object.create(vm.constructor.options);\n    // doing this because it's faster than dynamic enumeration.\n    var parentVnode = options._parentVnode;\n    opts.parent = options.parent;\n    opts._parentVnode = parentVnode;\n\n    var vnodeComponentOptions = parentVnode.componentOptions;\n    opts.propsData = vnodeComponentOptions.propsData;\n    opts._parentListeners = vnodeComponentOptions.listeners;\n    opts._renderChildren = vnodeComponentOptions.children;\n    opts._componentTag = vnodeComponentOptions.tag;\n\n    if (options.render) {\n      opts.render = options.render;\n      opts.staticRenderFns = options.staticRenderFns;\n    }\n  }\n\n  function resolveConstructorOptions (Ctor) {\n    var options = Ctor.options;\n    if (Ctor.super) {\n      var superOptions = resolveConstructorOptions(Ctor.super);\n      var cachedSuperOptions = Ctor.superOptions;\n      if (superOptions !== cachedSuperOptions) {\n        // super option changed,\n        // need to resolve new options.\n        Ctor.superOptions = superOptions;\n        // check if there are any late-modified/attached options (#4976)\n        var modifiedOptions = resolveModifiedOptions(Ctor);\n        // update base extend options\n        if (modifiedOptions) {\n          extend(Ctor.extendOptions, modifiedOptions);\n        }\n        options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);\n        if (options.name) {\n          options.components[options.name] = Ctor;\n        }\n      }\n    }\n    return options\n  }\n\n  function resolveModifiedOptions (Ctor) {\n    var modified;\n    var latest = Ctor.options;\n    var sealed = Ctor.sealedOptions;\n    for (var key in latest) {\n      if (latest[key] !== sealed[key]) {\n        if (!modified) { modified = {}; }\n        modified[key] = latest[key];\n      }\n    }\n    return modified\n  }\n\n  function Vue (options) {\n    if (!(this instanceof Vue)\n    ) {\n      warn('Vue is a constructor and should be called with the `new` keyword');\n    }\n    this._init(options);\n  }\n\n  initMixin(Vue);\n  stateMixin(Vue);\n  eventsMixin(Vue);\n  lifecycleMixin(Vue);\n  renderMixin(Vue);\n\n  /*  */\n\n  function initUse (Vue) {\n    Vue.use = function (plugin) {\n      var installedPlugins = (this._installedPlugins || (this._installedPlugins = []));\n      if (installedPlugins.indexOf(plugin) > -1) {\n        return this\n      }\n\n      // additional parameters\n      var args = toArray(arguments, 1);\n      args.unshift(this);\n      if (typeof plugin.install === 'function') {\n        plugin.install.apply(plugin, args);\n      } else if (typeof plugin === 'function') {\n        plugin.apply(null, args);\n      }\n      installedPlugins.push(plugin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initMixin$1 (Vue) {\n    Vue.mixin = function (mixin) {\n      this.options = mergeOptions(this.options, mixin);\n      return this\n    };\n  }\n\n  /*  */\n\n  function initExtend (Vue) {\n    /**\n     * Each instance constructor, including Vue, has a unique\n     * cid. This enables us to create wrapped \"child\n     * constructors\" for prototypal inheritance and cache them.\n     */\n    Vue.cid = 0;\n    var cid = 1;\n\n    /**\n     * Class inheritance\n     */\n    Vue.extend = function (extendOptions) {\n      extendOptions = extendOptions || {};\n      var Super = this;\n      var SuperId = Super.cid;\n      var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});\n      if (cachedCtors[SuperId]) {\n        return cachedCtors[SuperId]\n      }\n\n      var name = extendOptions.name || Super.options.name;\n      if (name) {\n        validateComponentName(name);\n      }\n\n      var Sub = function VueComponent (options) {\n        this._init(options);\n      };\n      Sub.prototype = Object.create(Super.prototype);\n      Sub.prototype.constructor = Sub;\n      Sub.cid = cid++;\n      Sub.options = mergeOptions(\n        Super.options,\n        extendOptions\n      );\n      Sub['super'] = Super;\n\n      // For props and computed properties, we define the proxy getters on\n      // the Vue instances at extension time, on the extended prototype. This\n      // avoids Object.defineProperty calls for each instance created.\n      if (Sub.options.props) {\n        initProps$1(Sub);\n      }\n      if (Sub.options.computed) {\n        initComputed$1(Sub);\n      }\n\n      // allow further extension/mixin/plugin usage\n      Sub.extend = Super.extend;\n      Sub.mixin = Super.mixin;\n      Sub.use = Super.use;\n\n      // create asset registers, so extended classes\n      // can have their private assets too.\n      ASSET_TYPES.forEach(function (type) {\n        Sub[type] = Super[type];\n      });\n      // enable recursive self-lookup\n      if (name) {\n        Sub.options.components[name] = Sub;\n      }\n\n      // keep a reference to the super options at extension time.\n      // later at instantiation we can check if Super's options have\n      // been updated.\n      Sub.superOptions = Super.options;\n      Sub.extendOptions = extendOptions;\n      Sub.sealedOptions = extend({}, Sub.options);\n\n      // cache constructor\n      cachedCtors[SuperId] = Sub;\n      return Sub\n    };\n  }\n\n  function initProps$1 (Comp) {\n    var props = Comp.options.props;\n    for (var key in props) {\n      proxy(Comp.prototype, \"_props\", key);\n    }\n  }\n\n  function initComputed$1 (Comp) {\n    var computed = Comp.options.computed;\n    for (var key in computed) {\n      defineComputed(Comp.prototype, key, computed[key]);\n    }\n  }\n\n  /*  */\n\n  function initAssetRegisters (Vue) {\n    /**\n     * Create asset registration methods.\n     */\n    ASSET_TYPES.forEach(function (type) {\n      Vue[type] = function (\n        id,\n        definition\n      ) {\n        if (!definition) {\n          return this.options[type + 's'][id]\n        } else {\n          /* istanbul ignore if */\n          if (type === 'component') {\n            validateComponentName(id);\n          }\n          if (type === 'component' && isPlainObject(definition)) {\n            definition.name = definition.name || id;\n            definition = this.options._base.extend(definition);\n          }\n          if (type === 'directive' && typeof definition === 'function') {\n            definition = { bind: definition, update: definition };\n          }\n          this.options[type + 's'][id] = definition;\n          return definition\n        }\n      };\n    });\n  }\n\n  /*  */\n\n\n\n  function getComponentName (opts) {\n    return opts && (opts.Ctor.options.name || opts.tag)\n  }\n\n  function matches (pattern, name) {\n    if (Array.isArray(pattern)) {\n      return pattern.indexOf(name) > -1\n    } else if (typeof pattern === 'string') {\n      return pattern.split(',').indexOf(name) > -1\n    } else if (isRegExp(pattern)) {\n      return pattern.test(name)\n    }\n    /* istanbul ignore next */\n    return false\n  }\n\n  function pruneCache (keepAliveInstance, filter) {\n    var cache = keepAliveInstance.cache;\n    var keys = keepAliveInstance.keys;\n    var _vnode = keepAliveInstance._vnode;\n    for (var key in cache) {\n      var cachedNode = cache[key];\n      if (cachedNode) {\n        var name = getComponentName(cachedNode.componentOptions);\n        if (name && !filter(name)) {\n          pruneCacheEntry(cache, key, keys, _vnode);\n        }\n      }\n    }\n  }\n\n  function pruneCacheEntry (\n    cache,\n    key,\n    keys,\n    current\n  ) {\n    var cached$$1 = cache[key];\n    if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {\n      cached$$1.componentInstance.$destroy();\n    }\n    cache[key] = null;\n    remove(keys, key);\n  }\n\n  var patternTypes = [String, RegExp, Array];\n\n  var KeepAlive = {\n    name: 'keep-alive',\n    abstract: true,\n\n    props: {\n      include: patternTypes,\n      exclude: patternTypes,\n      max: [String, Number]\n    },\n\n    created: function created () {\n      this.cache = Object.create(null);\n      this.keys = [];\n    },\n\n    destroyed: function destroyed () {\n      for (var key in this.cache) {\n        pruneCacheEntry(this.cache, key, this.keys);\n      }\n    },\n\n    mounted: function mounted () {\n      var this$1 = this;\n\n      this.$watch('include', function (val) {\n        pruneCache(this$1, function (name) { return matches(val, name); });\n      });\n      this.$watch('exclude', function (val) {\n        pruneCache(this$1, function (name) { return !matches(val, name); });\n      });\n    },\n\n    render: function render () {\n      var slot = this.$slots.default;\n      var vnode = getFirstComponentChild(slot);\n      var componentOptions = vnode && vnode.componentOptions;\n      if (componentOptions) {\n        // check pattern\n        var name = getComponentName(componentOptions);\n        var ref = this;\n        var include = ref.include;\n        var exclude = ref.exclude;\n        if (\n          // not included\n          (include && (!name || !matches(include, name))) ||\n          // excluded\n          (exclude && name && matches(exclude, name))\n        ) {\n          return vnode\n        }\n\n        var ref$1 = this;\n        var cache = ref$1.cache;\n        var keys = ref$1.keys;\n        var key = vnode.key == null\n          // same constructor may get registered as different local components\n          // so cid alone is not enough (#3269)\n          ? componentOptions.Ctor.cid + (componentOptions.tag ? (\"::\" + (componentOptions.tag)) : '')\n          : vnode.key;\n        if (cache[key]) {\n          vnode.componentInstance = cache[key].componentInstance;\n          // make current key freshest\n          remove(keys, key);\n          keys.push(key);\n        } else {\n          cache[key] = vnode;\n          keys.push(key);\n          // prune oldest entry\n          if (this.max && keys.length > parseInt(this.max)) {\n            pruneCacheEntry(cache, keys[0], keys, this._vnode);\n          }\n        }\n\n        vnode.data.keepAlive = true;\n      }\n      return vnode || (slot && slot[0])\n    }\n  };\n\n  var builtInComponents = {\n    KeepAlive: KeepAlive\n  };\n\n  /*  */\n\n  function initGlobalAPI (Vue) {\n    // config\n    var configDef = {};\n    configDef.get = function () { return config; };\n    {\n      configDef.set = function () {\n        warn(\n          'Do not replace the Vue.config object, set individual fields instead.'\n        );\n      };\n    }\n    Object.defineProperty(Vue, 'config', configDef);\n\n    // exposed util methods.\n    // NOTE: these are not considered part of the public API - avoid relying on\n    // them unless you are aware of the risk.\n    Vue.util = {\n      warn: warn,\n      extend: extend,\n      mergeOptions: mergeOptions,\n      defineReactive: defineReactive$$1\n    };\n\n    Vue.set = set;\n    Vue.delete = del;\n    Vue.nextTick = nextTick;\n\n    // 2.6 explicit observable API\n    Vue.observable = function (obj) {\n      observe(obj);\n      return obj\n    };\n\n    Vue.options = Object.create(null);\n    ASSET_TYPES.forEach(function (type) {\n      Vue.options[type + 's'] = Object.create(null);\n    });\n\n    // this is used to identify the \"base\" constructor to extend all plain-object\n    // components with in Weex's multi-instance scenarios.\n    Vue.options._base = Vue;\n\n    extend(Vue.options.components, builtInComponents);\n\n    initUse(Vue);\n    initMixin$1(Vue);\n    initExtend(Vue);\n    initAssetRegisters(Vue);\n  }\n\n  initGlobalAPI(Vue);\n\n  Object.defineProperty(Vue.prototype, '$isServer', {\n    get: isServerRendering\n  });\n\n  Object.defineProperty(Vue.prototype, '$ssrContext', {\n    get: function get () {\n      /* istanbul ignore next */\n      return this.$vnode && this.$vnode.ssrContext\n    }\n  });\n\n  // expose FunctionalRenderContext for ssr runtime helper installation\n  Object.defineProperty(Vue, 'FunctionalRenderContext', {\n    value: FunctionalRenderContext\n  });\n\n  Vue.version = '2.6.10';\n\n  /*  */\n\n  // these are reserved for web because they are directly compiled away\n  // during template compilation\n  var isReservedAttr = makeMap('style,class');\n\n  // attributes that should be using props for binding\n  var acceptValue = makeMap('input,textarea,option,select,progress');\n  var mustUseProp = function (tag, type, attr) {\n    return (\n      (attr === 'value' && acceptValue(tag)) && type !== 'button' ||\n      (attr === 'selected' && tag === 'option') ||\n      (attr === 'checked' && tag === 'input') ||\n      (attr === 'muted' && tag === 'video')\n    )\n  };\n\n  var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');\n\n  var isValidContentEditableValue = makeMap('events,caret,typing,plaintext-only');\n\n  var convertEnumeratedValue = function (key, value) {\n    return isFalsyAttrValue(value) || value === 'false'\n      ? 'false'\n      // allow arbitrary string value for contenteditable\n      : key === 'contenteditable' && isValidContentEditableValue(value)\n        ? value\n        : 'true'\n  };\n\n  var isBooleanAttr = makeMap(\n    'allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' +\n    'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' +\n    'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' +\n    'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' +\n    'required,reversed,scoped,seamless,selected,sortable,translate,' +\n    'truespeed,typemustmatch,visible'\n  );\n\n  var xlinkNS = 'http://www.w3.org/1999/xlink';\n\n  var isXlink = function (name) {\n    return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink'\n  };\n\n  var getXlinkProp = function (name) {\n    return isXlink(name) ? name.slice(6, name.length) : ''\n  };\n\n  var isFalsyAttrValue = function (val) {\n    return val == null || val === false\n  };\n\n  /*  */\n\n  function genClassForVnode (vnode) {\n    var data = vnode.data;\n    var parentNode = vnode;\n    var childNode = vnode;\n    while (isDef(childNode.componentInstance)) {\n      childNode = childNode.componentInstance._vnode;\n      if (childNode && childNode.data) {\n        data = mergeClassData(childNode.data, data);\n      }\n    }\n    while (isDef(parentNode = parentNode.parent)) {\n      if (parentNode && parentNode.data) {\n        data = mergeClassData(data, parentNode.data);\n      }\n    }\n    return renderClass(data.staticClass, data.class)\n  }\n\n  function mergeClassData (child, parent) {\n    return {\n      staticClass: concat(child.staticClass, parent.staticClass),\n      class: isDef(child.class)\n        ? [child.class, parent.class]\n        : parent.class\n    }\n  }\n\n  function renderClass (\n    staticClass,\n    dynamicClass\n  ) {\n    if (isDef(staticClass) || isDef(dynamicClass)) {\n      return concat(staticClass, stringifyClass(dynamicClass))\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function concat (a, b) {\n    return a ? b ? (a + ' ' + b) : a : (b || '')\n  }\n\n  function stringifyClass (value) {\n    if (Array.isArray(value)) {\n      return stringifyArray(value)\n    }\n    if (isObject(value)) {\n      return stringifyObject(value)\n    }\n    if (typeof value === 'string') {\n      return value\n    }\n    /* istanbul ignore next */\n    return ''\n  }\n\n  function stringifyArray (value) {\n    var res = '';\n    var stringified;\n    for (var i = 0, l = value.length; i < l; i++) {\n      if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {\n        if (res) { res += ' '; }\n        res += stringified;\n      }\n    }\n    return res\n  }\n\n  function stringifyObject (value) {\n    var res = '';\n    for (var key in value) {\n      if (value[key]) {\n        if (res) { res += ' '; }\n        res += key;\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var namespaceMap = {\n    svg: 'http://www.w3.org/2000/svg',\n    math: 'http://www.w3.org/1998/Math/MathML'\n  };\n\n  var isHTMLTag = makeMap(\n    'html,body,base,head,link,meta,style,title,' +\n    'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' +\n    'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' +\n    'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' +\n    's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' +\n    'embed,object,param,source,canvas,script,noscript,del,ins,' +\n    'caption,col,colgroup,table,thead,tbody,td,th,tr,' +\n    'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' +\n    'output,progress,select,textarea,' +\n    'details,dialog,menu,menuitem,summary,' +\n    'content,element,shadow,template,blockquote,iframe,tfoot'\n  );\n\n  // this map is intentionally selective, only covering SVG elements that may\n  // contain child elements.\n  var isSVG = makeMap(\n    'svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' +\n    'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' +\n    'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view',\n    true\n  );\n\n  var isPreTag = function (tag) { return tag === 'pre'; };\n\n  var isReservedTag = function (tag) {\n    return isHTMLTag(tag) || isSVG(tag)\n  };\n\n  function getTagNamespace (tag) {\n    if (isSVG(tag)) {\n      return 'svg'\n    }\n    // basic support for MathML\n    // note it doesn't support other MathML elements being component roots\n    if (tag === 'math') {\n      return 'math'\n    }\n  }\n\n  var unknownElementCache = Object.create(null);\n  function isUnknownElement (tag) {\n    /* istanbul ignore if */\n    if (!inBrowser) {\n      return true\n    }\n    if (isReservedTag(tag)) {\n      return false\n    }\n    tag = tag.toLowerCase();\n    /* istanbul ignore if */\n    if (unknownElementCache[tag] != null) {\n      return unknownElementCache[tag]\n    }\n    var el = document.createElement(tag);\n    if (tag.indexOf('-') > -1) {\n      // http://stackoverflow.com/a/28210364/1070244\n      return (unknownElementCache[tag] = (\n        el.constructor === window.HTMLUnknownElement ||\n        el.constructor === window.HTMLElement\n      ))\n    } else {\n      return (unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString()))\n    }\n  }\n\n  var isTextInputType = makeMap('text,number,password,search,email,tel,url');\n\n  /*  */\n\n  /**\n   * Query an element selector if it's not an element already.\n   */\n  function query (el) {\n    if (typeof el === 'string') {\n      var selected = document.querySelector(el);\n      if (!selected) {\n        warn(\n          'Cannot find element: ' + el\n        );\n        return document.createElement('div')\n      }\n      return selected\n    } else {\n      return el\n    }\n  }\n\n  /*  */\n\n  function createElement$1 (tagName, vnode) {\n    var elm = document.createElement(tagName);\n    if (tagName !== 'select') {\n      return elm\n    }\n    // false or null will remove the attribute but undefined will not\n    if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {\n      elm.setAttribute('multiple', 'multiple');\n    }\n    return elm\n  }\n\n  function createElementNS (namespace, tagName) {\n    return document.createElementNS(namespaceMap[namespace], tagName)\n  }\n\n  function createTextNode (text) {\n    return document.createTextNode(text)\n  }\n\n  function createComment (text) {\n    return document.createComment(text)\n  }\n\n  function insertBefore (parentNode, newNode, referenceNode) {\n    parentNode.insertBefore(newNode, referenceNode);\n  }\n\n  function removeChild (node, child) {\n    node.removeChild(child);\n  }\n\n  function appendChild (node, child) {\n    node.appendChild(child);\n  }\n\n  function parentNode (node) {\n    return node.parentNode\n  }\n\n  function nextSibling (node) {\n    return node.nextSibling\n  }\n\n  function tagName (node) {\n    return node.tagName\n  }\n\n  function setTextContent (node, text) {\n    node.textContent = text;\n  }\n\n  function setStyleScope (node, scopeId) {\n    node.setAttribute(scopeId, '');\n  }\n\n  var nodeOps = /*#__PURE__*/Object.freeze({\n    createElement: createElement$1,\n    createElementNS: createElementNS,\n    createTextNode: createTextNode,\n    createComment: createComment,\n    insertBefore: insertBefore,\n    removeChild: removeChild,\n    appendChild: appendChild,\n    parentNode: parentNode,\n    nextSibling: nextSibling,\n    tagName: tagName,\n    setTextContent: setTextContent,\n    setStyleScope: setStyleScope\n  });\n\n  /*  */\n\n  var ref = {\n    create: function create (_, vnode) {\n      registerRef(vnode);\n    },\n    update: function update (oldVnode, vnode) {\n      if (oldVnode.data.ref !== vnode.data.ref) {\n        registerRef(oldVnode, true);\n        registerRef(vnode);\n      }\n    },\n    destroy: function destroy (vnode) {\n      registerRef(vnode, true);\n    }\n  };\n\n  function registerRef (vnode, isRemoval) {\n    var key = vnode.data.ref;\n    if (!isDef(key)) { return }\n\n    var vm = vnode.context;\n    var ref = vnode.componentInstance || vnode.elm;\n    var refs = vm.$refs;\n    if (isRemoval) {\n      if (Array.isArray(refs[key])) {\n        remove(refs[key], ref);\n      } else if (refs[key] === ref) {\n        refs[key] = undefined;\n      }\n    } else {\n      if (vnode.data.refInFor) {\n        if (!Array.isArray(refs[key])) {\n          refs[key] = [ref];\n        } else if (refs[key].indexOf(ref) < 0) {\n          // $flow-disable-line\n          refs[key].push(ref);\n        }\n      } else {\n        refs[key] = ref;\n      }\n    }\n  }\n\n  /**\n   * Virtual DOM patching algorithm based on Snabbdom by\n   * Simon Friis Vindum (@paldepind)\n   * Licensed under the MIT License\n   * https://github.com/paldepind/snabbdom/blob/master/LICENSE\n   *\n   * modified by Evan You (@yyx990803)\n   *\n   * Not type-checking this because this file is perf-critical and the cost\n   * of making flow understand it is not worth it.\n   */\n\n  var emptyNode = new VNode('', {}, []);\n\n  var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];\n\n  function sameVnode (a, b) {\n    return (\n      a.key === b.key && (\n        (\n          a.tag === b.tag &&\n          a.isComment === b.isComment &&\n          isDef(a.data) === isDef(b.data) &&\n          sameInputType(a, b)\n        ) || (\n          isTrue(a.isAsyncPlaceholder) &&\n          a.asyncFactory === b.asyncFactory &&\n          isUndef(b.asyncFactory.error)\n        )\n      )\n    )\n  }\n\n  function sameInputType (a, b) {\n    if (a.tag !== 'input') { return true }\n    var i;\n    var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;\n    var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;\n    return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB)\n  }\n\n  function createKeyToOldIdx (children, beginIdx, endIdx) {\n    var i, key;\n    var map = {};\n    for (i = beginIdx; i <= endIdx; ++i) {\n      key = children[i].key;\n      if (isDef(key)) { map[key] = i; }\n    }\n    return map\n  }\n\n  function createPatchFunction (backend) {\n    var i, j;\n    var cbs = {};\n\n    var modules = backend.modules;\n    var nodeOps = backend.nodeOps;\n\n    for (i = 0; i < hooks.length; ++i) {\n      cbs[hooks[i]] = [];\n      for (j = 0; j < modules.length; ++j) {\n        if (isDef(modules[j][hooks[i]])) {\n          cbs[hooks[i]].push(modules[j][hooks[i]]);\n        }\n      }\n    }\n\n    function emptyNodeAt (elm) {\n      return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm)\n    }\n\n    function createRmCb (childElm, listeners) {\n      function remove$$1 () {\n        if (--remove$$1.listeners === 0) {\n          removeNode(childElm);\n        }\n      }\n      remove$$1.listeners = listeners;\n      return remove$$1\n    }\n\n    function removeNode (el) {\n      var parent = nodeOps.parentNode(el);\n      // element may have already been removed due to v-html / v-text\n      if (isDef(parent)) {\n        nodeOps.removeChild(parent, el);\n      }\n    }\n\n    function isUnknownElement$$1 (vnode, inVPre) {\n      return (\n        !inVPre &&\n        !vnode.ns &&\n        !(\n          config.ignoredElements.length &&\n          config.ignoredElements.some(function (ignore) {\n            return isRegExp(ignore)\n              ? ignore.test(vnode.tag)\n              : ignore === vnode.tag\n          })\n        ) &&\n        config.isUnknownElement(vnode.tag)\n      )\n    }\n\n    var creatingElmInVPre = 0;\n\n    function createElm (\n      vnode,\n      insertedVnodeQueue,\n      parentElm,\n      refElm,\n      nested,\n      ownerArray,\n      index\n    ) {\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // This vnode was used in a previous render!\n        // now it's used as a new node, overwriting its elm would cause\n        // potential patch errors down the road when it's used as an insertion\n        // reference node. Instead, we clone the node on-demand before creating\n        // associated DOM element for it.\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      vnode.isRootInsert = !nested; // for transition enter check\n      if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {\n        return\n      }\n\n      var data = vnode.data;\n      var children = vnode.children;\n      var tag = vnode.tag;\n      if (isDef(tag)) {\n        {\n          if (data && data.pre) {\n            creatingElmInVPre++;\n          }\n          if (isUnknownElement$$1(vnode, creatingElmInVPre)) {\n            warn(\n              'Unknown custom element: <' + tag + '> - did you ' +\n              'register the component correctly? For recursive components, ' +\n              'make sure to provide the \"name\" option.',\n              vnode.context\n            );\n          }\n        }\n\n        vnode.elm = vnode.ns\n          ? nodeOps.createElementNS(vnode.ns, tag)\n          : nodeOps.createElement(tag, vnode);\n        setScope(vnode);\n\n        /* istanbul ignore if */\n        {\n          createChildren(vnode, children, insertedVnodeQueue);\n          if (isDef(data)) {\n            invokeCreateHooks(vnode, insertedVnodeQueue);\n          }\n          insert(parentElm, vnode.elm, refElm);\n        }\n\n        if (data && data.pre) {\n          creatingElmInVPre--;\n        }\n      } else if (isTrue(vnode.isComment)) {\n        vnode.elm = nodeOps.createComment(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      } else {\n        vnode.elm = nodeOps.createTextNode(vnode.text);\n        insert(parentElm, vnode.elm, refElm);\n      }\n    }\n\n    function createComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i = vnode.data;\n      if (isDef(i)) {\n        var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;\n        if (isDef(i = i.hook) && isDef(i = i.init)) {\n          i(vnode, false /* hydrating */);\n        }\n        // after calling the init hook, if the vnode is a child component\n        // it should've created a child instance and mounted it. the child\n        // component also has set the placeholder vnode's elm.\n        // in that case we can just return the element and be done.\n        if (isDef(vnode.componentInstance)) {\n          initComponent(vnode, insertedVnodeQueue);\n          insert(parentElm, vnode.elm, refElm);\n          if (isTrue(isReactivated)) {\n            reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);\n          }\n          return true\n        }\n      }\n    }\n\n    function initComponent (vnode, insertedVnodeQueue) {\n      if (isDef(vnode.data.pendingInsert)) {\n        insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);\n        vnode.data.pendingInsert = null;\n      }\n      vnode.elm = vnode.componentInstance.$el;\n      if (isPatchable(vnode)) {\n        invokeCreateHooks(vnode, insertedVnodeQueue);\n        setScope(vnode);\n      } else {\n        // empty component root.\n        // skip all element-related modules except for ref (#3455)\n        registerRef(vnode);\n        // make sure to invoke the insert hook\n        insertedVnodeQueue.push(vnode);\n      }\n    }\n\n    function reactivateComponent (vnode, insertedVnodeQueue, parentElm, refElm) {\n      var i;\n      // hack for #4339: a reactivated component with inner transition\n      // does not trigger because the inner node's created hooks are not called\n      // again. It's not ideal to involve module-specific logic in here but\n      // there doesn't seem to be a better way to do it.\n      var innerNode = vnode;\n      while (innerNode.componentInstance) {\n        innerNode = innerNode.componentInstance._vnode;\n        if (isDef(i = innerNode.data) && isDef(i = i.transition)) {\n          for (i = 0; i < cbs.activate.length; ++i) {\n            cbs.activate[i](emptyNode, innerNode);\n          }\n          insertedVnodeQueue.push(innerNode);\n          break\n        }\n      }\n      // unlike a newly created component,\n      // a reactivated keep-alive component doesn't insert itself\n      insert(parentElm, vnode.elm, refElm);\n    }\n\n    function insert (parent, elm, ref$$1) {\n      if (isDef(parent)) {\n        if (isDef(ref$$1)) {\n          if (nodeOps.parentNode(ref$$1) === parent) {\n            nodeOps.insertBefore(parent, elm, ref$$1);\n          }\n        } else {\n          nodeOps.appendChild(parent, elm);\n        }\n      }\n    }\n\n    function createChildren (vnode, children, insertedVnodeQueue) {\n      if (Array.isArray(children)) {\n        {\n          checkDuplicateKeys(children);\n        }\n        for (var i = 0; i < children.length; ++i) {\n          createElm(children[i], insertedVnodeQueue, vnode.elm, null, true, children, i);\n        }\n      } else if (isPrimitive(vnode.text)) {\n        nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(String(vnode.text)));\n      }\n    }\n\n    function isPatchable (vnode) {\n      while (vnode.componentInstance) {\n        vnode = vnode.componentInstance._vnode;\n      }\n      return isDef(vnode.tag)\n    }\n\n    function invokeCreateHooks (vnode, insertedVnodeQueue) {\n      for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n        cbs.create[i$1](emptyNode, vnode);\n      }\n      i = vnode.data.hook; // Reuse variable\n      if (isDef(i)) {\n        if (isDef(i.create)) { i.create(emptyNode, vnode); }\n        if (isDef(i.insert)) { insertedVnodeQueue.push(vnode); }\n      }\n    }\n\n    // set scope id attribute for scoped CSS.\n    // this is implemented as a special case to avoid the overhead\n    // of going through the normal attribute patching process.\n    function setScope (vnode) {\n      var i;\n      if (isDef(i = vnode.fnScopeId)) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      } else {\n        var ancestor = vnode;\n        while (ancestor) {\n          if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {\n            nodeOps.setStyleScope(vnode.elm, i);\n          }\n          ancestor = ancestor.parent;\n        }\n      }\n      // for slot content they should also get the scopeId from the host instance.\n      if (isDef(i = activeInstance) &&\n        i !== vnode.context &&\n        i !== vnode.fnContext &&\n        isDef(i = i.$options._scopeId)\n      ) {\n        nodeOps.setStyleScope(vnode.elm, i);\n      }\n    }\n\n    function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm, false, vnodes, startIdx);\n      }\n    }\n\n    function invokeDestroyHook (vnode) {\n      var i, j;\n      var data = vnode.data;\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.destroy)) { i(vnode); }\n        for (i = 0; i < cbs.destroy.length; ++i) { cbs.destroy[i](vnode); }\n      }\n      if (isDef(i = vnode.children)) {\n        for (j = 0; j < vnode.children.length; ++j) {\n          invokeDestroyHook(vnode.children[j]);\n        }\n      }\n    }\n\n    function removeVnodes (parentElm, vnodes, startIdx, endIdx) {\n      for (; startIdx <= endIdx; ++startIdx) {\n        var ch = vnodes[startIdx];\n        if (isDef(ch)) {\n          if (isDef(ch.tag)) {\n            removeAndInvokeRemoveHook(ch);\n            invokeDestroyHook(ch);\n          } else { // Text node\n            removeNode(ch.elm);\n          }\n        }\n      }\n    }\n\n    function removeAndInvokeRemoveHook (vnode, rm) {\n      if (isDef(rm) || isDef(vnode.data)) {\n        var i;\n        var listeners = cbs.remove.length + 1;\n        if (isDef(rm)) {\n          // we have a recursively passed down rm callback\n          // increase the listeners count\n          rm.listeners += listeners;\n        } else {\n          // directly removing\n          rm = createRmCb(vnode.elm, listeners);\n        }\n        // recursively invoke hooks on child component root node\n        if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {\n          removeAndInvokeRemoveHook(i, rm);\n        }\n        for (i = 0; i < cbs.remove.length; ++i) {\n          cbs.remove[i](vnode, rm);\n        }\n        if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {\n          i(vnode, rm);\n        } else {\n          rm();\n        }\n      } else {\n        removeNode(vnode.elm);\n      }\n    }\n\n    function updateChildren (parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {\n      var oldStartIdx = 0;\n      var newStartIdx = 0;\n      var oldEndIdx = oldCh.length - 1;\n      var oldStartVnode = oldCh[0];\n      var oldEndVnode = oldCh[oldEndIdx];\n      var newEndIdx = newCh.length - 1;\n      var newStartVnode = newCh[0];\n      var newEndVnode = newCh[newEndIdx];\n      var oldKeyToIdx, idxInOld, vnodeToMove, refElm;\n\n      // removeOnly is a special flag used only by <transition-group>\n      // to ensure removed elements stay in correct relative positions\n      // during leaving transitions\n      var canMove = !removeOnly;\n\n      {\n        checkDuplicateKeys(newCh);\n      }\n\n      while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n        if (isUndef(oldStartVnode)) {\n          oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left\n        } else if (isUndef(oldEndVnode)) {\n          oldEndVnode = oldCh[--oldEndIdx];\n        } else if (sameVnode(oldStartVnode, newStartVnode)) {\n          patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          oldStartVnode = oldCh[++oldStartIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else if (sameVnode(oldEndVnode, newEndVnode)) {\n          patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldStartVnode, newEndVnode)) { // Vnode moved right\n          patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue, newCh, newEndIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));\n          oldStartVnode = oldCh[++oldStartIdx];\n          newEndVnode = newCh[--newEndIdx];\n        } else if (sameVnode(oldEndVnode, newStartVnode)) { // Vnode moved left\n          patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n          canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);\n          oldEndVnode = oldCh[--oldEndIdx];\n          newStartVnode = newCh[++newStartIdx];\n        } else {\n          if (isUndef(oldKeyToIdx)) { oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); }\n          idxInOld = isDef(newStartVnode.key)\n            ? oldKeyToIdx[newStartVnode.key]\n            : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);\n          if (isUndef(idxInOld)) { // New element\n            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n          } else {\n            vnodeToMove = oldCh[idxInOld];\n            if (sameVnode(vnodeToMove, newStartVnode)) {\n              patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue, newCh, newStartIdx);\n              oldCh[idxInOld] = undefined;\n              canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);\n            } else {\n              // same key but different element. treat as new element\n              createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm, false, newCh, newStartIdx);\n            }\n          }\n          newStartVnode = newCh[++newStartIdx];\n        }\n      }\n      if (oldStartIdx > oldEndIdx) {\n        refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;\n        addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);\n      } else if (newStartIdx > newEndIdx) {\n        removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);\n      }\n    }\n\n    function checkDuplicateKeys (children) {\n      var seenKeys = {};\n      for (var i = 0; i < children.length; i++) {\n        var vnode = children[i];\n        var key = vnode.key;\n        if (isDef(key)) {\n          if (seenKeys[key]) {\n            warn(\n              (\"Duplicate keys detected: '\" + key + \"'. This may cause an update error.\"),\n              vnode.context\n            );\n          } else {\n            seenKeys[key] = true;\n          }\n        }\n      }\n    }\n\n    function findIdxInOld (node, oldCh, start, end) {\n      for (var i = start; i < end; i++) {\n        var c = oldCh[i];\n        if (isDef(c) && sameVnode(node, c)) { return i }\n      }\n    }\n\n    function patchVnode (\n      oldVnode,\n      vnode,\n      insertedVnodeQueue,\n      ownerArray,\n      index,\n      removeOnly\n    ) {\n      if (oldVnode === vnode) {\n        return\n      }\n\n      if (isDef(vnode.elm) && isDef(ownerArray)) {\n        // clone reused vnode\n        vnode = ownerArray[index] = cloneVNode(vnode);\n      }\n\n      var elm = vnode.elm = oldVnode.elm;\n\n      if (isTrue(oldVnode.isAsyncPlaceholder)) {\n        if (isDef(vnode.asyncFactory.resolved)) {\n          hydrate(oldVnode.elm, vnode, insertedVnodeQueue);\n        } else {\n          vnode.isAsyncPlaceholder = true;\n        }\n        return\n      }\n\n      // reuse element for static trees.\n      // note we only do this if the vnode is cloned -\n      // if the new node is not cloned it means the render functions have been\n      // reset by the hot-reload-api and we need to do a proper re-render.\n      if (isTrue(vnode.isStatic) &&\n        isTrue(oldVnode.isStatic) &&\n        vnode.key === oldVnode.key &&\n        (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))\n      ) {\n        vnode.componentInstance = oldVnode.componentInstance;\n        return\n      }\n\n      var i;\n      var data = vnode.data;\n      if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {\n        i(oldVnode, vnode);\n      }\n\n      var oldCh = oldVnode.children;\n      var ch = vnode.children;\n      if (isDef(data) && isPatchable(vnode)) {\n        for (i = 0; i < cbs.update.length; ++i) { cbs.update[i](oldVnode, vnode); }\n        if (isDef(i = data.hook) && isDef(i = i.update)) { i(oldVnode, vnode); }\n      }\n      if (isUndef(vnode.text)) {\n        if (isDef(oldCh) && isDef(ch)) {\n          if (oldCh !== ch) { updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly); }\n        } else if (isDef(ch)) {\n          {\n            checkDuplicateKeys(ch);\n          }\n          if (isDef(oldVnode.text)) { nodeOps.setTextContent(elm, ''); }\n          addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);\n        } else if (isDef(oldCh)) {\n          removeVnodes(elm, oldCh, 0, oldCh.length - 1);\n        } else if (isDef(oldVnode.text)) {\n          nodeOps.setTextContent(elm, '');\n        }\n      } else if (oldVnode.text !== vnode.text) {\n        nodeOps.setTextContent(elm, vnode.text);\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.postpatch)) { i(oldVnode, vnode); }\n      }\n    }\n\n    function invokeInsertHook (vnode, queue, initial) {\n      // delay insert hooks for component root nodes, invoke them after the\n      // element is really inserted\n      if (isTrue(initial) && isDef(vnode.parent)) {\n        vnode.parent.data.pendingInsert = queue;\n      } else {\n        for (var i = 0; i < queue.length; ++i) {\n          queue[i].data.hook.insert(queue[i]);\n        }\n      }\n    }\n\n    var hydrationBailed = false;\n    // list of modules that can skip create hook during hydration because they\n    // are already rendered on the client or has no need for initialization\n    // Note: style is excluded because it relies on initial clone for future\n    // deep updates (#7063).\n    var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');\n\n    // Note: this is a browser-only function so we can assume elms are DOM nodes.\n    function hydrate (elm, vnode, insertedVnodeQueue, inVPre) {\n      var i;\n      var tag = vnode.tag;\n      var data = vnode.data;\n      var children = vnode.children;\n      inVPre = inVPre || (data && data.pre);\n      vnode.elm = elm;\n\n      if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {\n        vnode.isAsyncPlaceholder = true;\n        return true\n      }\n      // assert node match\n      {\n        if (!assertNodeMatch(elm, vnode, inVPre)) {\n          return false\n        }\n      }\n      if (isDef(data)) {\n        if (isDef(i = data.hook) && isDef(i = i.init)) { i(vnode, true /* hydrating */); }\n        if (isDef(i = vnode.componentInstance)) {\n          // child component. it should have hydrated its own tree.\n          initComponent(vnode, insertedVnodeQueue);\n          return true\n        }\n      }\n      if (isDef(tag)) {\n        if (isDef(children)) {\n          // empty element, allow client to pick up and populate children\n          if (!elm.hasChildNodes()) {\n            createChildren(vnode, children, insertedVnodeQueue);\n          } else {\n            // v-html and domProps: innerHTML\n            if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {\n              if (i !== elm.innerHTML) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('server innerHTML: ', i);\n                  console.warn('client innerHTML: ', elm.innerHTML);\n                }\n                return false\n              }\n            } else {\n              // iterate and compare children lists\n              var childrenMatch = true;\n              var childNode = elm.firstChild;\n              for (var i$1 = 0; i$1 < children.length; i$1++) {\n                if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {\n                  childrenMatch = false;\n                  break\n                }\n                childNode = childNode.nextSibling;\n              }\n              // if childNode is not null, it means the actual childNodes list is\n              // longer than the virtual children list.\n              if (!childrenMatch || childNode) {\n                /* istanbul ignore if */\n                if (typeof console !== 'undefined' &&\n                  !hydrationBailed\n                ) {\n                  hydrationBailed = true;\n                  console.warn('Parent: ', elm);\n                  console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);\n                }\n                return false\n              }\n            }\n          }\n        }\n        if (isDef(data)) {\n          var fullInvoke = false;\n          for (var key in data) {\n            if (!isRenderedModule(key)) {\n              fullInvoke = true;\n              invokeCreateHooks(vnode, insertedVnodeQueue);\n              break\n            }\n          }\n          if (!fullInvoke && data['class']) {\n            // ensure collecting deps for deep class bindings for future updates\n            traverse(data['class']);\n          }\n        }\n      } else if (elm.data !== vnode.text) {\n        elm.data = vnode.text;\n      }\n      return true\n    }\n\n    function assertNodeMatch (node, vnode, inVPre) {\n      if (isDef(vnode.tag)) {\n        return vnode.tag.indexOf('vue-component') === 0 || (\n          !isUnknownElement$$1(vnode, inVPre) &&\n          vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase())\n        )\n      } else {\n        return node.nodeType === (vnode.isComment ? 8 : 3)\n      }\n    }\n\n    return function patch (oldVnode, vnode, hydrating, removeOnly) {\n      if (isUndef(vnode)) {\n        if (isDef(oldVnode)) { invokeDestroyHook(oldVnode); }\n        return\n      }\n\n      var isInitialPatch = false;\n      var insertedVnodeQueue = [];\n\n      if (isUndef(oldVnode)) {\n        // empty mount (likely as component), create new root element\n        isInitialPatch = true;\n        createElm(vnode, insertedVnodeQueue);\n      } else {\n        var isRealElement = isDef(oldVnode.nodeType);\n        if (!isRealElement && sameVnode(oldVnode, vnode)) {\n          // patch existing root node\n          patchVnode(oldVnode, vnode, insertedVnodeQueue, null, null, removeOnly);\n        } else {\n          if (isRealElement) {\n            // mounting to a real element\n            // check if this is server-rendered content and if we can perform\n            // a successful hydration.\n            if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {\n              oldVnode.removeAttribute(SSR_ATTR);\n              hydrating = true;\n            }\n            if (isTrue(hydrating)) {\n              if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {\n                invokeInsertHook(vnode, insertedVnodeQueue, true);\n                return oldVnode\n              } else {\n                warn(\n                  'The client-side rendered virtual DOM tree is not matching ' +\n                  'server-rendered content. This is likely caused by incorrect ' +\n                  'HTML markup, for example nesting block-level elements inside ' +\n                  '<p>, or missing <tbody>. Bailing hydration and performing ' +\n                  'full client-side render.'\n                );\n              }\n            }\n            // either not server-rendered, or hydration failed.\n            // create an empty node and replace it\n            oldVnode = emptyNodeAt(oldVnode);\n          }\n\n          // replacing existing element\n          var oldElm = oldVnode.elm;\n          var parentElm = nodeOps.parentNode(oldElm);\n\n          // create new node\n          createElm(\n            vnode,\n            insertedVnodeQueue,\n            // extremely rare edge case: do not insert if old element is in a\n            // leaving transition. Only happens when combining transition +\n            // keep-alive + HOCs. (#4590)\n            oldElm._leaveCb ? null : parentElm,\n            nodeOps.nextSibling(oldElm)\n          );\n\n          // update parent placeholder node element, recursively\n          if (isDef(vnode.parent)) {\n            var ancestor = vnode.parent;\n            var patchable = isPatchable(vnode);\n            while (ancestor) {\n              for (var i = 0; i < cbs.destroy.length; ++i) {\n                cbs.destroy[i](ancestor);\n              }\n              ancestor.elm = vnode.elm;\n              if (patchable) {\n                for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {\n                  cbs.create[i$1](emptyNode, ancestor);\n                }\n                // #6513\n                // invoke insert hooks that may have been merged by create hooks.\n                // e.g. for directives that uses the \"inserted\" hook.\n                var insert = ancestor.data.hook.insert;\n                if (insert.merged) {\n                  // start at index 1 to avoid re-invoking component mounted hook\n                  for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {\n                    insert.fns[i$2]();\n                  }\n                }\n              } else {\n                registerRef(ancestor);\n              }\n              ancestor = ancestor.parent;\n            }\n          }\n\n          // destroy old node\n          if (isDef(parentElm)) {\n            removeVnodes(parentElm, [oldVnode], 0, 0);\n          } else if (isDef(oldVnode.tag)) {\n            invokeDestroyHook(oldVnode);\n          }\n        }\n      }\n\n      invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);\n      return vnode.elm\n    }\n  }\n\n  /*  */\n\n  var directives = {\n    create: updateDirectives,\n    update: updateDirectives,\n    destroy: function unbindDirectives (vnode) {\n      updateDirectives(vnode, emptyNode);\n    }\n  };\n\n  function updateDirectives (oldVnode, vnode) {\n    if (oldVnode.data.directives || vnode.data.directives) {\n      _update(oldVnode, vnode);\n    }\n  }\n\n  function _update (oldVnode, vnode) {\n    var isCreate = oldVnode === emptyNode;\n    var isDestroy = vnode === emptyNode;\n    var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);\n    var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);\n\n    var dirsWithInsert = [];\n    var dirsWithPostpatch = [];\n\n    var key, oldDir, dir;\n    for (key in newDirs) {\n      oldDir = oldDirs[key];\n      dir = newDirs[key];\n      if (!oldDir) {\n        // new directive, bind\n        callHook$1(dir, 'bind', vnode, oldVnode);\n        if (dir.def && dir.def.inserted) {\n          dirsWithInsert.push(dir);\n        }\n      } else {\n        // existing directive, update\n        dir.oldValue = oldDir.value;\n        dir.oldArg = oldDir.arg;\n        callHook$1(dir, 'update', vnode, oldVnode);\n        if (dir.def && dir.def.componentUpdated) {\n          dirsWithPostpatch.push(dir);\n        }\n      }\n    }\n\n    if (dirsWithInsert.length) {\n      var callInsert = function () {\n        for (var i = 0; i < dirsWithInsert.length; i++) {\n          callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);\n        }\n      };\n      if (isCreate) {\n        mergeVNodeHook(vnode, 'insert', callInsert);\n      } else {\n        callInsert();\n      }\n    }\n\n    if (dirsWithPostpatch.length) {\n      mergeVNodeHook(vnode, 'postpatch', function () {\n        for (var i = 0; i < dirsWithPostpatch.length; i++) {\n          callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);\n        }\n      });\n    }\n\n    if (!isCreate) {\n      for (key in oldDirs) {\n        if (!newDirs[key]) {\n          // no longer present, unbind\n          callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);\n        }\n      }\n    }\n  }\n\n  var emptyModifiers = Object.create(null);\n\n  function normalizeDirectives$1 (\n    dirs,\n    vm\n  ) {\n    var res = Object.create(null);\n    if (!dirs) {\n      // $flow-disable-line\n      return res\n    }\n    var i, dir;\n    for (i = 0; i < dirs.length; i++) {\n      dir = dirs[i];\n      if (!dir.modifiers) {\n        // $flow-disable-line\n        dir.modifiers = emptyModifiers;\n      }\n      res[getRawDirName(dir)] = dir;\n      dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);\n    }\n    // $flow-disable-line\n    return res\n  }\n\n  function getRawDirName (dir) {\n    return dir.rawName || ((dir.name) + \".\" + (Object.keys(dir.modifiers || {}).join('.')))\n  }\n\n  function callHook$1 (dir, hook, vnode, oldVnode, isDestroy) {\n    var fn = dir.def && dir.def[hook];\n    if (fn) {\n      try {\n        fn(vnode.elm, dir, vnode, oldVnode, isDestroy);\n      } catch (e) {\n        handleError(e, vnode.context, (\"directive \" + (dir.name) + \" \" + hook + \" hook\"));\n      }\n    }\n  }\n\n  var baseModules = [\n    ref,\n    directives\n  ];\n\n  /*  */\n\n  function updateAttrs (oldVnode, vnode) {\n    var opts = vnode.componentOptions;\n    if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {\n      return\n    }\n    if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {\n      return\n    }\n    var key, cur, old;\n    var elm = vnode.elm;\n    var oldAttrs = oldVnode.data.attrs || {};\n    var attrs = vnode.data.attrs || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(attrs.__ob__)) {\n      attrs = vnode.data.attrs = extend({}, attrs);\n    }\n\n    for (key in attrs) {\n      cur = attrs[key];\n      old = oldAttrs[key];\n      if (old !== cur) {\n        setAttr(elm, key, cur);\n      }\n    }\n    // #4391: in IE9, setting type can reset value for input[type=radio]\n    // #6666: IE/Edge forces progress value down to 1 before setting a max\n    /* istanbul ignore if */\n    if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {\n      setAttr(elm, 'value', attrs.value);\n    }\n    for (key in oldAttrs) {\n      if (isUndef(attrs[key])) {\n        if (isXlink(key)) {\n          elm.removeAttributeNS(xlinkNS, getXlinkProp(key));\n        } else if (!isEnumeratedAttr(key)) {\n          elm.removeAttribute(key);\n        }\n      }\n    }\n  }\n\n  function setAttr (el, key, value) {\n    if (el.tagName.indexOf('-') > -1) {\n      baseSetAttr(el, key, value);\n    } else if (isBooleanAttr(key)) {\n      // set attribute for blank value\n      // e.g. <option disabled>Select one</option>\n      if (isFalsyAttrValue(value)) {\n        el.removeAttribute(key);\n      } else {\n        // technically allowfullscreen is a boolean attribute for <iframe>,\n        // but Flash expects a value of \"true\" when used on <embed> tag\n        value = key === 'allowfullscreen' && el.tagName === 'EMBED'\n          ? 'true'\n          : key;\n        el.setAttribute(key, value);\n      }\n    } else if (isEnumeratedAttr(key)) {\n      el.setAttribute(key, convertEnumeratedValue(key, value));\n    } else if (isXlink(key)) {\n      if (isFalsyAttrValue(value)) {\n        el.removeAttributeNS(xlinkNS, getXlinkProp(key));\n      } else {\n        el.setAttributeNS(xlinkNS, key, value);\n      }\n    } else {\n      baseSetAttr(el, key, value);\n    }\n  }\n\n  function baseSetAttr (el, key, value) {\n    if (isFalsyAttrValue(value)) {\n      el.removeAttribute(key);\n    } else {\n      // #7138: IE10 & 11 fires input event when setting placeholder on\n      // <textarea>... block the first input event and remove the blocker\n      // immediately.\n      /* istanbul ignore if */\n      if (\n        isIE && !isIE9 &&\n        el.tagName === 'TEXTAREA' &&\n        key === 'placeholder' && value !== '' && !el.__ieph\n      ) {\n        var blocker = function (e) {\n          e.stopImmediatePropagation();\n          el.removeEventListener('input', blocker);\n        };\n        el.addEventListener('input', blocker);\n        // $flow-disable-line\n        el.__ieph = true; /* IE placeholder patched */\n      }\n      el.setAttribute(key, value);\n    }\n  }\n\n  var attrs = {\n    create: updateAttrs,\n    update: updateAttrs\n  };\n\n  /*  */\n\n  function updateClass (oldVnode, vnode) {\n    var el = vnode.elm;\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n    if (\n      isUndef(data.staticClass) &&\n      isUndef(data.class) && (\n        isUndef(oldData) || (\n          isUndef(oldData.staticClass) &&\n          isUndef(oldData.class)\n        )\n      )\n    ) {\n      return\n    }\n\n    var cls = genClassForVnode(vnode);\n\n    // handle transition classes\n    var transitionClass = el._transitionClasses;\n    if (isDef(transitionClass)) {\n      cls = concat(cls, stringifyClass(transitionClass));\n    }\n\n    // set the class\n    if (cls !== el._prevClass) {\n      el.setAttribute('class', cls);\n      el._prevClass = cls;\n    }\n  }\n\n  var klass = {\n    create: updateClass,\n    update: updateClass\n  };\n\n  /*  */\n\n  var validDivisionCharRE = /[\\w).+\\-_$\\]]/;\n\n  function parseFilters (exp) {\n    var inSingle = false;\n    var inDouble = false;\n    var inTemplateString = false;\n    var inRegex = false;\n    var curly = 0;\n    var square = 0;\n    var paren = 0;\n    var lastFilterIndex = 0;\n    var c, prev, i, expression, filters;\n\n    for (i = 0; i < exp.length; i++) {\n      prev = c;\n      c = exp.charCodeAt(i);\n      if (inSingle) {\n        if (c === 0x27 && prev !== 0x5C) { inSingle = false; }\n      } else if (inDouble) {\n        if (c === 0x22 && prev !== 0x5C) { inDouble = false; }\n      } else if (inTemplateString) {\n        if (c === 0x60 && prev !== 0x5C) { inTemplateString = false; }\n      } else if (inRegex) {\n        if (c === 0x2f && prev !== 0x5C) { inRegex = false; }\n      } else if (\n        c === 0x7C && // pipe\n        exp.charCodeAt(i + 1) !== 0x7C &&\n        exp.charCodeAt(i - 1) !== 0x7C &&\n        !curly && !square && !paren\n      ) {\n        if (expression === undefined) {\n          // first filter, end of expression\n          lastFilterIndex = i + 1;\n          expression = exp.slice(0, i).trim();\n        } else {\n          pushFilter();\n        }\n      } else {\n        switch (c) {\n          case 0x22: inDouble = true; break         // \"\n          case 0x27: inSingle = true; break         // '\n          case 0x60: inTemplateString = true; break // `\n          case 0x28: paren++; break                 // (\n          case 0x29: paren--; break                 // )\n          case 0x5B: square++; break                // [\n          case 0x5D: square--; break                // ]\n          case 0x7B: curly++; break                 // {\n          case 0x7D: curly--; break                 // }\n        }\n        if (c === 0x2f) { // /\n          var j = i - 1;\n          var p = (void 0);\n          // find first non-whitespace prev char\n          for (; j >= 0; j--) {\n            p = exp.charAt(j);\n            if (p !== ' ') { break }\n          }\n          if (!p || !validDivisionCharRE.test(p)) {\n            inRegex = true;\n          }\n        }\n      }\n    }\n\n    if (expression === undefined) {\n      expression = exp.slice(0, i).trim();\n    } else if (lastFilterIndex !== 0) {\n      pushFilter();\n    }\n\n    function pushFilter () {\n      (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());\n      lastFilterIndex = i + 1;\n    }\n\n    if (filters) {\n      for (i = 0; i < filters.length; i++) {\n        expression = wrapFilter(expression, filters[i]);\n      }\n    }\n\n    return expression\n  }\n\n  function wrapFilter (exp, filter) {\n    var i = filter.indexOf('(');\n    if (i < 0) {\n      // _f: resolveFilter\n      return (\"_f(\\\"\" + filter + \"\\\")(\" + exp + \")\")\n    } else {\n      var name = filter.slice(0, i);\n      var args = filter.slice(i + 1);\n      return (\"_f(\\\"\" + name + \"\\\")(\" + exp + (args !== ')' ? ',' + args : args))\n    }\n  }\n\n  /*  */\n\n\n\n  /* eslint-disable no-unused-vars */\n  function baseWarn (msg, range) {\n    console.error((\"[Vue compiler]: \" + msg));\n  }\n  /* eslint-enable no-unused-vars */\n\n  function pluckModuleFunction (\n    modules,\n    key\n  ) {\n    return modules\n      ? modules.map(function (m) { return m[key]; }).filter(function (_) { return _; })\n      : []\n  }\n\n  function addProp (el, name, value, range, dynamic) {\n    (el.props || (el.props = [])).push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  function addAttr (el, name, value, range, dynamic) {\n    var attrs = dynamic\n      ? (el.dynamicAttrs || (el.dynamicAttrs = []))\n      : (el.attrs || (el.attrs = []));\n    attrs.push(rangeSetItem({ name: name, value: value, dynamic: dynamic }, range));\n    el.plain = false;\n  }\n\n  // add a raw attr (use this in preTransforms)\n  function addRawAttr (el, name, value, range) {\n    el.attrsMap[name] = value;\n    el.attrsList.push(rangeSetItem({ name: name, value: value }, range));\n  }\n\n  function addDirective (\n    el,\n    name,\n    rawName,\n    value,\n    arg,\n    isDynamicArg,\n    modifiers,\n    range\n  ) {\n    (el.directives || (el.directives = [])).push(rangeSetItem({\n      name: name,\n      rawName: rawName,\n      value: value,\n      arg: arg,\n      isDynamicArg: isDynamicArg,\n      modifiers: modifiers\n    }, range));\n    el.plain = false;\n  }\n\n  function prependModifierMarker (symbol, name, dynamic) {\n    return dynamic\n      ? (\"_p(\" + name + \",\\\"\" + symbol + \"\\\")\")\n      : symbol + name // mark the event as captured\n  }\n\n  function addHandler (\n    el,\n    name,\n    value,\n    modifiers,\n    important,\n    warn,\n    range,\n    dynamic\n  ) {\n    modifiers = modifiers || emptyObject;\n    // warn prevent and passive modifier\n    /* istanbul ignore if */\n    if (\n      warn &&\n      modifiers.prevent && modifiers.passive\n    ) {\n      warn(\n        'passive and prevent can\\'t be used together. ' +\n        'Passive handler can\\'t prevent default event.',\n        range\n      );\n    }\n\n    // normalize click.right and click.middle since they don't actually fire\n    // this is technically browser-specific, but at least for now browsers are\n    // the only target envs that have right/middle clicks.\n    if (modifiers.right) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'contextmenu':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'contextmenu';\n        delete modifiers.right;\n      }\n    } else if (modifiers.middle) {\n      if (dynamic) {\n        name = \"(\" + name + \")==='click'?'mouseup':(\" + name + \")\";\n      } else if (name === 'click') {\n        name = 'mouseup';\n      }\n    }\n\n    // check capture modifier\n    if (modifiers.capture) {\n      delete modifiers.capture;\n      name = prependModifierMarker('!', name, dynamic);\n    }\n    if (modifiers.once) {\n      delete modifiers.once;\n      name = prependModifierMarker('~', name, dynamic);\n    }\n    /* istanbul ignore if */\n    if (modifiers.passive) {\n      delete modifiers.passive;\n      name = prependModifierMarker('&', name, dynamic);\n    }\n\n    var events;\n    if (modifiers.native) {\n      delete modifiers.native;\n      events = el.nativeEvents || (el.nativeEvents = {});\n    } else {\n      events = el.events || (el.events = {});\n    }\n\n    var newHandler = rangeSetItem({ value: value.trim(), dynamic: dynamic }, range);\n    if (modifiers !== emptyObject) {\n      newHandler.modifiers = modifiers;\n    }\n\n    var handlers = events[name];\n    /* istanbul ignore if */\n    if (Array.isArray(handlers)) {\n      important ? handlers.unshift(newHandler) : handlers.push(newHandler);\n    } else if (handlers) {\n      events[name] = important ? [newHandler, handlers] : [handlers, newHandler];\n    } else {\n      events[name] = newHandler;\n    }\n\n    el.plain = false;\n  }\n\n  function getRawBindingAttr (\n    el,\n    name\n  ) {\n    return el.rawAttrsMap[':' + name] ||\n      el.rawAttrsMap['v-bind:' + name] ||\n      el.rawAttrsMap[name]\n  }\n\n  function getBindingAttr (\n    el,\n    name,\n    getStatic\n  ) {\n    var dynamicValue =\n      getAndRemoveAttr(el, ':' + name) ||\n      getAndRemoveAttr(el, 'v-bind:' + name);\n    if (dynamicValue != null) {\n      return parseFilters(dynamicValue)\n    } else if (getStatic !== false) {\n      var staticValue = getAndRemoveAttr(el, name);\n      if (staticValue != null) {\n        return JSON.stringify(staticValue)\n      }\n    }\n  }\n\n  // note: this only removes the attr from the Array (attrsList) so that it\n  // doesn't get processed by processAttrs.\n  // By default it does NOT remove it from the map (attrsMap) because the map is\n  // needed during codegen.\n  function getAndRemoveAttr (\n    el,\n    name,\n    removeFromMap\n  ) {\n    var val;\n    if ((val = el.attrsMap[name]) != null) {\n      var list = el.attrsList;\n      for (var i = 0, l = list.length; i < l; i++) {\n        if (list[i].name === name) {\n          list.splice(i, 1);\n          break\n        }\n      }\n    }\n    if (removeFromMap) {\n      delete el.attrsMap[name];\n    }\n    return val\n  }\n\n  function getAndRemoveAttrByRegex (\n    el,\n    name\n  ) {\n    var list = el.attrsList;\n    for (var i = 0, l = list.length; i < l; i++) {\n      var attr = list[i];\n      if (name.test(attr.name)) {\n        list.splice(i, 1);\n        return attr\n      }\n    }\n  }\n\n  function rangeSetItem (\n    item,\n    range\n  ) {\n    if (range) {\n      if (range.start != null) {\n        item.start = range.start;\n      }\n      if (range.end != null) {\n        item.end = range.end;\n      }\n    }\n    return item\n  }\n\n  /*  */\n\n  /**\n   * Cross-platform code generation for component v-model\n   */\n  function genComponentModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var ref = modifiers || {};\n    var number = ref.number;\n    var trim = ref.trim;\n\n    var baseValueExpression = '$$v';\n    var valueExpression = baseValueExpression;\n    if (trim) {\n      valueExpression =\n        \"(typeof \" + baseValueExpression + \" === 'string'\" +\n        \"? \" + baseValueExpression + \".trim()\" +\n        \": \" + baseValueExpression + \")\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n    var assignment = genAssignmentCode(value, valueExpression);\n\n    el.model = {\n      value: (\"(\" + value + \")\"),\n      expression: JSON.stringify(value),\n      callback: (\"function (\" + baseValueExpression + \") {\" + assignment + \"}\")\n    };\n  }\n\n  /**\n   * Cross-platform codegen helper for generating v-model value assignment code.\n   */\n  function genAssignmentCode (\n    value,\n    assignment\n  ) {\n    var res = parseModel(value);\n    if (res.key === null) {\n      return (value + \"=\" + assignment)\n    } else {\n      return (\"$set(\" + (res.exp) + \", \" + (res.key) + \", \" + assignment + \")\")\n    }\n  }\n\n  /**\n   * Parse a v-model expression into a base path and a final key segment.\n   * Handles both dot-path and possible square brackets.\n   *\n   * Possible cases:\n   *\n   * - test\n   * - test[key]\n   * - test[test1[key]]\n   * - test[\"a\"][key]\n   * - xxx.test[a[a].test1[key]]\n   * - test.xxx.a[\"asa\"][test1[key]]\n   *\n   */\n\n  var len, str, chr, index$1, expressionPos, expressionEndPos;\n\n\n\n  function parseModel (val) {\n    // Fix https://github.com/vuejs/vue/pull/7730\n    // allow v-model=\"obj.val \" (trailing whitespace)\n    val = val.trim();\n    len = val.length;\n\n    if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {\n      index$1 = val.lastIndexOf('.');\n      if (index$1 > -1) {\n        return {\n          exp: val.slice(0, index$1),\n          key: '\"' + val.slice(index$1 + 1) + '\"'\n        }\n      } else {\n        return {\n          exp: val,\n          key: null\n        }\n      }\n    }\n\n    str = val;\n    index$1 = expressionPos = expressionEndPos = 0;\n\n    while (!eof()) {\n      chr = next();\n      /* istanbul ignore if */\n      if (isStringStart(chr)) {\n        parseString(chr);\n      } else if (chr === 0x5B) {\n        parseBracket(chr);\n      }\n    }\n\n    return {\n      exp: val.slice(0, expressionPos),\n      key: val.slice(expressionPos + 1, expressionEndPos)\n    }\n  }\n\n  function next () {\n    return str.charCodeAt(++index$1)\n  }\n\n  function eof () {\n    return index$1 >= len\n  }\n\n  function isStringStart (chr) {\n    return chr === 0x22 || chr === 0x27\n  }\n\n  function parseBracket (chr) {\n    var inBracket = 1;\n    expressionPos = index$1;\n    while (!eof()) {\n      chr = next();\n      if (isStringStart(chr)) {\n        parseString(chr);\n        continue\n      }\n      if (chr === 0x5B) { inBracket++; }\n      if (chr === 0x5D) { inBracket--; }\n      if (inBracket === 0) {\n        expressionEndPos = index$1;\n        break\n      }\n    }\n  }\n\n  function parseString (chr) {\n    var stringQuote = chr;\n    while (!eof()) {\n      chr = next();\n      if (chr === stringQuote) {\n        break\n      }\n    }\n  }\n\n  /*  */\n\n  var warn$1;\n\n  // in some cases, the event used has to be determined at runtime\n  // so we used some reserved tokens during compile.\n  var RANGE_TOKEN = '__r';\n  var CHECKBOX_RADIO_TOKEN = '__c';\n\n  function model (\n    el,\n    dir,\n    _warn\n  ) {\n    warn$1 = _warn;\n    var value = dir.value;\n    var modifiers = dir.modifiers;\n    var tag = el.tag;\n    var type = el.attrsMap.type;\n\n    {\n      // inputs with type=\"file\" are read only and setting the input's\n      // value will throw an error.\n      if (tag === 'input' && type === 'file') {\n        warn$1(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\" type=\\\"file\\\">:\\n\" +\n          \"File inputs are read only. Use a v-on:change listener instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n    }\n\n    if (el.component) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else if (tag === 'select') {\n      genSelect(el, value, modifiers);\n    } else if (tag === 'input' && type === 'checkbox') {\n      genCheckboxModel(el, value, modifiers);\n    } else if (tag === 'input' && type === 'radio') {\n      genRadioModel(el, value, modifiers);\n    } else if (tag === 'input' || tag === 'textarea') {\n      genDefaultModel(el, value, modifiers);\n    } else if (!config.isReservedTag(tag)) {\n      genComponentModel(el, value, modifiers);\n      // component v-model doesn't need extra runtime\n      return false\n    } else {\n      warn$1(\n        \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n        \"v-model is not supported on this element type. \" +\n        'If you are working with contenteditable, it\\'s recommended to ' +\n        'wrap a library dedicated for that purpose inside a custom component.',\n        el.rawAttrsMap['v-model']\n      );\n    }\n\n    // ensure runtime directive metadata\n    return true\n  }\n\n  function genCheckboxModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';\n    var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';\n    addProp(el, 'checked',\n      \"Array.isArray(\" + value + \")\" +\n      \"?_i(\" + value + \",\" + valueBinding + \")>-1\" + (\n        trueValueBinding === 'true'\n          ? (\":(\" + value + \")\")\n          : (\":_q(\" + value + \",\" + trueValueBinding + \")\")\n      )\n    );\n    addHandler(el, 'change',\n      \"var $$a=\" + value + \",\" +\n          '$$el=$event.target,' +\n          \"$$c=$$el.checked?(\" + trueValueBinding + \"):(\" + falseValueBinding + \");\" +\n      'if(Array.isArray($$a)){' +\n        \"var $$v=\" + (number ? '_n(' + valueBinding + ')' : valueBinding) + \",\" +\n            '$$i=_i($$a,$$v);' +\n        \"if($$el.checked){$$i<0&&(\" + (genAssignmentCode(value, '$$a.concat([$$v])')) + \")}\" +\n        \"else{$$i>-1&&(\" + (genAssignmentCode(value, '$$a.slice(0,$$i).concat($$a.slice($$i+1))')) + \")}\" +\n      \"}else{\" + (genAssignmentCode(value, '$$c')) + \"}\",\n      null, true\n    );\n  }\n\n  function genRadioModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var valueBinding = getBindingAttr(el, 'value') || 'null';\n    valueBinding = number ? (\"_n(\" + valueBinding + \")\") : valueBinding;\n    addProp(el, 'checked', (\"_q(\" + value + \",\" + valueBinding + \")\"));\n    addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);\n  }\n\n  function genSelect (\n    el,\n    value,\n    modifiers\n  ) {\n    var number = modifiers && modifiers.number;\n    var selectedVal = \"Array.prototype.filter\" +\n      \".call($event.target.options,function(o){return o.selected})\" +\n      \".map(function(o){var val = \\\"_value\\\" in o ? o._value : o.value;\" +\n      \"return \" + (number ? '_n(val)' : 'val') + \"})\";\n\n    var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';\n    var code = \"var $$selectedVal = \" + selectedVal + \";\";\n    code = code + \" \" + (genAssignmentCode(value, assignment));\n    addHandler(el, 'change', code, null, true);\n  }\n\n  function genDefaultModel (\n    el,\n    value,\n    modifiers\n  ) {\n    var type = el.attrsMap.type;\n\n    // warn if v-bind:value conflicts with v-model\n    // except for inputs with v-bind:type\n    {\n      var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];\n      var typeBinding = el.attrsMap['v-bind:type'] || el.attrsMap[':type'];\n      if (value$1 && !typeBinding) {\n        var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';\n        warn$1(\n          binding + \"=\\\"\" + value$1 + \"\\\" conflicts with v-model on the same element \" +\n          'because the latter already expands to a value binding internally',\n          el.rawAttrsMap[binding]\n        );\n      }\n    }\n\n    var ref = modifiers || {};\n    var lazy = ref.lazy;\n    var number = ref.number;\n    var trim = ref.trim;\n    var needCompositionGuard = !lazy && type !== 'range';\n    var event = lazy\n      ? 'change'\n      : type === 'range'\n        ? RANGE_TOKEN\n        : 'input';\n\n    var valueExpression = '$event.target.value';\n    if (trim) {\n      valueExpression = \"$event.target.value.trim()\";\n    }\n    if (number) {\n      valueExpression = \"_n(\" + valueExpression + \")\";\n    }\n\n    var code = genAssignmentCode(value, valueExpression);\n    if (needCompositionGuard) {\n      code = \"if($event.target.composing)return;\" + code;\n    }\n\n    addProp(el, 'value', (\"(\" + value + \")\"));\n    addHandler(el, event, code, null, true);\n    if (trim || number) {\n      addHandler(el, 'blur', '$forceUpdate()');\n    }\n  }\n\n  /*  */\n\n  // normalize v-model event tokens that can only be determined at runtime.\n  // it's important to place the event as the first in the array because\n  // the whole point is ensuring the v-model callback gets called before\n  // user-attached handlers.\n  function normalizeEvents (on) {\n    /* istanbul ignore if */\n    if (isDef(on[RANGE_TOKEN])) {\n      // IE input[type=range] only supports `change` event\n      var event = isIE ? 'change' : 'input';\n      on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);\n      delete on[RANGE_TOKEN];\n    }\n    // This was originally intended to fix #4521 but no longer necessary\n    // after 2.5. Keeping it for backwards compat with generated code from < 2.4\n    /* istanbul ignore if */\n    if (isDef(on[CHECKBOX_RADIO_TOKEN])) {\n      on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);\n      delete on[CHECKBOX_RADIO_TOKEN];\n    }\n  }\n\n  var target$1;\n\n  function createOnceHandler$1 (event, handler, capture) {\n    var _target = target$1; // save current target element in closure\n    return function onceHandler () {\n      var res = handler.apply(null, arguments);\n      if (res !== null) {\n        remove$2(event, onceHandler, capture, _target);\n      }\n    }\n  }\n\n  // #9446: Firefox <= 53 (in particular, ESR 52) has incorrect Event.timeStamp\n  // implementation and does not fire microtasks in between event propagation, so\n  // safe to exclude.\n  var useMicrotaskFix = isUsingMicroTask && !(isFF && Number(isFF[1]) <= 53);\n\n  function add$1 (\n    name,\n    handler,\n    capture,\n    passive\n  ) {\n    // async edge case #6566: inner click event triggers patch, event handler\n    // attached to outer element during patch, and triggered again. This\n    // happens because browsers fire microtask ticks between event propagation.\n    // the solution is simple: we save the timestamp when a handler is attached,\n    // and the handler would only fire if the event passed to it was fired\n    // AFTER it was attached.\n    if (useMicrotaskFix) {\n      var attachedTimestamp = currentFlushTimestamp;\n      var original = handler;\n      handler = original._wrapper = function (e) {\n        if (\n          // no bubbling, should always fire.\n          // this is just a safety net in case event.timeStamp is unreliable in\n          // certain weird environments...\n          e.target === e.currentTarget ||\n          // event is fired after handler attachment\n          e.timeStamp >= attachedTimestamp ||\n          // bail for environments that have buggy event.timeStamp implementations\n          // #9462 iOS 9 bug: event.timeStamp is 0 after history.pushState\n          // #9681 QtWebEngine event.timeStamp is negative value\n          e.timeStamp <= 0 ||\n          // #9448 bail if event is fired in another document in a multi-page\n          // electron/nw.js app, since event.timeStamp will be using a different\n          // starting reference\n          e.target.ownerDocument !== document\n        ) {\n          return original.apply(this, arguments)\n        }\n      };\n    }\n    target$1.addEventListener(\n      name,\n      handler,\n      supportsPassive\n        ? { capture: capture, passive: passive }\n        : capture\n    );\n  }\n\n  function remove$2 (\n    name,\n    handler,\n    capture,\n    _target\n  ) {\n    (_target || target$1).removeEventListener(\n      name,\n      handler._wrapper || handler,\n      capture\n    );\n  }\n\n  function updateDOMListeners (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {\n      return\n    }\n    var on = vnode.data.on || {};\n    var oldOn = oldVnode.data.on || {};\n    target$1 = vnode.elm;\n    normalizeEvents(on);\n    updateListeners(on, oldOn, add$1, remove$2, createOnceHandler$1, vnode.context);\n    target$1 = undefined;\n  }\n\n  var events = {\n    create: updateDOMListeners,\n    update: updateDOMListeners\n  };\n\n  /*  */\n\n  var svgContainer;\n\n  function updateDOMProps (oldVnode, vnode) {\n    if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {\n      return\n    }\n    var key, cur;\n    var elm = vnode.elm;\n    var oldProps = oldVnode.data.domProps || {};\n    var props = vnode.data.domProps || {};\n    // clone observed objects, as the user probably wants to mutate it\n    if (isDef(props.__ob__)) {\n      props = vnode.data.domProps = extend({}, props);\n    }\n\n    for (key in oldProps) {\n      if (!(key in props)) {\n        elm[key] = '';\n      }\n    }\n\n    for (key in props) {\n      cur = props[key];\n      // ignore children if the node has textContent or innerHTML,\n      // as these will throw away existing DOM nodes and cause removal errors\n      // on subsequent patches (#3360)\n      if (key === 'textContent' || key === 'innerHTML') {\n        if (vnode.children) { vnode.children.length = 0; }\n        if (cur === oldProps[key]) { continue }\n        // #6601 work around Chrome version <= 55 bug where single textNode\n        // replaced by innerHTML/textContent retains its parentNode property\n        if (elm.childNodes.length === 1) {\n          elm.removeChild(elm.childNodes[0]);\n        }\n      }\n\n      if (key === 'value' && elm.tagName !== 'PROGRESS') {\n        // store value as _value as well since\n        // non-string values will be stringified\n        elm._value = cur;\n        // avoid resetting cursor position when value is the same\n        var strCur = isUndef(cur) ? '' : String(cur);\n        if (shouldUpdateValue(elm, strCur)) {\n          elm.value = strCur;\n        }\n      } else if (key === 'innerHTML' && isSVG(elm.tagName) && isUndef(elm.innerHTML)) {\n        // IE doesn't support innerHTML for SVG elements\n        svgContainer = svgContainer || document.createElement('div');\n        svgContainer.innerHTML = \"<svg>\" + cur + \"</svg>\";\n        var svg = svgContainer.firstChild;\n        while (elm.firstChild) {\n          elm.removeChild(elm.firstChild);\n        }\n        while (svg.firstChild) {\n          elm.appendChild(svg.firstChild);\n        }\n      } else if (\n        // skip the update if old and new VDOM state is the same.\n        // `value` is handled separately because the DOM value may be temporarily\n        // out of sync with VDOM state due to focus, composition and modifiers.\n        // This  #4521 by skipping the unnecesarry `checked` update.\n        cur !== oldProps[key]\n      ) {\n        // some property updates can throw\n        // e.g. `value` on <progress> w/ non-finite value\n        try {\n          elm[key] = cur;\n        } catch (e) {}\n      }\n    }\n  }\n\n  // check platforms/web/util/attrs.js acceptValue\n\n\n  function shouldUpdateValue (elm, checkVal) {\n    return (!elm.composing && (\n      elm.tagName === 'OPTION' ||\n      isNotInFocusAndDirty(elm, checkVal) ||\n      isDirtyWithModifiers(elm, checkVal)\n    ))\n  }\n\n  function isNotInFocusAndDirty (elm, checkVal) {\n    // return true when textbox (.number and .trim) loses focus and its value is\n    // not equal to the updated value\n    var notInFocus = true;\n    // #6157\n    // work around IE bug when accessing document.activeElement in an iframe\n    try { notInFocus = document.activeElement !== elm; } catch (e) {}\n    return notInFocus && elm.value !== checkVal\n  }\n\n  function isDirtyWithModifiers (elm, newVal) {\n    var value = elm.value;\n    var modifiers = elm._vModifiers; // injected by v-model runtime\n    if (isDef(modifiers)) {\n      if (modifiers.number) {\n        return toNumber(value) !== toNumber(newVal)\n      }\n      if (modifiers.trim) {\n        return value.trim() !== newVal.trim()\n      }\n    }\n    return value !== newVal\n  }\n\n  var domProps = {\n    create: updateDOMProps,\n    update: updateDOMProps\n  };\n\n  /*  */\n\n  var parseStyleText = cached(function (cssText) {\n    var res = {};\n    var listDelimiter = /;(?![^(]*\\))/g;\n    var propertyDelimiter = /:(.+)/;\n    cssText.split(listDelimiter).forEach(function (item) {\n      if (item) {\n        var tmp = item.split(propertyDelimiter);\n        tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());\n      }\n    });\n    return res\n  });\n\n  // merge static and dynamic style data on the same vnode\n  function normalizeStyleData (data) {\n    var style = normalizeStyleBinding(data.style);\n    // static style is pre-processed into an object during compilation\n    // and is always a fresh object, so it's safe to merge into it\n    return data.staticStyle\n      ? extend(data.staticStyle, style)\n      : style\n  }\n\n  // normalize possible array / string values into Object\n  function normalizeStyleBinding (bindingStyle) {\n    if (Array.isArray(bindingStyle)) {\n      return toObject(bindingStyle)\n    }\n    if (typeof bindingStyle === 'string') {\n      return parseStyleText(bindingStyle)\n    }\n    return bindingStyle\n  }\n\n  /**\n   * parent component style should be after child's\n   * so that parent component's style could override it\n   */\n  function getStyle (vnode, checkChild) {\n    var res = {};\n    var styleData;\n\n    if (checkChild) {\n      var childNode = vnode;\n      while (childNode.componentInstance) {\n        childNode = childNode.componentInstance._vnode;\n        if (\n          childNode && childNode.data &&\n          (styleData = normalizeStyleData(childNode.data))\n        ) {\n          extend(res, styleData);\n        }\n      }\n    }\n\n    if ((styleData = normalizeStyleData(vnode.data))) {\n      extend(res, styleData);\n    }\n\n    var parentNode = vnode;\n    while ((parentNode = parentNode.parent)) {\n      if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {\n        extend(res, styleData);\n      }\n    }\n    return res\n  }\n\n  /*  */\n\n  var cssVarRE = /^--/;\n  var importantRE = /\\s*!important$/;\n  var setProp = function (el, name, val) {\n    /* istanbul ignore if */\n    if (cssVarRE.test(name)) {\n      el.style.setProperty(name, val);\n    } else if (importantRE.test(val)) {\n      el.style.setProperty(hyphenate(name), val.replace(importantRE, ''), 'important');\n    } else {\n      var normalizedName = normalize(name);\n      if (Array.isArray(val)) {\n        // Support values array created by autoprefixer, e.g.\n        // {display: [\"-webkit-box\", \"-ms-flexbox\", \"flex\"]}\n        // Set them one by one, and the browser will only set those it can recognize\n        for (var i = 0, len = val.length; i < len; i++) {\n          el.style[normalizedName] = val[i];\n        }\n      } else {\n        el.style[normalizedName] = val;\n      }\n    }\n  };\n\n  var vendorNames = ['Webkit', 'Moz', 'ms'];\n\n  var emptyStyle;\n  var normalize = cached(function (prop) {\n    emptyStyle = emptyStyle || document.createElement('div').style;\n    prop = camelize(prop);\n    if (prop !== 'filter' && (prop in emptyStyle)) {\n      return prop\n    }\n    var capName = prop.charAt(0).toUpperCase() + prop.slice(1);\n    for (var i = 0; i < vendorNames.length; i++) {\n      var name = vendorNames[i] + capName;\n      if (name in emptyStyle) {\n        return name\n      }\n    }\n  });\n\n  function updateStyle (oldVnode, vnode) {\n    var data = vnode.data;\n    var oldData = oldVnode.data;\n\n    if (isUndef(data.staticStyle) && isUndef(data.style) &&\n      isUndef(oldData.staticStyle) && isUndef(oldData.style)\n    ) {\n      return\n    }\n\n    var cur, name;\n    var el = vnode.elm;\n    var oldStaticStyle = oldData.staticStyle;\n    var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};\n\n    // if static style exists, stylebinding already merged into it when doing normalizeStyleData\n    var oldStyle = oldStaticStyle || oldStyleBinding;\n\n    var style = normalizeStyleBinding(vnode.data.style) || {};\n\n    // store normalized style under a different key for next diff\n    // make sure to clone it if it's reactive, since the user likely wants\n    // to mutate it.\n    vnode.data.normalizedStyle = isDef(style.__ob__)\n      ? extend({}, style)\n      : style;\n\n    var newStyle = getStyle(vnode, true);\n\n    for (name in oldStyle) {\n      if (isUndef(newStyle[name])) {\n        setProp(el, name, '');\n      }\n    }\n    for (name in newStyle) {\n      cur = newStyle[name];\n      if (cur !== oldStyle[name]) {\n        // ie9 setting to null has no effect, must use empty string\n        setProp(el, name, cur == null ? '' : cur);\n      }\n    }\n  }\n\n  var style = {\n    create: updateStyle,\n    update: updateStyle\n  };\n\n  /*  */\n\n  var whitespaceRE = /\\s+/;\n\n  /**\n   * Add class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function addClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.add(c); });\n      } else {\n        el.classList.add(cls);\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      if (cur.indexOf(' ' + cls + ' ') < 0) {\n        el.setAttribute('class', (cur + cls).trim());\n      }\n    }\n  }\n\n  /**\n   * Remove class with compatibility for SVG since classList is not supported on\n   * SVG elements in IE\n   */\n  function removeClass (el, cls) {\n    /* istanbul ignore if */\n    if (!cls || !(cls = cls.trim())) {\n      return\n    }\n\n    /* istanbul ignore else */\n    if (el.classList) {\n      if (cls.indexOf(' ') > -1) {\n        cls.split(whitespaceRE).forEach(function (c) { return el.classList.remove(c); });\n      } else {\n        el.classList.remove(cls);\n      }\n      if (!el.classList.length) {\n        el.removeAttribute('class');\n      }\n    } else {\n      var cur = \" \" + (el.getAttribute('class') || '') + \" \";\n      var tar = ' ' + cls + ' ';\n      while (cur.indexOf(tar) >= 0) {\n        cur = cur.replace(tar, ' ');\n      }\n      cur = cur.trim();\n      if (cur) {\n        el.setAttribute('class', cur);\n      } else {\n        el.removeAttribute('class');\n      }\n    }\n  }\n\n  /*  */\n\n  function resolveTransition (def$$1) {\n    if (!def$$1) {\n      return\n    }\n    /* istanbul ignore else */\n    if (typeof def$$1 === 'object') {\n      var res = {};\n      if (def$$1.css !== false) {\n        extend(res, autoCssTransition(def$$1.name || 'v'));\n      }\n      extend(res, def$$1);\n      return res\n    } else if (typeof def$$1 === 'string') {\n      return autoCssTransition(def$$1)\n    }\n  }\n\n  var autoCssTransition = cached(function (name) {\n    return {\n      enterClass: (name + \"-enter\"),\n      enterToClass: (name + \"-enter-to\"),\n      enterActiveClass: (name + \"-enter-active\"),\n      leaveClass: (name + \"-leave\"),\n      leaveToClass: (name + \"-leave-to\"),\n      leaveActiveClass: (name + \"-leave-active\")\n    }\n  });\n\n  var hasTransition = inBrowser && !isIE9;\n  var TRANSITION = 'transition';\n  var ANIMATION = 'animation';\n\n  // Transition property/event sniffing\n  var transitionProp = 'transition';\n  var transitionEndEvent = 'transitionend';\n  var animationProp = 'animation';\n  var animationEndEvent = 'animationend';\n  if (hasTransition) {\n    /* istanbul ignore if */\n    if (window.ontransitionend === undefined &&\n      window.onwebkittransitionend !== undefined\n    ) {\n      transitionProp = 'WebkitTransition';\n      transitionEndEvent = 'webkitTransitionEnd';\n    }\n    if (window.onanimationend === undefined &&\n      window.onwebkitanimationend !== undefined\n    ) {\n      animationProp = 'WebkitAnimation';\n      animationEndEvent = 'webkitAnimationEnd';\n    }\n  }\n\n  // binding to window is necessary to make hot reload work in IE in strict mode\n  var raf = inBrowser\n    ? window.requestAnimationFrame\n      ? window.requestAnimationFrame.bind(window)\n      : setTimeout\n    : /* istanbul ignore next */ function (fn) { return fn(); };\n\n  function nextFrame (fn) {\n    raf(function () {\n      raf(fn);\n    });\n  }\n\n  function addTransitionClass (el, cls) {\n    var transitionClasses = el._transitionClasses || (el._transitionClasses = []);\n    if (transitionClasses.indexOf(cls) < 0) {\n      transitionClasses.push(cls);\n      addClass(el, cls);\n    }\n  }\n\n  function removeTransitionClass (el, cls) {\n    if (el._transitionClasses) {\n      remove(el._transitionClasses, cls);\n    }\n    removeClass(el, cls);\n  }\n\n  function whenTransitionEnds (\n    el,\n    expectedType,\n    cb\n  ) {\n    var ref = getTransitionInfo(el, expectedType);\n    var type = ref.type;\n    var timeout = ref.timeout;\n    var propCount = ref.propCount;\n    if (!type) { return cb() }\n    var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;\n    var ended = 0;\n    var end = function () {\n      el.removeEventListener(event, onEnd);\n      cb();\n    };\n    var onEnd = function (e) {\n      if (e.target === el) {\n        if (++ended >= propCount) {\n          end();\n        }\n      }\n    };\n    setTimeout(function () {\n      if (ended < propCount) {\n        end();\n      }\n    }, timeout + 1);\n    el.addEventListener(event, onEnd);\n  }\n\n  var transformRE = /\\b(transform|all)(,|$)/;\n\n  function getTransitionInfo (el, expectedType) {\n    var styles = window.getComputedStyle(el);\n    // JSDOM may return undefined for transition properties\n    var transitionDelays = (styles[transitionProp + 'Delay'] || '').split(', ');\n    var transitionDurations = (styles[transitionProp + 'Duration'] || '').split(', ');\n    var transitionTimeout = getTimeout(transitionDelays, transitionDurations);\n    var animationDelays = (styles[animationProp + 'Delay'] || '').split(', ');\n    var animationDurations = (styles[animationProp + 'Duration'] || '').split(', ');\n    var animationTimeout = getTimeout(animationDelays, animationDurations);\n\n    var type;\n    var timeout = 0;\n    var propCount = 0;\n    /* istanbul ignore if */\n    if (expectedType === TRANSITION) {\n      if (transitionTimeout > 0) {\n        type = TRANSITION;\n        timeout = transitionTimeout;\n        propCount = transitionDurations.length;\n      }\n    } else if (expectedType === ANIMATION) {\n      if (animationTimeout > 0) {\n        type = ANIMATION;\n        timeout = animationTimeout;\n        propCount = animationDurations.length;\n      }\n    } else {\n      timeout = Math.max(transitionTimeout, animationTimeout);\n      type = timeout > 0\n        ? transitionTimeout > animationTimeout\n          ? TRANSITION\n          : ANIMATION\n        : null;\n      propCount = type\n        ? type === TRANSITION\n          ? transitionDurations.length\n          : animationDurations.length\n        : 0;\n    }\n    var hasTransform =\n      type === TRANSITION &&\n      transformRE.test(styles[transitionProp + 'Property']);\n    return {\n      type: type,\n      timeout: timeout,\n      propCount: propCount,\n      hasTransform: hasTransform\n    }\n  }\n\n  function getTimeout (delays, durations) {\n    /* istanbul ignore next */\n    while (delays.length < durations.length) {\n      delays = delays.concat(delays);\n    }\n\n    return Math.max.apply(null, durations.map(function (d, i) {\n      return toMs(d) + toMs(delays[i])\n    }))\n  }\n\n  // Old versions of Chromium (below 61.0.3163.100) formats floating pointer numbers\n  // in a locale-dependent way, using a comma instead of a dot.\n  // If comma is not replaced with a dot, the input will be rounded down (i.e. acting\n  // as a floor function) causing unexpected behaviors\n  function toMs (s) {\n    return Number(s.slice(0, -1).replace(',', '.')) * 1000\n  }\n\n  /*  */\n\n  function enter (vnode, toggleDisplay) {\n    var el = vnode.elm;\n\n    // call leave callback now\n    if (isDef(el._leaveCb)) {\n      el._leaveCb.cancelled = true;\n      el._leaveCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data)) {\n      return\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._enterCb) || el.nodeType !== 1) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var enterClass = data.enterClass;\n    var enterToClass = data.enterToClass;\n    var enterActiveClass = data.enterActiveClass;\n    var appearClass = data.appearClass;\n    var appearToClass = data.appearToClass;\n    var appearActiveClass = data.appearActiveClass;\n    var beforeEnter = data.beforeEnter;\n    var enter = data.enter;\n    var afterEnter = data.afterEnter;\n    var enterCancelled = data.enterCancelled;\n    var beforeAppear = data.beforeAppear;\n    var appear = data.appear;\n    var afterAppear = data.afterAppear;\n    var appearCancelled = data.appearCancelled;\n    var duration = data.duration;\n\n    // activeInstance will always be the <transition> component managing this\n    // transition. One edge case to check is when the <transition> is placed\n    // as the root node of a child component. In that case we need to check\n    // <transition>'s parent for appear check.\n    var context = activeInstance;\n    var transitionNode = activeInstance.$vnode;\n    while (transitionNode && transitionNode.parent) {\n      context = transitionNode.context;\n      transitionNode = transitionNode.parent;\n    }\n\n    var isAppear = !context._isMounted || !vnode.isRootInsert;\n\n    if (isAppear && !appear && appear !== '') {\n      return\n    }\n\n    var startClass = isAppear && appearClass\n      ? appearClass\n      : enterClass;\n    var activeClass = isAppear && appearActiveClass\n      ? appearActiveClass\n      : enterActiveClass;\n    var toClass = isAppear && appearToClass\n      ? appearToClass\n      : enterToClass;\n\n    var beforeEnterHook = isAppear\n      ? (beforeAppear || beforeEnter)\n      : beforeEnter;\n    var enterHook = isAppear\n      ? (typeof appear === 'function' ? appear : enter)\n      : enter;\n    var afterEnterHook = isAppear\n      ? (afterAppear || afterEnter)\n      : afterEnter;\n    var enterCancelledHook = isAppear\n      ? (appearCancelled || enterCancelled)\n      : enterCancelled;\n\n    var explicitEnterDuration = toNumber(\n      isObject(duration)\n        ? duration.enter\n        : duration\n    );\n\n    if (explicitEnterDuration != null) {\n      checkDuration(explicitEnterDuration, 'enter', vnode);\n    }\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(enterHook);\n\n    var cb = el._enterCb = once(function () {\n      if (expectsCSS) {\n        removeTransitionClass(el, toClass);\n        removeTransitionClass(el, activeClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, startClass);\n        }\n        enterCancelledHook && enterCancelledHook(el);\n      } else {\n        afterEnterHook && afterEnterHook(el);\n      }\n      el._enterCb = null;\n    });\n\n    if (!vnode.data.show) {\n      // remove pending leave element on enter by injecting an insert hook\n      mergeVNodeHook(vnode, 'insert', function () {\n        var parent = el.parentNode;\n        var pendingNode = parent && parent._pending && parent._pending[vnode.key];\n        if (pendingNode &&\n          pendingNode.tag === vnode.tag &&\n          pendingNode.elm._leaveCb\n        ) {\n          pendingNode.elm._leaveCb();\n        }\n        enterHook && enterHook(el, cb);\n      });\n    }\n\n    // start enter transition\n    beforeEnterHook && beforeEnterHook(el);\n    if (expectsCSS) {\n      addTransitionClass(el, startClass);\n      addTransitionClass(el, activeClass);\n      nextFrame(function () {\n        removeTransitionClass(el, startClass);\n        if (!cb.cancelled) {\n          addTransitionClass(el, toClass);\n          if (!userWantsControl) {\n            if (isValidDuration(explicitEnterDuration)) {\n              setTimeout(cb, explicitEnterDuration);\n            } else {\n              whenTransitionEnds(el, type, cb);\n            }\n          }\n        }\n      });\n    }\n\n    if (vnode.data.show) {\n      toggleDisplay && toggleDisplay();\n      enterHook && enterHook(el, cb);\n    }\n\n    if (!expectsCSS && !userWantsControl) {\n      cb();\n    }\n  }\n\n  function leave (vnode, rm) {\n    var el = vnode.elm;\n\n    // call enter callback now\n    if (isDef(el._enterCb)) {\n      el._enterCb.cancelled = true;\n      el._enterCb();\n    }\n\n    var data = resolveTransition(vnode.data.transition);\n    if (isUndef(data) || el.nodeType !== 1) {\n      return rm()\n    }\n\n    /* istanbul ignore if */\n    if (isDef(el._leaveCb)) {\n      return\n    }\n\n    var css = data.css;\n    var type = data.type;\n    var leaveClass = data.leaveClass;\n    var leaveToClass = data.leaveToClass;\n    var leaveActiveClass = data.leaveActiveClass;\n    var beforeLeave = data.beforeLeave;\n    var leave = data.leave;\n    var afterLeave = data.afterLeave;\n    var leaveCancelled = data.leaveCancelled;\n    var delayLeave = data.delayLeave;\n    var duration = data.duration;\n\n    var expectsCSS = css !== false && !isIE9;\n    var userWantsControl = getHookArgumentsLength(leave);\n\n    var explicitLeaveDuration = toNumber(\n      isObject(duration)\n        ? duration.leave\n        : duration\n    );\n\n    if (isDef(explicitLeaveDuration)) {\n      checkDuration(explicitLeaveDuration, 'leave', vnode);\n    }\n\n    var cb = el._leaveCb = once(function () {\n      if (el.parentNode && el.parentNode._pending) {\n        el.parentNode._pending[vnode.key] = null;\n      }\n      if (expectsCSS) {\n        removeTransitionClass(el, leaveToClass);\n        removeTransitionClass(el, leaveActiveClass);\n      }\n      if (cb.cancelled) {\n        if (expectsCSS) {\n          removeTransitionClass(el, leaveClass);\n        }\n        leaveCancelled && leaveCancelled(el);\n      } else {\n        rm();\n        afterLeave && afterLeave(el);\n      }\n      el._leaveCb = null;\n    });\n\n    if (delayLeave) {\n      delayLeave(performLeave);\n    } else {\n      performLeave();\n    }\n\n    function performLeave () {\n      // the delayed leave may have already been cancelled\n      if (cb.cancelled) {\n        return\n      }\n      // record leaving element\n      if (!vnode.data.show && el.parentNode) {\n        (el.parentNode._pending || (el.parentNode._pending = {}))[(vnode.key)] = vnode;\n      }\n      beforeLeave && beforeLeave(el);\n      if (expectsCSS) {\n        addTransitionClass(el, leaveClass);\n        addTransitionClass(el, leaveActiveClass);\n        nextFrame(function () {\n          removeTransitionClass(el, leaveClass);\n          if (!cb.cancelled) {\n            addTransitionClass(el, leaveToClass);\n            if (!userWantsControl) {\n              if (isValidDuration(explicitLeaveDuration)) {\n                setTimeout(cb, explicitLeaveDuration);\n              } else {\n                whenTransitionEnds(el, type, cb);\n              }\n            }\n          }\n        });\n      }\n      leave && leave(el, cb);\n      if (!expectsCSS && !userWantsControl) {\n        cb();\n      }\n    }\n  }\n\n  // only used in dev mode\n  function checkDuration (val, name, vnode) {\n    if (typeof val !== 'number') {\n      warn(\n        \"<transition> explicit \" + name + \" duration is not a valid number - \" +\n        \"got \" + (JSON.stringify(val)) + \".\",\n        vnode.context\n      );\n    } else if (isNaN(val)) {\n      warn(\n        \"<transition> explicit \" + name + \" duration is NaN - \" +\n        'the duration expression might be incorrect.',\n        vnode.context\n      );\n    }\n  }\n\n  function isValidDuration (val) {\n    return typeof val === 'number' && !isNaN(val)\n  }\n\n  /**\n   * Normalize a transition hook's argument length. The hook may be:\n   * - a merged hook (invoker) with the original in .fns\n   * - a wrapped component method (check ._length)\n   * - a plain function (.length)\n   */\n  function getHookArgumentsLength (fn) {\n    if (isUndef(fn)) {\n      return false\n    }\n    var invokerFns = fn.fns;\n    if (isDef(invokerFns)) {\n      // invoker\n      return getHookArgumentsLength(\n        Array.isArray(invokerFns)\n          ? invokerFns[0]\n          : invokerFns\n      )\n    } else {\n      return (fn._length || fn.length) > 1\n    }\n  }\n\n  function _enter (_, vnode) {\n    if (vnode.data.show !== true) {\n      enter(vnode);\n    }\n  }\n\n  var transition = inBrowser ? {\n    create: _enter,\n    activate: _enter,\n    remove: function remove$$1 (vnode, rm) {\n      /* istanbul ignore else */\n      if (vnode.data.show !== true) {\n        leave(vnode, rm);\n      } else {\n        rm();\n      }\n    }\n  } : {};\n\n  var platformModules = [\n    attrs,\n    klass,\n    events,\n    domProps,\n    style,\n    transition\n  ];\n\n  /*  */\n\n  // the directive module should be applied last, after all\n  // built-in modules have been applied.\n  var modules = platformModules.concat(baseModules);\n\n  var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });\n\n  /**\n   * Not type checking this file because flow doesn't like attaching\n   * properties to Elements.\n   */\n\n  /* istanbul ignore if */\n  if (isIE9) {\n    // http://www.matts411.com/post/internet-explorer-9-oninput/\n    document.addEventListener('selectionchange', function () {\n      var el = document.activeElement;\n      if (el && el.vmodel) {\n        trigger(el, 'input');\n      }\n    });\n  }\n\n  var directive = {\n    inserted: function inserted (el, binding, vnode, oldVnode) {\n      if (vnode.tag === 'select') {\n        // #6903\n        if (oldVnode.elm && !oldVnode.elm._vOptions) {\n          mergeVNodeHook(vnode, 'postpatch', function () {\n            directive.componentUpdated(el, binding, vnode);\n          });\n        } else {\n          setSelected(el, binding, vnode.context);\n        }\n        el._vOptions = [].map.call(el.options, getValue);\n      } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {\n        el._vModifiers = binding.modifiers;\n        if (!binding.modifiers.lazy) {\n          el.addEventListener('compositionstart', onCompositionStart);\n          el.addEventListener('compositionend', onCompositionEnd);\n          // Safari < 10.2 & UIWebView doesn't fire compositionend when\n          // switching focus before confirming composition choice\n          // this also fixes the issue where some browsers e.g. iOS Chrome\n          // fires \"change\" instead of \"input\" on autocomplete.\n          el.addEventListener('change', onCompositionEnd);\n          /* istanbul ignore if */\n          if (isIE9) {\n            el.vmodel = true;\n          }\n        }\n      }\n    },\n\n    componentUpdated: function componentUpdated (el, binding, vnode) {\n      if (vnode.tag === 'select') {\n        setSelected(el, binding, vnode.context);\n        // in case the options rendered by v-for have changed,\n        // it's possible that the value is out-of-sync with the rendered options.\n        // detect such cases and filter out values that no longer has a matching\n        // option in the DOM.\n        var prevOptions = el._vOptions;\n        var curOptions = el._vOptions = [].map.call(el.options, getValue);\n        if (curOptions.some(function (o, i) { return !looseEqual(o, prevOptions[i]); })) {\n          // trigger change event if\n          // no matching option found for at least one value\n          var needReset = el.multiple\n            ? binding.value.some(function (v) { return hasNoMatchingOption(v, curOptions); })\n            : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);\n          if (needReset) {\n            trigger(el, 'change');\n          }\n        }\n      }\n    }\n  };\n\n  function setSelected (el, binding, vm) {\n    actuallySetSelected(el, binding, vm);\n    /* istanbul ignore if */\n    if (isIE || isEdge) {\n      setTimeout(function () {\n        actuallySetSelected(el, binding, vm);\n      }, 0);\n    }\n  }\n\n  function actuallySetSelected (el, binding, vm) {\n    var value = binding.value;\n    var isMultiple = el.multiple;\n    if (isMultiple && !Array.isArray(value)) {\n      warn(\n        \"<select multiple v-model=\\\"\" + (binding.expression) + \"\\\"> \" +\n        \"expects an Array value for its binding, but got \" + (Object.prototype.toString.call(value).slice(8, -1)),\n        vm\n      );\n      return\n    }\n    var selected, option;\n    for (var i = 0, l = el.options.length; i < l; i++) {\n      option = el.options[i];\n      if (isMultiple) {\n        selected = looseIndexOf(value, getValue(option)) > -1;\n        if (option.selected !== selected) {\n          option.selected = selected;\n        }\n      } else {\n        if (looseEqual(getValue(option), value)) {\n          if (el.selectedIndex !== i) {\n            el.selectedIndex = i;\n          }\n          return\n        }\n      }\n    }\n    if (!isMultiple) {\n      el.selectedIndex = -1;\n    }\n  }\n\n  function hasNoMatchingOption (value, options) {\n    return options.every(function (o) { return !looseEqual(o, value); })\n  }\n\n  function getValue (option) {\n    return '_value' in option\n      ? option._value\n      : option.value\n  }\n\n  function onCompositionStart (e) {\n    e.target.composing = true;\n  }\n\n  function onCompositionEnd (e) {\n    // prevent triggering an input event for no reason\n    if (!e.target.composing) { return }\n    e.target.composing = false;\n    trigger(e.target, 'input');\n  }\n\n  function trigger (el, type) {\n    var e = document.createEvent('HTMLEvents');\n    e.initEvent(type, true, true);\n    el.dispatchEvent(e);\n  }\n\n  /*  */\n\n  // recursively search for possible transition defined inside the component root\n  function locateNode (vnode) {\n    return vnode.componentInstance && (!vnode.data || !vnode.data.transition)\n      ? locateNode(vnode.componentInstance._vnode)\n      : vnode\n  }\n\n  var show = {\n    bind: function bind (el, ref, vnode) {\n      var value = ref.value;\n\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      var originalDisplay = el.__vOriginalDisplay =\n        el.style.display === 'none' ? '' : el.style.display;\n      if (value && transition$$1) {\n        vnode.data.show = true;\n        enter(vnode, function () {\n          el.style.display = originalDisplay;\n        });\n      } else {\n        el.style.display = value ? originalDisplay : 'none';\n      }\n    },\n\n    update: function update (el, ref, vnode) {\n      var value = ref.value;\n      var oldValue = ref.oldValue;\n\n      /* istanbul ignore if */\n      if (!value === !oldValue) { return }\n      vnode = locateNode(vnode);\n      var transition$$1 = vnode.data && vnode.data.transition;\n      if (transition$$1) {\n        vnode.data.show = true;\n        if (value) {\n          enter(vnode, function () {\n            el.style.display = el.__vOriginalDisplay;\n          });\n        } else {\n          leave(vnode, function () {\n            el.style.display = 'none';\n          });\n        }\n      } else {\n        el.style.display = value ? el.__vOriginalDisplay : 'none';\n      }\n    },\n\n    unbind: function unbind (\n      el,\n      binding,\n      vnode,\n      oldVnode,\n      isDestroy\n    ) {\n      if (!isDestroy) {\n        el.style.display = el.__vOriginalDisplay;\n      }\n    }\n  };\n\n  var platformDirectives = {\n    model: directive,\n    show: show\n  };\n\n  /*  */\n\n  var transitionProps = {\n    name: String,\n    appear: Boolean,\n    css: Boolean,\n    mode: String,\n    type: String,\n    enterClass: String,\n    leaveClass: String,\n    enterToClass: String,\n    leaveToClass: String,\n    enterActiveClass: String,\n    leaveActiveClass: String,\n    appearClass: String,\n    appearActiveClass: String,\n    appearToClass: String,\n    duration: [Number, String, Object]\n  };\n\n  // in case the child is also an abstract component, e.g. <keep-alive>\n  // we want to recursively retrieve the real component to be rendered\n  function getRealChild (vnode) {\n    var compOptions = vnode && vnode.componentOptions;\n    if (compOptions && compOptions.Ctor.options.abstract) {\n      return getRealChild(getFirstComponentChild(compOptions.children))\n    } else {\n      return vnode\n    }\n  }\n\n  function extractTransitionData (comp) {\n    var data = {};\n    var options = comp.$options;\n    // props\n    for (var key in options.propsData) {\n      data[key] = comp[key];\n    }\n    // events.\n    // extract listeners and pass them directly to the transition methods\n    var listeners = options._parentListeners;\n    for (var key$1 in listeners) {\n      data[camelize(key$1)] = listeners[key$1];\n    }\n    return data\n  }\n\n  function placeholder (h, rawChild) {\n    if (/\\d-keep-alive$/.test(rawChild.tag)) {\n      return h('keep-alive', {\n        props: rawChild.componentOptions.propsData\n      })\n    }\n  }\n\n  function hasParentTransition (vnode) {\n    while ((vnode = vnode.parent)) {\n      if (vnode.data.transition) {\n        return true\n      }\n    }\n  }\n\n  function isSameChild (child, oldChild) {\n    return oldChild.key === child.key && oldChild.tag === child.tag\n  }\n\n  var isNotTextNode = function (c) { return c.tag || isAsyncPlaceholder(c); };\n\n  var isVShowDirective = function (d) { return d.name === 'show'; };\n\n  var Transition = {\n    name: 'transition',\n    props: transitionProps,\n    abstract: true,\n\n    render: function render (h) {\n      var this$1 = this;\n\n      var children = this.$slots.default;\n      if (!children) {\n        return\n      }\n\n      // filter out text nodes (possible whitespaces)\n      children = children.filter(isNotTextNode);\n      /* istanbul ignore if */\n      if (!children.length) {\n        return\n      }\n\n      // warn multiple elements\n      if (children.length > 1) {\n        warn(\n          '<transition> can only be used on a single element. Use ' +\n          '<transition-group> for lists.',\n          this.$parent\n        );\n      }\n\n      var mode = this.mode;\n\n      // warn invalid mode\n      if (mode && mode !== 'in-out' && mode !== 'out-in'\n      ) {\n        warn(\n          'invalid <transition> mode: ' + mode,\n          this.$parent\n        );\n      }\n\n      var rawChild = children[0];\n\n      // if this is a component root node and the component's\n      // parent container node also has transition, skip.\n      if (hasParentTransition(this.$vnode)) {\n        return rawChild\n      }\n\n      // apply transition data to child\n      // use getRealChild() to ignore abstract components e.g. keep-alive\n      var child = getRealChild(rawChild);\n      /* istanbul ignore if */\n      if (!child) {\n        return rawChild\n      }\n\n      if (this._leaving) {\n        return placeholder(h, rawChild)\n      }\n\n      // ensure a key that is unique to the vnode type and to this transition\n      // component instance. This key will be used to remove pending leaving nodes\n      // during entering.\n      var id = \"__transition-\" + (this._uid) + \"-\";\n      child.key = child.key == null\n        ? child.isComment\n          ? id + 'comment'\n          : id + child.tag\n        : isPrimitive(child.key)\n          ? (String(child.key).indexOf(id) === 0 ? child.key : id + child.key)\n          : child.key;\n\n      var data = (child.data || (child.data = {})).transition = extractTransitionData(this);\n      var oldRawChild = this._vnode;\n      var oldChild = getRealChild(oldRawChild);\n\n      // mark v-show\n      // so that the transition module can hand over the control to the directive\n      if (child.data.directives && child.data.directives.some(isVShowDirective)) {\n        child.data.show = true;\n      }\n\n      if (\n        oldChild &&\n        oldChild.data &&\n        !isSameChild(child, oldChild) &&\n        !isAsyncPlaceholder(oldChild) &&\n        // #6687 component root is a comment node\n        !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)\n      ) {\n        // replace old child transition data with fresh one\n        // important for dynamic transitions!\n        var oldData = oldChild.data.transition = extend({}, data);\n        // handle transition mode\n        if (mode === 'out-in') {\n          // return placeholder node and queue update when leave finishes\n          this._leaving = true;\n          mergeVNodeHook(oldData, 'afterLeave', function () {\n            this$1._leaving = false;\n            this$1.$forceUpdate();\n          });\n          return placeholder(h, rawChild)\n        } else if (mode === 'in-out') {\n          if (isAsyncPlaceholder(child)) {\n            return oldRawChild\n          }\n          var delayedLeave;\n          var performLeave = function () { delayedLeave(); };\n          mergeVNodeHook(data, 'afterEnter', performLeave);\n          mergeVNodeHook(data, 'enterCancelled', performLeave);\n          mergeVNodeHook(oldData, 'delayLeave', function (leave) { delayedLeave = leave; });\n        }\n      }\n\n      return rawChild\n    }\n  };\n\n  /*  */\n\n  var props = extend({\n    tag: String,\n    moveClass: String\n  }, transitionProps);\n\n  delete props.mode;\n\n  var TransitionGroup = {\n    props: props,\n\n    beforeMount: function beforeMount () {\n      var this$1 = this;\n\n      var update = this._update;\n      this._update = function (vnode, hydrating) {\n        var restoreActiveInstance = setActiveInstance(this$1);\n        // force removing pass\n        this$1.__patch__(\n          this$1._vnode,\n          this$1.kept,\n          false, // hydrating\n          true // removeOnly (!important, avoids unnecessary moves)\n        );\n        this$1._vnode = this$1.kept;\n        restoreActiveInstance();\n        update.call(this$1, vnode, hydrating);\n      };\n    },\n\n    render: function render (h) {\n      var tag = this.tag || this.$vnode.data.tag || 'span';\n      var map = Object.create(null);\n      var prevChildren = this.prevChildren = this.children;\n      var rawChildren = this.$slots.default || [];\n      var children = this.children = [];\n      var transitionData = extractTransitionData(this);\n\n      for (var i = 0; i < rawChildren.length; i++) {\n        var c = rawChildren[i];\n        if (c.tag) {\n          if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {\n            children.push(c);\n            map[c.key] = c\n            ;(c.data || (c.data = {})).transition = transitionData;\n          } else {\n            var opts = c.componentOptions;\n            var name = opts ? (opts.Ctor.options.name || opts.tag || '') : c.tag;\n            warn((\"<transition-group> children must be keyed: <\" + name + \">\"));\n          }\n        }\n      }\n\n      if (prevChildren) {\n        var kept = [];\n        var removed = [];\n        for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {\n          var c$1 = prevChildren[i$1];\n          c$1.data.transition = transitionData;\n          c$1.data.pos = c$1.elm.getBoundingClientRect();\n          if (map[c$1.key]) {\n            kept.push(c$1);\n          } else {\n            removed.push(c$1);\n          }\n        }\n        this.kept = h(tag, null, kept);\n        this.removed = removed;\n      }\n\n      return h(tag, null, children)\n    },\n\n    updated: function updated () {\n      var children = this.prevChildren;\n      var moveClass = this.moveClass || ((this.name || 'v') + '-move');\n      if (!children.length || !this.hasMove(children[0].elm, moveClass)) {\n        return\n      }\n\n      // we divide the work into three loops to avoid mixing DOM reads and writes\n      // in each iteration - which helps prevent layout thrashing.\n      children.forEach(callPendingCbs);\n      children.forEach(recordPosition);\n      children.forEach(applyTranslation);\n\n      // force reflow to put everything in position\n      // assign to this to avoid being removed in tree-shaking\n      // $flow-disable-line\n      this._reflow = document.body.offsetHeight;\n\n      children.forEach(function (c) {\n        if (c.data.moved) {\n          var el = c.elm;\n          var s = el.style;\n          addTransitionClass(el, moveClass);\n          s.transform = s.WebkitTransform = s.transitionDuration = '';\n          el.addEventListener(transitionEndEvent, el._moveCb = function cb (e) {\n            if (e && e.target !== el) {\n              return\n            }\n            if (!e || /transform$/.test(e.propertyName)) {\n              el.removeEventListener(transitionEndEvent, cb);\n              el._moveCb = null;\n              removeTransitionClass(el, moveClass);\n            }\n          });\n        }\n      });\n    },\n\n    methods: {\n      hasMove: function hasMove (el, moveClass) {\n        /* istanbul ignore if */\n        if (!hasTransition) {\n          return false\n        }\n        /* istanbul ignore if */\n        if (this._hasMove) {\n          return this._hasMove\n        }\n        // Detect whether an element with the move class applied has\n        // CSS transitions. Since the element may be inside an entering\n        // transition at this very moment, we make a clone of it and remove\n        // all other transition classes applied to ensure only the move class\n        // is applied.\n        var clone = el.cloneNode();\n        if (el._transitionClasses) {\n          el._transitionClasses.forEach(function (cls) { removeClass(clone, cls); });\n        }\n        addClass(clone, moveClass);\n        clone.style.display = 'none';\n        this.$el.appendChild(clone);\n        var info = getTransitionInfo(clone);\n        this.$el.removeChild(clone);\n        return (this._hasMove = info.hasTransform)\n      }\n    }\n  };\n\n  function callPendingCbs (c) {\n    /* istanbul ignore if */\n    if (c.elm._moveCb) {\n      c.elm._moveCb();\n    }\n    /* istanbul ignore if */\n    if (c.elm._enterCb) {\n      c.elm._enterCb();\n    }\n  }\n\n  function recordPosition (c) {\n    c.data.newPos = c.elm.getBoundingClientRect();\n  }\n\n  function applyTranslation (c) {\n    var oldPos = c.data.pos;\n    var newPos = c.data.newPos;\n    var dx = oldPos.left - newPos.left;\n    var dy = oldPos.top - newPos.top;\n    if (dx || dy) {\n      c.data.moved = true;\n      var s = c.elm.style;\n      s.transform = s.WebkitTransform = \"translate(\" + dx + \"px,\" + dy + \"px)\";\n      s.transitionDuration = '0s';\n    }\n  }\n\n  var platformComponents = {\n    Transition: Transition,\n    TransitionGroup: TransitionGroup\n  };\n\n  /*  */\n\n  // install platform specific utils\n  Vue.config.mustUseProp = mustUseProp;\n  Vue.config.isReservedTag = isReservedTag;\n  Vue.config.isReservedAttr = isReservedAttr;\n  Vue.config.getTagNamespace = getTagNamespace;\n  Vue.config.isUnknownElement = isUnknownElement;\n\n  // install platform runtime directives & components\n  extend(Vue.options.directives, platformDirectives);\n  extend(Vue.options.components, platformComponents);\n\n  // install platform patch function\n  Vue.prototype.__patch__ = inBrowser ? patch : noop;\n\n  // public mount method\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && inBrowser ? query(el) : undefined;\n    return mountComponent(this, el, hydrating)\n  };\n\n  // devtools global hook\n  /* istanbul ignore next */\n  if (inBrowser) {\n    setTimeout(function () {\n      if (config.devtools) {\n        if (devtools) {\n          devtools.emit('init', Vue);\n        } else {\n          console[console.info ? 'info' : 'log'](\n            'Download the Vue Devtools extension for a better development experience:\\n' +\n            'https://github.com/vuejs/vue-devtools'\n          );\n        }\n      }\n      if (config.productionTip !== false &&\n        typeof console !== 'undefined'\n      ) {\n        console[console.info ? 'info' : 'log'](\n          \"You are running Vue in development mode.\\n\" +\n          \"Make sure to turn on production mode when deploying for production.\\n\" +\n          \"See more tips at https://vuejs.org/guide/deployment.html\"\n        );\n      }\n    }, 0);\n  }\n\n  /*  */\n\n  var defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g;\n  var regexEscapeRE = /[-.*+?^${}()|[\\]\\/\\\\]/g;\n\n  var buildRegex = cached(function (delimiters) {\n    var open = delimiters[0].replace(regexEscapeRE, '\\\\$&');\n    var close = delimiters[1].replace(regexEscapeRE, '\\\\$&');\n    return new RegExp(open + '((?:.|\\\\n)+?)' + close, 'g')\n  });\n\n\n\n  function parseText (\n    text,\n    delimiters\n  ) {\n    var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;\n    if (!tagRE.test(text)) {\n      return\n    }\n    var tokens = [];\n    var rawTokens = [];\n    var lastIndex = tagRE.lastIndex = 0;\n    var match, index, tokenValue;\n    while ((match = tagRE.exec(text))) {\n      index = match.index;\n      // push text token\n      if (index > lastIndex) {\n        rawTokens.push(tokenValue = text.slice(lastIndex, index));\n        tokens.push(JSON.stringify(tokenValue));\n      }\n      // tag token\n      var exp = parseFilters(match[1].trim());\n      tokens.push((\"_s(\" + exp + \")\"));\n      rawTokens.push({ '@binding': exp });\n      lastIndex = index + match[0].length;\n    }\n    if (lastIndex < text.length) {\n      rawTokens.push(tokenValue = text.slice(lastIndex));\n      tokens.push(JSON.stringify(tokenValue));\n    }\n    return {\n      expression: tokens.join('+'),\n      tokens: rawTokens\n    }\n  }\n\n  /*  */\n\n  function transformNode (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticClass = getAndRemoveAttr(el, 'class');\n    if (staticClass) {\n      var res = parseText(staticClass, options.delimiters);\n      if (res) {\n        warn(\n          \"class=\\\"\" + staticClass + \"\\\": \" +\n          'Interpolation inside attributes has been removed. ' +\n          'Use v-bind or the colon shorthand instead. For example, ' +\n          'instead of <div class=\"{{ val }}\">, use <div :class=\"val\">.',\n          el.rawAttrsMap['class']\n        );\n      }\n    }\n    if (staticClass) {\n      el.staticClass = JSON.stringify(staticClass);\n    }\n    var classBinding = getBindingAttr(el, 'class', false /* getStatic */);\n    if (classBinding) {\n      el.classBinding = classBinding;\n    }\n  }\n\n  function genData (el) {\n    var data = '';\n    if (el.staticClass) {\n      data += \"staticClass:\" + (el.staticClass) + \",\";\n    }\n    if (el.classBinding) {\n      data += \"class:\" + (el.classBinding) + \",\";\n    }\n    return data\n  }\n\n  var klass$1 = {\n    staticKeys: ['staticClass'],\n    transformNode: transformNode,\n    genData: genData\n  };\n\n  /*  */\n\n  function transformNode$1 (el, options) {\n    var warn = options.warn || baseWarn;\n    var staticStyle = getAndRemoveAttr(el, 'style');\n    if (staticStyle) {\n      /* istanbul ignore if */\n      {\n        var res = parseText(staticStyle, options.delimiters);\n        if (res) {\n          warn(\n            \"style=\\\"\" + staticStyle + \"\\\": \" +\n            'Interpolation inside attributes has been removed. ' +\n            'Use v-bind or the colon shorthand instead. For example, ' +\n            'instead of <div style=\"{{ val }}\">, use <div :style=\"val\">.',\n            el.rawAttrsMap['style']\n          );\n        }\n      }\n      el.staticStyle = JSON.stringify(parseStyleText(staticStyle));\n    }\n\n    var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);\n    if (styleBinding) {\n      el.styleBinding = styleBinding;\n    }\n  }\n\n  function genData$1 (el) {\n    var data = '';\n    if (el.staticStyle) {\n      data += \"staticStyle:\" + (el.staticStyle) + \",\";\n    }\n    if (el.styleBinding) {\n      data += \"style:(\" + (el.styleBinding) + \"),\";\n    }\n    return data\n  }\n\n  var style$1 = {\n    staticKeys: ['staticStyle'],\n    transformNode: transformNode$1,\n    genData: genData$1\n  };\n\n  /*  */\n\n  var decoder;\n\n  var he = {\n    decode: function decode (html) {\n      decoder = decoder || document.createElement('div');\n      decoder.innerHTML = html;\n      return decoder.textContent\n    }\n  };\n\n  /*  */\n\n  var isUnaryTag = makeMap(\n    'area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' +\n    'link,meta,param,source,track,wbr'\n  );\n\n  // Elements that you can, intentionally, leave open\n  // (and which close themselves)\n  var canBeLeftOpenTag = makeMap(\n    'colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source'\n  );\n\n  // HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3\n  // Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content\n  var isNonPhrasingTag = makeMap(\n    'address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' +\n    'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' +\n    'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' +\n    'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' +\n    'title,tr,track'\n  );\n\n  /**\n   * Not type-checking this file because it's mostly vendor code.\n   */\n\n  // Regular Expressions for parsing tags and attributes\n  var attribute = /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var dynamicArgAttribute = /^\\s*((?:v-[\\w-]+:|@|:|#)\\[[^=]+\\][^\\s\"'<>\\/=]*)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/;\n  var ncname = \"[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z\" + (unicodeRegExp.source) + \"]*\";\n  var qnameCapture = \"((?:\" + ncname + \"\\\\:)?\" + ncname + \")\";\n  var startTagOpen = new RegExp((\"^<\" + qnameCapture));\n  var startTagClose = /^\\s*(\\/?)>/;\n  var endTag = new RegExp((\"^<\\\\/\" + qnameCapture + \"[^>]*>\"));\n  var doctype = /^<!DOCTYPE [^>]+>/i;\n  // #7298: escape - to avoid being pased as HTML comment when inlined in page\n  var comment = /^<!\\--/;\n  var conditionalComment = /^<!\\[/;\n\n  // Special Elements (can contain anything)\n  var isPlainTextElement = makeMap('script,style,textarea', true);\n  var reCache = {};\n\n  var decodingMap = {\n    '&lt;': '<',\n    '&gt;': '>',\n    '&quot;': '\"',\n    '&amp;': '&',\n    '&#10;': '\\n',\n    '&#9;': '\\t',\n    '&#39;': \"'\"\n  };\n  var encodedAttr = /&(?:lt|gt|quot|amp|#39);/g;\n  var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#39|#10|#9);/g;\n\n  // #5992\n  var isIgnoreNewlineTag = makeMap('pre,textarea', true);\n  var shouldIgnoreFirstNewline = function (tag, html) { return tag && isIgnoreNewlineTag(tag) && html[0] === '\\n'; };\n\n  function decodeAttr (value, shouldDecodeNewlines) {\n    var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;\n    return value.replace(re, function (match) { return decodingMap[match]; })\n  }\n\n  function parseHTML (html, options) {\n    var stack = [];\n    var expectHTML = options.expectHTML;\n    var isUnaryTag$$1 = options.isUnaryTag || no;\n    var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;\n    var index = 0;\n    var last, lastTag;\n    while (html) {\n      last = html;\n      // Make sure we're not in a plaintext content element like script/style\n      if (!lastTag || !isPlainTextElement(lastTag)) {\n        var textEnd = html.indexOf('<');\n        if (textEnd === 0) {\n          // Comment:\n          if (comment.test(html)) {\n            var commentEnd = html.indexOf('-->');\n\n            if (commentEnd >= 0) {\n              if (options.shouldKeepComment) {\n                options.comment(html.substring(4, commentEnd), index, index + commentEnd + 3);\n              }\n              advance(commentEnd + 3);\n              continue\n            }\n          }\n\n          // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment\n          if (conditionalComment.test(html)) {\n            var conditionalEnd = html.indexOf(']>');\n\n            if (conditionalEnd >= 0) {\n              advance(conditionalEnd + 2);\n              continue\n            }\n          }\n\n          // Doctype:\n          var doctypeMatch = html.match(doctype);\n          if (doctypeMatch) {\n            advance(doctypeMatch[0].length);\n            continue\n          }\n\n          // End tag:\n          var endTagMatch = html.match(endTag);\n          if (endTagMatch) {\n            var curIndex = index;\n            advance(endTagMatch[0].length);\n            parseEndTag(endTagMatch[1], curIndex, index);\n            continue\n          }\n\n          // Start tag:\n          var startTagMatch = parseStartTag();\n          if (startTagMatch) {\n            handleStartTag(startTagMatch);\n            if (shouldIgnoreFirstNewline(startTagMatch.tagName, html)) {\n              advance(1);\n            }\n            continue\n          }\n        }\n\n        var text = (void 0), rest = (void 0), next = (void 0);\n        if (textEnd >= 0) {\n          rest = html.slice(textEnd);\n          while (\n            !endTag.test(rest) &&\n            !startTagOpen.test(rest) &&\n            !comment.test(rest) &&\n            !conditionalComment.test(rest)\n          ) {\n            // < in plain text, be forgiving and treat it as text\n            next = rest.indexOf('<', 1);\n            if (next < 0) { break }\n            textEnd += next;\n            rest = html.slice(textEnd);\n          }\n          text = html.substring(0, textEnd);\n        }\n\n        if (textEnd < 0) {\n          text = html;\n        }\n\n        if (text) {\n          advance(text.length);\n        }\n\n        if (options.chars && text) {\n          options.chars(text, index - text.length, index);\n        }\n      } else {\n        var endTagLength = 0;\n        var stackedTag = lastTag.toLowerCase();\n        var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\\\s\\\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));\n        var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {\n          endTagLength = endTag.length;\n          if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {\n            text = text\n              .replace(/<!\\--([\\s\\S]*?)-->/g, '$1') // #7298\n              .replace(/<!\\[CDATA\\[([\\s\\S]*?)]]>/g, '$1');\n          }\n          if (shouldIgnoreFirstNewline(stackedTag, text)) {\n            text = text.slice(1);\n          }\n          if (options.chars) {\n            options.chars(text);\n          }\n          return ''\n        });\n        index += html.length - rest$1.length;\n        html = rest$1;\n        parseEndTag(stackedTag, index - endTagLength, index);\n      }\n\n      if (html === last) {\n        options.chars && options.chars(html);\n        if (!stack.length && options.warn) {\n          options.warn((\"Mal-formatted tag at end of template: \\\"\" + html + \"\\\"\"), { start: index + html.length });\n        }\n        break\n      }\n    }\n\n    // Clean up any remaining tags\n    parseEndTag();\n\n    function advance (n) {\n      index += n;\n      html = html.substring(n);\n    }\n\n    function parseStartTag () {\n      var start = html.match(startTagOpen);\n      if (start) {\n        var match = {\n          tagName: start[1],\n          attrs: [],\n          start: index\n        };\n        advance(start[0].length);\n        var end, attr;\n        while (!(end = html.match(startTagClose)) && (attr = html.match(dynamicArgAttribute) || html.match(attribute))) {\n          attr.start = index;\n          advance(attr[0].length);\n          attr.end = index;\n          match.attrs.push(attr);\n        }\n        if (end) {\n          match.unarySlash = end[1];\n          advance(end[0].length);\n          match.end = index;\n          return match\n        }\n      }\n    }\n\n    function handleStartTag (match) {\n      var tagName = match.tagName;\n      var unarySlash = match.unarySlash;\n\n      if (expectHTML) {\n        if (lastTag === 'p' && isNonPhrasingTag(tagName)) {\n          parseEndTag(lastTag);\n        }\n        if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {\n          parseEndTag(tagName);\n        }\n      }\n\n      var unary = isUnaryTag$$1(tagName) || !!unarySlash;\n\n      var l = match.attrs.length;\n      var attrs = new Array(l);\n      for (var i = 0; i < l; i++) {\n        var args = match.attrs[i];\n        var value = args[3] || args[4] || args[5] || '';\n        var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href'\n          ? options.shouldDecodeNewlinesForHref\n          : options.shouldDecodeNewlines;\n        attrs[i] = {\n          name: args[1],\n          value: decodeAttr(value, shouldDecodeNewlines)\n        };\n        if (options.outputSourceRange) {\n          attrs[i].start = args.start + args[0].match(/^\\s*/).length;\n          attrs[i].end = args.end;\n        }\n      }\n\n      if (!unary) {\n        stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs, start: match.start, end: match.end });\n        lastTag = tagName;\n      }\n\n      if (options.start) {\n        options.start(tagName, attrs, unary, match.start, match.end);\n      }\n    }\n\n    function parseEndTag (tagName, start, end) {\n      var pos, lowerCasedTagName;\n      if (start == null) { start = index; }\n      if (end == null) { end = index; }\n\n      // Find the closest opened tag of the same type\n      if (tagName) {\n        lowerCasedTagName = tagName.toLowerCase();\n        for (pos = stack.length - 1; pos >= 0; pos--) {\n          if (stack[pos].lowerCasedTag === lowerCasedTagName) {\n            break\n          }\n        }\n      } else {\n        // If no tag name is provided, clean shop\n        pos = 0;\n      }\n\n      if (pos >= 0) {\n        // Close all the open elements, up the stack\n        for (var i = stack.length - 1; i >= pos; i--) {\n          if (i > pos || !tagName &&\n            options.warn\n          ) {\n            options.warn(\n              (\"tag <\" + (stack[i].tag) + \"> has no matching end tag.\"),\n              { start: stack[i].start, end: stack[i].end }\n            );\n          }\n          if (options.end) {\n            options.end(stack[i].tag, start, end);\n          }\n        }\n\n        // Remove the open elements from the stack\n        stack.length = pos;\n        lastTag = pos && stack[pos - 1].tag;\n      } else if (lowerCasedTagName === 'br') {\n        if (options.start) {\n          options.start(tagName, [], true, start, end);\n        }\n      } else if (lowerCasedTagName === 'p') {\n        if (options.start) {\n          options.start(tagName, [], false, start, end);\n        }\n        if (options.end) {\n          options.end(tagName, start, end);\n        }\n      }\n    }\n  }\n\n  /*  */\n\n  var onRE = /^@|^v-on:/;\n  var dirRE = /^v-|^@|^:/;\n  var forAliasRE = /([\\s\\S]*?)\\s+(?:in|of)\\s+([\\s\\S]*)/;\n  var forIteratorRE = /,([^,\\}\\]]*)(?:,([^,\\}\\]]*))?$/;\n  var stripParensRE = /^\\(|\\)$/g;\n  var dynamicArgRE = /^\\[.*\\]$/;\n\n  var argRE = /:(.*)$/;\n  var bindRE = /^:|^\\.|^v-bind:/;\n  var modifierRE = /\\.[^.\\]]+(?=[^\\]]*$)/g;\n\n  var slotRE = /^v-slot(:|$)|^#/;\n\n  var lineBreakRE = /[\\r\\n]/;\n  var whitespaceRE$1 = /\\s+/g;\n\n  var invalidAttributeRE = /[\\s\"'<>\\/=]/;\n\n  var decodeHTMLCached = cached(he.decode);\n\n  var emptySlotScopeToken = \"_empty_\";\n\n  // configurable state\n  var warn$2;\n  var delimiters;\n  var transforms;\n  var preTransforms;\n  var postTransforms;\n  var platformIsPreTag;\n  var platformMustUseProp;\n  var platformGetTagNamespace;\n  var maybeComponent;\n\n  function createASTElement (\n    tag,\n    attrs,\n    parent\n  ) {\n    return {\n      type: 1,\n      tag: tag,\n      attrsList: attrs,\n      attrsMap: makeAttrsMap(attrs),\n      rawAttrsMap: {},\n      parent: parent,\n      children: []\n    }\n  }\n\n  /**\n   * Convert HTML string to AST.\n   */\n  function parse (\n    template,\n    options\n  ) {\n    warn$2 = options.warn || baseWarn;\n\n    platformIsPreTag = options.isPreTag || no;\n    platformMustUseProp = options.mustUseProp || no;\n    platformGetTagNamespace = options.getTagNamespace || no;\n    var isReservedTag = options.isReservedTag || no;\n    maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n\n    transforms = pluckModuleFunction(options.modules, 'transformNode');\n    preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');\n    postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');\n\n    delimiters = options.delimiters;\n\n    var stack = [];\n    var preserveWhitespace = options.preserveWhitespace !== false;\n    var whitespaceOption = options.whitespace;\n    var root;\n    var currentParent;\n    var inVPre = false;\n    var inPre = false;\n    var warned = false;\n\n    function warnOnce (msg, range) {\n      if (!warned) {\n        warned = true;\n        warn$2(msg, range);\n      }\n    }\n\n    function closeElement (element) {\n      trimEndingWhitespace(element);\n      if (!inVPre && !element.processed) {\n        element = processElement(element, options);\n      }\n      // tree management\n      if (!stack.length && element !== root) {\n        // allow root elements with v-if, v-else-if and v-else\n        if (root.if && (element.elseif || element.else)) {\n          {\n            checkRootConstraints(element);\n          }\n          addIfCondition(root, {\n            exp: element.elseif,\n            block: element\n          });\n        } else {\n          warnOnce(\n            \"Component template should contain exactly one root element. \" +\n            \"If you are using v-if on multiple elements, \" +\n            \"use v-else-if to chain them instead.\",\n            { start: element.start }\n          );\n        }\n      }\n      if (currentParent && !element.forbidden) {\n        if (element.elseif || element.else) {\n          processIfConditions(element, currentParent);\n        } else {\n          if (element.slotScope) {\n            // scoped slot\n            // keep it in the children list so that v-else(-if) conditions can\n            // find it as the prev node.\n            var name = element.slotTarget || '\"default\"'\n            ;(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;\n          }\n          currentParent.children.push(element);\n          element.parent = currentParent;\n        }\n      }\n\n      // final children cleanup\n      // filter out scoped slots\n      element.children = element.children.filter(function (c) { return !(c).slotScope; });\n      // remove trailing whitespace node again\n      trimEndingWhitespace(element);\n\n      // check pre state\n      if (element.pre) {\n        inVPre = false;\n      }\n      if (platformIsPreTag(element.tag)) {\n        inPre = false;\n      }\n      // apply post-transforms\n      for (var i = 0; i < postTransforms.length; i++) {\n        postTransforms[i](element, options);\n      }\n    }\n\n    function trimEndingWhitespace (el) {\n      // remove trailing whitespace node\n      if (!inPre) {\n        var lastNode;\n        while (\n          (lastNode = el.children[el.children.length - 1]) &&\n          lastNode.type === 3 &&\n          lastNode.text === ' '\n        ) {\n          el.children.pop();\n        }\n      }\n    }\n\n    function checkRootConstraints (el) {\n      if (el.tag === 'slot' || el.tag === 'template') {\n        warnOnce(\n          \"Cannot use <\" + (el.tag) + \"> as component root element because it may \" +\n          'contain multiple nodes.',\n          { start: el.start }\n        );\n      }\n      if (el.attrsMap.hasOwnProperty('v-for')) {\n        warnOnce(\n          'Cannot use v-for on stateful component root element because ' +\n          'it renders multiple elements.',\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n\n    parseHTML(template, {\n      warn: warn$2,\n      expectHTML: options.expectHTML,\n      isUnaryTag: options.isUnaryTag,\n      canBeLeftOpenTag: options.canBeLeftOpenTag,\n      shouldDecodeNewlines: options.shouldDecodeNewlines,\n      shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,\n      shouldKeepComment: options.comments,\n      outputSourceRange: options.outputSourceRange,\n      start: function start (tag, attrs, unary, start$1, end) {\n        // check namespace.\n        // inherit parent ns if there is one\n        var ns = (currentParent && currentParent.ns) || platformGetTagNamespace(tag);\n\n        // handle IE svg bug\n        /* istanbul ignore if */\n        if (isIE && ns === 'svg') {\n          attrs = guardIESVGBug(attrs);\n        }\n\n        var element = createASTElement(tag, attrs, currentParent);\n        if (ns) {\n          element.ns = ns;\n        }\n\n        {\n          if (options.outputSourceRange) {\n            element.start = start$1;\n            element.end = end;\n            element.rawAttrsMap = element.attrsList.reduce(function (cumulated, attr) {\n              cumulated[attr.name] = attr;\n              return cumulated\n            }, {});\n          }\n          attrs.forEach(function (attr) {\n            if (invalidAttributeRE.test(attr.name)) {\n              warn$2(\n                \"Invalid dynamic argument expression: attribute names cannot contain \" +\n                \"spaces, quotes, <, >, / or =.\",\n                {\n                  start: attr.start + attr.name.indexOf(\"[\"),\n                  end: attr.start + attr.name.length\n                }\n              );\n            }\n          });\n        }\n\n        if (isForbiddenTag(element) && !isServerRendering()) {\n          element.forbidden = true;\n          warn$2(\n            'Templates should only be responsible for mapping the state to the ' +\n            'UI. Avoid placing tags with side-effects in your templates, such as ' +\n            \"<\" + tag + \">\" + ', as they will not be parsed.',\n            { start: element.start }\n          );\n        }\n\n        // apply pre-transforms\n        for (var i = 0; i < preTransforms.length; i++) {\n          element = preTransforms[i](element, options) || element;\n        }\n\n        if (!inVPre) {\n          processPre(element);\n          if (element.pre) {\n            inVPre = true;\n          }\n        }\n        if (platformIsPreTag(element.tag)) {\n          inPre = true;\n        }\n        if (inVPre) {\n          processRawAttrs(element);\n        } else if (!element.processed) {\n          // structural directives\n          processFor(element);\n          processIf(element);\n          processOnce(element);\n        }\n\n        if (!root) {\n          root = element;\n          {\n            checkRootConstraints(root);\n          }\n        }\n\n        if (!unary) {\n          currentParent = element;\n          stack.push(element);\n        } else {\n          closeElement(element);\n        }\n      },\n\n      end: function end (tag, start, end$1) {\n        var element = stack[stack.length - 1];\n        // pop stack\n        stack.length -= 1;\n        currentParent = stack[stack.length - 1];\n        if (options.outputSourceRange) {\n          element.end = end$1;\n        }\n        closeElement(element);\n      },\n\n      chars: function chars (text, start, end) {\n        if (!currentParent) {\n          {\n            if (text === template) {\n              warnOnce(\n                'Component template requires a root element, rather than just text.',\n                { start: start }\n              );\n            } else if ((text = text.trim())) {\n              warnOnce(\n                (\"text \\\"\" + text + \"\\\" outside root element will be ignored.\"),\n                { start: start }\n              );\n            }\n          }\n          return\n        }\n        // IE textarea placeholder bug\n        /* istanbul ignore if */\n        if (isIE &&\n          currentParent.tag === 'textarea' &&\n          currentParent.attrsMap.placeholder === text\n        ) {\n          return\n        }\n        var children = currentParent.children;\n        if (inPre || text.trim()) {\n          text = isTextTag(currentParent) ? text : decodeHTMLCached(text);\n        } else if (!children.length) {\n          // remove the whitespace-only node right after an opening tag\n          text = '';\n        } else if (whitespaceOption) {\n          if (whitespaceOption === 'condense') {\n            // in condense mode, remove the whitespace node if it contains\n            // line break, otherwise condense to a single space\n            text = lineBreakRE.test(text) ? '' : ' ';\n          } else {\n            text = ' ';\n          }\n        } else {\n          text = preserveWhitespace ? ' ' : '';\n        }\n        if (text) {\n          if (!inPre && whitespaceOption === 'condense') {\n            // condense consecutive whitespaces into single space\n            text = text.replace(whitespaceRE$1, ' ');\n          }\n          var res;\n          var child;\n          if (!inVPre && text !== ' ' && (res = parseText(text, delimiters))) {\n            child = {\n              type: 2,\n              expression: res.expression,\n              tokens: res.tokens,\n              text: text\n            };\n          } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {\n            child = {\n              type: 3,\n              text: text\n            };\n          }\n          if (child) {\n            if (options.outputSourceRange) {\n              child.start = start;\n              child.end = end;\n            }\n            children.push(child);\n          }\n        }\n      },\n      comment: function comment (text, start, end) {\n        // adding anyting as a sibling to the root node is forbidden\n        // comments should still be allowed, but ignored\n        if (currentParent) {\n          var child = {\n            type: 3,\n            text: text,\n            isComment: true\n          };\n          if (options.outputSourceRange) {\n            child.start = start;\n            child.end = end;\n          }\n          currentParent.children.push(child);\n        }\n      }\n    });\n    return root\n  }\n\n  function processPre (el) {\n    if (getAndRemoveAttr(el, 'v-pre') != null) {\n      el.pre = true;\n    }\n  }\n\n  function processRawAttrs (el) {\n    var list = el.attrsList;\n    var len = list.length;\n    if (len) {\n      var attrs = el.attrs = new Array(len);\n      for (var i = 0; i < len; i++) {\n        attrs[i] = {\n          name: list[i].name,\n          value: JSON.stringify(list[i].value)\n        };\n        if (list[i].start != null) {\n          attrs[i].start = list[i].start;\n          attrs[i].end = list[i].end;\n        }\n      }\n    } else if (!el.pre) {\n      // non root node in pre blocks with no attributes\n      el.plain = true;\n    }\n  }\n\n  function processElement (\n    element,\n    options\n  ) {\n    processKey(element);\n\n    // determine whether this is a plain element after\n    // removing structural attributes\n    element.plain = (\n      !element.key &&\n      !element.scopedSlots &&\n      !element.attrsList.length\n    );\n\n    processRef(element);\n    processSlotContent(element);\n    processSlotOutlet(element);\n    processComponent(element);\n    for (var i = 0; i < transforms.length; i++) {\n      element = transforms[i](element, options) || element;\n    }\n    processAttrs(element);\n    return element\n  }\n\n  function processKey (el) {\n    var exp = getBindingAttr(el, 'key');\n    if (exp) {\n      {\n        if (el.tag === 'template') {\n          warn$2(\n            \"<template> cannot be keyed. Place the key on real elements instead.\",\n            getRawBindingAttr(el, 'key')\n          );\n        }\n        if (el.for) {\n          var iterator = el.iterator2 || el.iterator1;\n          var parent = el.parent;\n          if (iterator && iterator === exp && parent && parent.tag === 'transition-group') {\n            warn$2(\n              \"Do not use v-for index as key on <transition-group> children, \" +\n              \"this is the same as not using keys.\",\n              getRawBindingAttr(el, 'key'),\n              true /* tip */\n            );\n          }\n        }\n      }\n      el.key = exp;\n    }\n  }\n\n  function processRef (el) {\n    var ref = getBindingAttr(el, 'ref');\n    if (ref) {\n      el.ref = ref;\n      el.refInFor = checkInFor(el);\n    }\n  }\n\n  function processFor (el) {\n    var exp;\n    if ((exp = getAndRemoveAttr(el, 'v-for'))) {\n      var res = parseFor(exp);\n      if (res) {\n        extend(el, res);\n      } else {\n        warn$2(\n          (\"Invalid v-for expression: \" + exp),\n          el.rawAttrsMap['v-for']\n        );\n      }\n    }\n  }\n\n\n\n  function parseFor (exp) {\n    var inMatch = exp.match(forAliasRE);\n    if (!inMatch) { return }\n    var res = {};\n    res.for = inMatch[2].trim();\n    var alias = inMatch[1].trim().replace(stripParensRE, '');\n    var iteratorMatch = alias.match(forIteratorRE);\n    if (iteratorMatch) {\n      res.alias = alias.replace(forIteratorRE, '').trim();\n      res.iterator1 = iteratorMatch[1].trim();\n      if (iteratorMatch[2]) {\n        res.iterator2 = iteratorMatch[2].trim();\n      }\n    } else {\n      res.alias = alias;\n    }\n    return res\n  }\n\n  function processIf (el) {\n    var exp = getAndRemoveAttr(el, 'v-if');\n    if (exp) {\n      el.if = exp;\n      addIfCondition(el, {\n        exp: exp,\n        block: el\n      });\n    } else {\n      if (getAndRemoveAttr(el, 'v-else') != null) {\n        el.else = true;\n      }\n      var elseif = getAndRemoveAttr(el, 'v-else-if');\n      if (elseif) {\n        el.elseif = elseif;\n      }\n    }\n  }\n\n  function processIfConditions (el, parent) {\n    var prev = findPrevElement(parent.children);\n    if (prev && prev.if) {\n      addIfCondition(prev, {\n        exp: el.elseif,\n        block: el\n      });\n    } else {\n      warn$2(\n        \"v-\" + (el.elseif ? ('else-if=\"' + el.elseif + '\"') : 'else') + \" \" +\n        \"used on element <\" + (el.tag) + \"> without corresponding v-if.\",\n        el.rawAttrsMap[el.elseif ? 'v-else-if' : 'v-else']\n      );\n    }\n  }\n\n  function findPrevElement (children) {\n    var i = children.length;\n    while (i--) {\n      if (children[i].type === 1) {\n        return children[i]\n      } else {\n        if (children[i].text !== ' ') {\n          warn$2(\n            \"text \\\"\" + (children[i].text.trim()) + \"\\\" between v-if and v-else(-if) \" +\n            \"will be ignored.\",\n            children[i]\n          );\n        }\n        children.pop();\n      }\n    }\n  }\n\n  function addIfCondition (el, condition) {\n    if (!el.ifConditions) {\n      el.ifConditions = [];\n    }\n    el.ifConditions.push(condition);\n  }\n\n  function processOnce (el) {\n    var once$$1 = getAndRemoveAttr(el, 'v-once');\n    if (once$$1 != null) {\n      el.once = true;\n    }\n  }\n\n  // handle content being passed to a component as slot,\n  // e.g. <template slot=\"xxx\">, <div slot-scope=\"xxx\">\n  function processSlotContent (el) {\n    var slotScope;\n    if (el.tag === 'template') {\n      slotScope = getAndRemoveAttr(el, 'scope');\n      /* istanbul ignore if */\n      if (slotScope) {\n        warn$2(\n          \"the \\\"scope\\\" attribute for scoped slots have been deprecated and \" +\n          \"replaced by \\\"slot-scope\\\" since 2.5. The new \\\"slot-scope\\\" attribute \" +\n          \"can also be used on plain elements in addition to <template> to \" +\n          \"denote scoped slots.\",\n          el.rawAttrsMap['scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');\n    } else if ((slotScope = getAndRemoveAttr(el, 'slot-scope'))) {\n      /* istanbul ignore if */\n      if (el.attrsMap['v-for']) {\n        warn$2(\n          \"Ambiguous combined usage of slot-scope and v-for on <\" + (el.tag) + \"> \" +\n          \"(v-for takes higher priority). Use a wrapper <template> for the \" +\n          \"scoped slot to make it clearer.\",\n          el.rawAttrsMap['slot-scope'],\n          true\n        );\n      }\n      el.slotScope = slotScope;\n    }\n\n    // slot=\"xxx\"\n    var slotTarget = getBindingAttr(el, 'slot');\n    if (slotTarget) {\n      el.slotTarget = slotTarget === '\"\"' ? '\"default\"' : slotTarget;\n      el.slotTargetDynamic = !!(el.attrsMap[':slot'] || el.attrsMap['v-bind:slot']);\n      // preserve slot as an attribute for native shadow DOM compat\n      // only for non-scoped slots.\n      if (el.tag !== 'template' && !el.slotScope) {\n        addAttr(el, 'slot', slotTarget, getRawBindingAttr(el, 'slot'));\n      }\n    }\n\n    // 2.6 v-slot syntax\n    {\n      if (el.tag === 'template') {\n        // v-slot on <template>\n        var slotBinding = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding) {\n          {\n            if (el.slotTarget || el.slotScope) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.parent && !maybeComponent(el.parent)) {\n              warn$2(\n                \"<template v-slot> can only appear at the root level inside \" +\n                \"the receiving the component\",\n                el\n              );\n            }\n          }\n          var ref = getSlotName(slotBinding);\n          var name = ref.name;\n          var dynamic = ref.dynamic;\n          el.slotTarget = name;\n          el.slotTargetDynamic = dynamic;\n          el.slotScope = slotBinding.value || emptySlotScopeToken; // force it into a scoped slot for perf\n        }\n      } else {\n        // v-slot on component, denotes default slot\n        var slotBinding$1 = getAndRemoveAttrByRegex(el, slotRE);\n        if (slotBinding$1) {\n          {\n            if (!maybeComponent(el)) {\n              warn$2(\n                \"v-slot can only be used on components or <template>.\",\n                slotBinding$1\n              );\n            }\n            if (el.slotScope || el.slotTarget) {\n              warn$2(\n                \"Unexpected mixed usage of different slot syntaxes.\",\n                el\n              );\n            }\n            if (el.scopedSlots) {\n              warn$2(\n                \"To avoid scope ambiguity, the default slot should also use \" +\n                \"<template> syntax when there are other named slots.\",\n                slotBinding$1\n              );\n            }\n          }\n          // add the component's children to its default slot\n          var slots = el.scopedSlots || (el.scopedSlots = {});\n          var ref$1 = getSlotName(slotBinding$1);\n          var name$1 = ref$1.name;\n          var dynamic$1 = ref$1.dynamic;\n          var slotContainer = slots[name$1] = createASTElement('template', [], el);\n          slotContainer.slotTarget = name$1;\n          slotContainer.slotTargetDynamic = dynamic$1;\n          slotContainer.children = el.children.filter(function (c) {\n            if (!c.slotScope) {\n              c.parent = slotContainer;\n              return true\n            }\n          });\n          slotContainer.slotScope = slotBinding$1.value || emptySlotScopeToken;\n          // remove children as they are returned from scopedSlots now\n          el.children = [];\n          // mark el non-plain so data gets generated\n          el.plain = false;\n        }\n      }\n    }\n  }\n\n  function getSlotName (binding) {\n    var name = binding.name.replace(slotRE, '');\n    if (!name) {\n      if (binding.name[0] !== '#') {\n        name = 'default';\n      } else {\n        warn$2(\n          \"v-slot shorthand syntax requires a slot name.\",\n          binding\n        );\n      }\n    }\n    return dynamicArgRE.test(name)\n      // dynamic [name]\n      ? { name: name.slice(1, -1), dynamic: true }\n      // static name\n      : { name: (\"\\\"\" + name + \"\\\"\"), dynamic: false }\n  }\n\n  // handle <slot/> outlets\n  function processSlotOutlet (el) {\n    if (el.tag === 'slot') {\n      el.slotName = getBindingAttr(el, 'name');\n      if (el.key) {\n        warn$2(\n          \"`key` does not work on <slot> because slots are abstract outlets \" +\n          \"and can possibly expand into multiple elements. \" +\n          \"Use the key on a wrapping element instead.\",\n          getRawBindingAttr(el, 'key')\n        );\n      }\n    }\n  }\n\n  function processComponent (el) {\n    var binding;\n    if ((binding = getBindingAttr(el, 'is'))) {\n      el.component = binding;\n    }\n    if (getAndRemoveAttr(el, 'inline-template') != null) {\n      el.inlineTemplate = true;\n    }\n  }\n\n  function processAttrs (el) {\n    var list = el.attrsList;\n    var i, l, name, rawName, value, modifiers, syncGen, isDynamic;\n    for (i = 0, l = list.length; i < l; i++) {\n      name = rawName = list[i].name;\n      value = list[i].value;\n      if (dirRE.test(name)) {\n        // mark element as dynamic\n        el.hasBindings = true;\n        // modifiers\n        modifiers = parseModifiers(name.replace(dirRE, ''));\n        // support .foo shorthand syntax for the .prop modifier\n        if (modifiers) {\n          name = name.replace(modifierRE, '');\n        }\n        if (bindRE.test(name)) { // v-bind\n          name = name.replace(bindRE, '');\n          value = parseFilters(value);\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          if (\n            value.trim().length === 0\n          ) {\n            warn$2(\n              (\"The value for a v-bind expression cannot be empty. Found in \\\"v-bind:\" + name + \"\\\"\")\n            );\n          }\n          if (modifiers) {\n            if (modifiers.prop && !isDynamic) {\n              name = camelize(name);\n              if (name === 'innerHtml') { name = 'innerHTML'; }\n            }\n            if (modifiers.camel && !isDynamic) {\n              name = camelize(name);\n            }\n            if (modifiers.sync) {\n              syncGen = genAssignmentCode(value, \"$event\");\n              if (!isDynamic) {\n                addHandler(\n                  el,\n                  (\"update:\" + (camelize(name))),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i]\n                );\n                if (hyphenate(name) !== camelize(name)) {\n                  addHandler(\n                    el,\n                    (\"update:\" + (hyphenate(name))),\n                    syncGen,\n                    null,\n                    false,\n                    warn$2,\n                    list[i]\n                  );\n                }\n              } else {\n                // handler w/ dynamic event name\n                addHandler(\n                  el,\n                  (\"\\\"update:\\\"+(\" + name + \")\"),\n                  syncGen,\n                  null,\n                  false,\n                  warn$2,\n                  list[i],\n                  true // dynamic\n                );\n              }\n            }\n          }\n          if ((modifiers && modifiers.prop) || (\n            !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)\n          )) {\n            addProp(el, name, value, list[i], isDynamic);\n          } else {\n            addAttr(el, name, value, list[i], isDynamic);\n          }\n        } else if (onRE.test(name)) { // v-on\n          name = name.replace(onRE, '');\n          isDynamic = dynamicArgRE.test(name);\n          if (isDynamic) {\n            name = name.slice(1, -1);\n          }\n          addHandler(el, name, value, modifiers, false, warn$2, list[i], isDynamic);\n        } else { // normal directives\n          name = name.replace(dirRE, '');\n          // parse arg\n          var argMatch = name.match(argRE);\n          var arg = argMatch && argMatch[1];\n          isDynamic = false;\n          if (arg) {\n            name = name.slice(0, -(arg.length + 1));\n            if (dynamicArgRE.test(arg)) {\n              arg = arg.slice(1, -1);\n              isDynamic = true;\n            }\n          }\n          addDirective(el, name, rawName, value, arg, isDynamic, modifiers, list[i]);\n          if (name === 'model') {\n            checkForAliasModel(el, value);\n          }\n        }\n      } else {\n        // literal attribute\n        {\n          var res = parseText(value, delimiters);\n          if (res) {\n            warn$2(\n              name + \"=\\\"\" + value + \"\\\": \" +\n              'Interpolation inside attributes has been removed. ' +\n              'Use v-bind or the colon shorthand instead. For example, ' +\n              'instead of <div id=\"{{ val }}\">, use <div :id=\"val\">.',\n              list[i]\n            );\n          }\n        }\n        addAttr(el, name, JSON.stringify(value), list[i]);\n        // #6887 firefox doesn't update muted state if set via attribute\n        // even immediately after element creation\n        if (!el.component &&\n            name === 'muted' &&\n            platformMustUseProp(el.tag, el.attrsMap.type, name)) {\n          addProp(el, name, 'true', list[i]);\n        }\n      }\n    }\n  }\n\n  function checkInFor (el) {\n    var parent = el;\n    while (parent) {\n      if (parent.for !== undefined) {\n        return true\n      }\n      parent = parent.parent;\n    }\n    return false\n  }\n\n  function parseModifiers (name) {\n    var match = name.match(modifierRE);\n    if (match) {\n      var ret = {};\n      match.forEach(function (m) { ret[m.slice(1)] = true; });\n      return ret\n    }\n  }\n\n  function makeAttrsMap (attrs) {\n    var map = {};\n    for (var i = 0, l = attrs.length; i < l; i++) {\n      if (\n        map[attrs[i].name] && !isIE && !isEdge\n      ) {\n        warn$2('duplicate attribute: ' + attrs[i].name, attrs[i]);\n      }\n      map[attrs[i].name] = attrs[i].value;\n    }\n    return map\n  }\n\n  // for script (e.g. type=\"x/template\") or style, do not decode content\n  function isTextTag (el) {\n    return el.tag === 'script' || el.tag === 'style'\n  }\n\n  function isForbiddenTag (el) {\n    return (\n      el.tag === 'style' ||\n      (el.tag === 'script' && (\n        !el.attrsMap.type ||\n        el.attrsMap.type === 'text/javascript'\n      ))\n    )\n  }\n\n  var ieNSBug = /^xmlns:NS\\d+/;\n  var ieNSPrefix = /^NS\\d+:/;\n\n  /* istanbul ignore next */\n  function guardIESVGBug (attrs) {\n    var res = [];\n    for (var i = 0; i < attrs.length; i++) {\n      var attr = attrs[i];\n      if (!ieNSBug.test(attr.name)) {\n        attr.name = attr.name.replace(ieNSPrefix, '');\n        res.push(attr);\n      }\n    }\n    return res\n  }\n\n  function checkForAliasModel (el, value) {\n    var _el = el;\n    while (_el) {\n      if (_el.for && _el.alias === value) {\n        warn$2(\n          \"<\" + (el.tag) + \" v-model=\\\"\" + value + \"\\\">: \" +\n          \"You are binding v-model directly to a v-for iteration alias. \" +\n          \"This will not be able to modify the v-for source array because \" +\n          \"writing to the alias is like modifying a function local variable. \" +\n          \"Consider using an array of objects and use v-model on an object property instead.\",\n          el.rawAttrsMap['v-model']\n        );\n      }\n      _el = _el.parent;\n    }\n  }\n\n  /*  */\n\n  function preTransformNode (el, options) {\n    if (el.tag === 'input') {\n      var map = el.attrsMap;\n      if (!map['v-model']) {\n        return\n      }\n\n      var typeBinding;\n      if (map[':type'] || map['v-bind:type']) {\n        typeBinding = getBindingAttr(el, 'type');\n      }\n      if (!map.type && !typeBinding && map['v-bind']) {\n        typeBinding = \"(\" + (map['v-bind']) + \").type\";\n      }\n\n      if (typeBinding) {\n        var ifCondition = getAndRemoveAttr(el, 'v-if', true);\n        var ifConditionExtra = ifCondition ? (\"&&(\" + ifCondition + \")\") : \"\";\n        var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;\n        var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);\n        // 1. checkbox\n        var branch0 = cloneASTElement(el);\n        // process for on the main node\n        processFor(branch0);\n        addRawAttr(branch0, 'type', 'checkbox');\n        processElement(branch0, options);\n        branch0.processed = true; // prevent it from double-processed\n        branch0.if = \"(\" + typeBinding + \")==='checkbox'\" + ifConditionExtra;\n        addIfCondition(branch0, {\n          exp: branch0.if,\n          block: branch0\n        });\n        // 2. add radio else-if condition\n        var branch1 = cloneASTElement(el);\n        getAndRemoveAttr(branch1, 'v-for', true);\n        addRawAttr(branch1, 'type', 'radio');\n        processElement(branch1, options);\n        addIfCondition(branch0, {\n          exp: \"(\" + typeBinding + \")==='radio'\" + ifConditionExtra,\n          block: branch1\n        });\n        // 3. other\n        var branch2 = cloneASTElement(el);\n        getAndRemoveAttr(branch2, 'v-for', true);\n        addRawAttr(branch2, ':type', typeBinding);\n        processElement(branch2, options);\n        addIfCondition(branch0, {\n          exp: ifCondition,\n          block: branch2\n        });\n\n        if (hasElse) {\n          branch0.else = true;\n        } else if (elseIfCondition) {\n          branch0.elseif = elseIfCondition;\n        }\n\n        return branch0\n      }\n    }\n  }\n\n  function cloneASTElement (el) {\n    return createASTElement(el.tag, el.attrsList.slice(), el.parent)\n  }\n\n  var model$1 = {\n    preTransformNode: preTransformNode\n  };\n\n  var modules$1 = [\n    klass$1,\n    style$1,\n    model$1\n  ];\n\n  /*  */\n\n  function text (el, dir) {\n    if (dir.value) {\n      addProp(el, 'textContent', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  /*  */\n\n  function html (el, dir) {\n    if (dir.value) {\n      addProp(el, 'innerHTML', (\"_s(\" + (dir.value) + \")\"), dir);\n    }\n  }\n\n  var directives$1 = {\n    model: model,\n    text: text,\n    html: html\n  };\n\n  /*  */\n\n  var baseOptions = {\n    expectHTML: true,\n    modules: modules$1,\n    directives: directives$1,\n    isPreTag: isPreTag,\n    isUnaryTag: isUnaryTag,\n    mustUseProp: mustUseProp,\n    canBeLeftOpenTag: canBeLeftOpenTag,\n    isReservedTag: isReservedTag,\n    getTagNamespace: getTagNamespace,\n    staticKeys: genStaticKeys(modules$1)\n  };\n\n  /*  */\n\n  var isStaticKey;\n  var isPlatformReservedTag;\n\n  var genStaticKeysCached = cached(genStaticKeys$1);\n\n  /**\n   * Goal of the optimizer: walk the generated template AST tree\n   * and detect sub-trees that are purely static, i.e. parts of\n   * the DOM that never needs to change.\n   *\n   * Once we detect these sub-trees, we can:\n   *\n   * 1. Hoist them into constants, so that we no longer need to\n   *    create fresh nodes for them on each re-render;\n   * 2. Completely skip them in the patching process.\n   */\n  function optimize (root, options) {\n    if (!root) { return }\n    isStaticKey = genStaticKeysCached(options.staticKeys || '');\n    isPlatformReservedTag = options.isReservedTag || no;\n    // first pass: mark all non-static nodes.\n    markStatic$1(root);\n    // second pass: mark static roots.\n    markStaticRoots(root, false);\n  }\n\n  function genStaticKeys$1 (keys) {\n    return makeMap(\n      'type,tag,attrsList,attrsMap,plain,parent,children,attrs,start,end,rawAttrsMap' +\n      (keys ? ',' + keys : '')\n    )\n  }\n\n  function markStatic$1 (node) {\n    node.static = isStatic(node);\n    if (node.type === 1) {\n      // do not make component slot content static. this avoids\n      // 1. components not able to mutate slot nodes\n      // 2. static slot content fails for hot-reloading\n      if (\n        !isPlatformReservedTag(node.tag) &&\n        node.tag !== 'slot' &&\n        node.attrsMap['inline-template'] == null\n      ) {\n        return\n      }\n      for (var i = 0, l = node.children.length; i < l; i++) {\n        var child = node.children[i];\n        markStatic$1(child);\n        if (!child.static) {\n          node.static = false;\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          var block = node.ifConditions[i$1].block;\n          markStatic$1(block);\n          if (!block.static) {\n            node.static = false;\n          }\n        }\n      }\n    }\n  }\n\n  function markStaticRoots (node, isInFor) {\n    if (node.type === 1) {\n      if (node.static || node.once) {\n        node.staticInFor = isInFor;\n      }\n      // For a node to qualify as a static root, it should have children that\n      // are not just static text. Otherwise the cost of hoisting out will\n      // outweigh the benefits and it's better off to just always render it fresh.\n      if (node.static && node.children.length && !(\n        node.children.length === 1 &&\n        node.children[0].type === 3\n      )) {\n        node.staticRoot = true;\n        return\n      } else {\n        node.staticRoot = false;\n      }\n      if (node.children) {\n        for (var i = 0, l = node.children.length; i < l; i++) {\n          markStaticRoots(node.children[i], isInFor || !!node.for);\n        }\n      }\n      if (node.ifConditions) {\n        for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {\n          markStaticRoots(node.ifConditions[i$1].block, isInFor);\n        }\n      }\n    }\n  }\n\n  function isStatic (node) {\n    if (node.type === 2) { // expression\n      return false\n    }\n    if (node.type === 3) { // text\n      return true\n    }\n    return !!(node.pre || (\n      !node.hasBindings && // no dynamic bindings\n      !node.if && !node.for && // not v-if or v-for or v-else\n      !isBuiltInTag(node.tag) && // not a built-in\n      isPlatformReservedTag(node.tag) && // not a component\n      !isDirectChildOfTemplateFor(node) &&\n      Object.keys(node).every(isStaticKey)\n    ))\n  }\n\n  function isDirectChildOfTemplateFor (node) {\n    while (node.parent) {\n      node = node.parent;\n      if (node.tag !== 'template') {\n        return false\n      }\n      if (node.for) {\n        return true\n      }\n    }\n    return false\n  }\n\n  /*  */\n\n  var fnExpRE = /^([\\w$_]+|\\([^)]*?\\))\\s*=>|^function\\s*(?:[\\w$]+)?\\s*\\(/;\n  var fnInvokeRE = /\\([^)]*?\\);*$/;\n  var simplePathRE = /^[A-Za-z_$][\\w$]*(?:\\.[A-Za-z_$][\\w$]*|\\['[^']*?']|\\[\"[^\"]*?\"]|\\[\\d+]|\\[[A-Za-z_$][\\w$]*])*$/;\n\n  // KeyboardEvent.keyCode aliases\n  var keyCodes = {\n    esc: 27,\n    tab: 9,\n    enter: 13,\n    space: 32,\n    up: 38,\n    left: 37,\n    right: 39,\n    down: 40,\n    'delete': [8, 46]\n  };\n\n  // KeyboardEvent.key aliases\n  var keyNames = {\n    // #7880: IE11 and Edge use `Esc` for Escape key name.\n    esc: ['Esc', 'Escape'],\n    tab: 'Tab',\n    enter: 'Enter',\n    // #9112: IE11 uses `Spacebar` for Space key name.\n    space: [' ', 'Spacebar'],\n    // #7806: IE11 uses key names without `Arrow` prefix for arrow keys.\n    up: ['Up', 'ArrowUp'],\n    left: ['Left', 'ArrowLeft'],\n    right: ['Right', 'ArrowRight'],\n    down: ['Down', 'ArrowDown'],\n    // #9112: IE11 uses `Del` for Delete key name.\n    'delete': ['Backspace', 'Delete', 'Del']\n  };\n\n  // #4868: modifiers that prevent the execution of the listener\n  // need to explicitly return null so that we can determine whether to remove\n  // the listener for .once\n  var genGuard = function (condition) { return (\"if(\" + condition + \")return null;\"); };\n\n  var modifierCode = {\n    stop: '$event.stopPropagation();',\n    prevent: '$event.preventDefault();',\n    self: genGuard(\"$event.target !== $event.currentTarget\"),\n    ctrl: genGuard(\"!$event.ctrlKey\"),\n    shift: genGuard(\"!$event.shiftKey\"),\n    alt: genGuard(\"!$event.altKey\"),\n    meta: genGuard(\"!$event.metaKey\"),\n    left: genGuard(\"'button' in $event && $event.button !== 0\"),\n    middle: genGuard(\"'button' in $event && $event.button !== 1\"),\n    right: genGuard(\"'button' in $event && $event.button !== 2\")\n  };\n\n  function genHandlers (\n    events,\n    isNative\n  ) {\n    var prefix = isNative ? 'nativeOn:' : 'on:';\n    var staticHandlers = \"\";\n    var dynamicHandlers = \"\";\n    for (var name in events) {\n      var handlerCode = genHandler(events[name]);\n      if (events[name] && events[name].dynamic) {\n        dynamicHandlers += name + \",\" + handlerCode + \",\";\n      } else {\n        staticHandlers += \"\\\"\" + name + \"\\\":\" + handlerCode + \",\";\n      }\n    }\n    staticHandlers = \"{\" + (staticHandlers.slice(0, -1)) + \"}\";\n    if (dynamicHandlers) {\n      return prefix + \"_d(\" + staticHandlers + \",[\" + (dynamicHandlers.slice(0, -1)) + \"])\"\n    } else {\n      return prefix + staticHandlers\n    }\n  }\n\n  function genHandler (handler) {\n    if (!handler) {\n      return 'function(){}'\n    }\n\n    if (Array.isArray(handler)) {\n      return (\"[\" + (handler.map(function (handler) { return genHandler(handler); }).join(',')) + \"]\")\n    }\n\n    var isMethodPath = simplePathRE.test(handler.value);\n    var isFunctionExpression = fnExpRE.test(handler.value);\n    var isFunctionInvocation = simplePathRE.test(handler.value.replace(fnInvokeRE, ''));\n\n    if (!handler.modifiers) {\n      if (isMethodPath || isFunctionExpression) {\n        return handler.value\n      }\n      return (\"function($event){\" + (isFunctionInvocation ? (\"return \" + (handler.value)) : handler.value) + \"}\") // inline statement\n    } else {\n      var code = '';\n      var genModifierCode = '';\n      var keys = [];\n      for (var key in handler.modifiers) {\n        if (modifierCode[key]) {\n          genModifierCode += modifierCode[key];\n          // left/right\n          if (keyCodes[key]) {\n            keys.push(key);\n          }\n        } else if (key === 'exact') {\n          var modifiers = (handler.modifiers);\n          genModifierCode += genGuard(\n            ['ctrl', 'shift', 'alt', 'meta']\n              .filter(function (keyModifier) { return !modifiers[keyModifier]; })\n              .map(function (keyModifier) { return (\"$event.\" + keyModifier + \"Key\"); })\n              .join('||')\n          );\n        } else {\n          keys.push(key);\n        }\n      }\n      if (keys.length) {\n        code += genKeyFilter(keys);\n      }\n      // Make sure modifiers like prevent and stop get executed after key filtering\n      if (genModifierCode) {\n        code += genModifierCode;\n      }\n      var handlerCode = isMethodPath\n        ? (\"return \" + (handler.value) + \"($event)\")\n        : isFunctionExpression\n          ? (\"return (\" + (handler.value) + \")($event)\")\n          : isFunctionInvocation\n            ? (\"return \" + (handler.value))\n            : handler.value;\n      return (\"function($event){\" + code + handlerCode + \"}\")\n    }\n  }\n\n  function genKeyFilter (keys) {\n    return (\n      // make sure the key filters only apply to KeyboardEvents\n      // #9441: can't use 'keyCode' in $event because Chrome autofill fires fake\n      // key events that do not have keyCode property...\n      \"if(!$event.type.indexOf('key')&&\" +\n      (keys.map(genFilterCode).join('&&')) + \")return null;\"\n    )\n  }\n\n  function genFilterCode (key) {\n    var keyVal = parseInt(key, 10);\n    if (keyVal) {\n      return (\"$event.keyCode!==\" + keyVal)\n    }\n    var keyCode = keyCodes[key];\n    var keyName = keyNames[key];\n    return (\n      \"_k($event.keyCode,\" +\n      (JSON.stringify(key)) + \",\" +\n      (JSON.stringify(keyCode)) + \",\" +\n      \"$event.key,\" +\n      \"\" + (JSON.stringify(keyName)) +\n      \")\"\n    )\n  }\n\n  /*  */\n\n  function on (el, dir) {\n    if (dir.modifiers) {\n      warn(\"v-on without argument does not support modifiers.\");\n    }\n    el.wrapListeners = function (code) { return (\"_g(\" + code + \",\" + (dir.value) + \")\"); };\n  }\n\n  /*  */\n\n  function bind$1 (el, dir) {\n    el.wrapData = function (code) {\n      return (\"_b(\" + code + \",'\" + (el.tag) + \"',\" + (dir.value) + \",\" + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + \")\")\n    };\n  }\n\n  /*  */\n\n  var baseDirectives = {\n    on: on,\n    bind: bind$1,\n    cloak: noop\n  };\n\n  /*  */\n\n\n\n\n\n  var CodegenState = function CodegenState (options) {\n    this.options = options;\n    this.warn = options.warn || baseWarn;\n    this.transforms = pluckModuleFunction(options.modules, 'transformCode');\n    this.dataGenFns = pluckModuleFunction(options.modules, 'genData');\n    this.directives = extend(extend({}, baseDirectives), options.directives);\n    var isReservedTag = options.isReservedTag || no;\n    this.maybeComponent = function (el) { return !!el.component || !isReservedTag(el.tag); };\n    this.onceId = 0;\n    this.staticRenderFns = [];\n    this.pre = false;\n  };\n\n\n\n  function generate (\n    ast,\n    options\n  ) {\n    var state = new CodegenState(options);\n    var code = ast ? genElement(ast, state) : '_c(\"div\")';\n    return {\n      render: (\"with(this){return \" + code + \"}\"),\n      staticRenderFns: state.staticRenderFns\n    }\n  }\n\n  function genElement (el, state) {\n    if (el.parent) {\n      el.pre = el.pre || el.parent.pre;\n    }\n\n    if (el.staticRoot && !el.staticProcessed) {\n      return genStatic(el, state)\n    } else if (el.once && !el.onceProcessed) {\n      return genOnce(el, state)\n    } else if (el.for && !el.forProcessed) {\n      return genFor(el, state)\n    } else if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.tag === 'template' && !el.slotTarget && !state.pre) {\n      return genChildren(el, state) || 'void 0'\n    } else if (el.tag === 'slot') {\n      return genSlot(el, state)\n    } else {\n      // component or element\n      var code;\n      if (el.component) {\n        code = genComponent(el.component, el, state);\n      } else {\n        var data;\n        if (!el.plain || (el.pre && state.maybeComponent(el))) {\n          data = genData$2(el, state);\n        }\n\n        var children = el.inlineTemplate ? null : genChildren(el, state, true);\n        code = \"_c('\" + (el.tag) + \"'\" + (data ? (\",\" + data) : '') + (children ? (\",\" + children) : '') + \")\";\n      }\n      // module transforms\n      for (var i = 0; i < state.transforms.length; i++) {\n        code = state.transforms[i](el, code);\n      }\n      return code\n    }\n  }\n\n  // hoist static sub-trees out\n  function genStatic (el, state) {\n    el.staticProcessed = true;\n    // Some elements (templates) need to behave differently inside of a v-pre\n    // node.  All pre nodes are static roots, so we can use this as a location to\n    // wrap a state change and reset it upon exiting the pre node.\n    var originalPreState = state.pre;\n    if (el.pre) {\n      state.pre = el.pre;\n    }\n    state.staticRenderFns.push((\"with(this){return \" + (genElement(el, state)) + \"}\"));\n    state.pre = originalPreState;\n    return (\"_m(\" + (state.staticRenderFns.length - 1) + (el.staticInFor ? ',true' : '') + \")\")\n  }\n\n  // v-once\n  function genOnce (el, state) {\n    el.onceProcessed = true;\n    if (el.if && !el.ifProcessed) {\n      return genIf(el, state)\n    } else if (el.staticInFor) {\n      var key = '';\n      var parent = el.parent;\n      while (parent) {\n        if (parent.for) {\n          key = parent.key;\n          break\n        }\n        parent = parent.parent;\n      }\n      if (!key) {\n        state.warn(\n          \"v-once can only be used inside v-for that is keyed. \",\n          el.rawAttrsMap['v-once']\n        );\n        return genElement(el, state)\n      }\n      return (\"_o(\" + (genElement(el, state)) + \",\" + (state.onceId++) + \",\" + key + \")\")\n    } else {\n      return genStatic(el, state)\n    }\n  }\n\n  function genIf (\n    el,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    el.ifProcessed = true; // avoid recursion\n    return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty)\n  }\n\n  function genIfConditions (\n    conditions,\n    state,\n    altGen,\n    altEmpty\n  ) {\n    if (!conditions.length) {\n      return altEmpty || '_e()'\n    }\n\n    var condition = conditions.shift();\n    if (condition.exp) {\n      return (\"(\" + (condition.exp) + \")?\" + (genTernaryExp(condition.block)) + \":\" + (genIfConditions(conditions, state, altGen, altEmpty)))\n    } else {\n      return (\"\" + (genTernaryExp(condition.block)))\n    }\n\n    // v-if with v-once should generate code like (a)?_m(0):_m(1)\n    function genTernaryExp (el) {\n      return altGen\n        ? altGen(el, state)\n        : el.once\n          ? genOnce(el, state)\n          : genElement(el, state)\n    }\n  }\n\n  function genFor (\n    el,\n    state,\n    altGen,\n    altHelper\n  ) {\n    var exp = el.for;\n    var alias = el.alias;\n    var iterator1 = el.iterator1 ? (\",\" + (el.iterator1)) : '';\n    var iterator2 = el.iterator2 ? (\",\" + (el.iterator2)) : '';\n\n    if (state.maybeComponent(el) &&\n      el.tag !== 'slot' &&\n      el.tag !== 'template' &&\n      !el.key\n    ) {\n      state.warn(\n        \"<\" + (el.tag) + \" v-for=\\\"\" + alias + \" in \" + exp + \"\\\">: component lists rendered with \" +\n        \"v-for should have explicit keys. \" +\n        \"See https://vuejs.org/guide/list.html#key for more info.\",\n        el.rawAttrsMap['v-for'],\n        true /* tip */\n      );\n    }\n\n    el.forProcessed = true; // avoid recursion\n    return (altHelper || '_l') + \"((\" + exp + \"),\" +\n      \"function(\" + alias + iterator1 + iterator2 + \"){\" +\n        \"return \" + ((altGen || genElement)(el, state)) +\n      '})'\n  }\n\n  function genData$2 (el, state) {\n    var data = '{';\n\n    // directives first.\n    // directives may mutate the el's other properties before they are generated.\n    var dirs = genDirectives(el, state);\n    if (dirs) { data += dirs + ','; }\n\n    // key\n    if (el.key) {\n      data += \"key:\" + (el.key) + \",\";\n    }\n    // ref\n    if (el.ref) {\n      data += \"ref:\" + (el.ref) + \",\";\n    }\n    if (el.refInFor) {\n      data += \"refInFor:true,\";\n    }\n    // pre\n    if (el.pre) {\n      data += \"pre:true,\";\n    }\n    // record original tag name for components using \"is\" attribute\n    if (el.component) {\n      data += \"tag:\\\"\" + (el.tag) + \"\\\",\";\n    }\n    // module data generation functions\n    for (var i = 0; i < state.dataGenFns.length; i++) {\n      data += state.dataGenFns[i](el);\n    }\n    // attributes\n    if (el.attrs) {\n      data += \"attrs:\" + (genProps(el.attrs)) + \",\";\n    }\n    // DOM props\n    if (el.props) {\n      data += \"domProps:\" + (genProps(el.props)) + \",\";\n    }\n    // event handlers\n    if (el.events) {\n      data += (genHandlers(el.events, false)) + \",\";\n    }\n    if (el.nativeEvents) {\n      data += (genHandlers(el.nativeEvents, true)) + \",\";\n    }\n    // slot target\n    // only for non-scoped slots\n    if (el.slotTarget && !el.slotScope) {\n      data += \"slot:\" + (el.slotTarget) + \",\";\n    }\n    // scoped slots\n    if (el.scopedSlots) {\n      data += (genScopedSlots(el, el.scopedSlots, state)) + \",\";\n    }\n    // component v-model\n    if (el.model) {\n      data += \"model:{value:\" + (el.model.value) + \",callback:\" + (el.model.callback) + \",expression:\" + (el.model.expression) + \"},\";\n    }\n    // inline-template\n    if (el.inlineTemplate) {\n      var inlineTemplate = genInlineTemplate(el, state);\n      if (inlineTemplate) {\n        data += inlineTemplate + \",\";\n      }\n    }\n    data = data.replace(/,$/, '') + '}';\n    // v-bind dynamic argument wrap\n    // v-bind with dynamic arguments must be applied using the same v-bind object\n    // merge helper so that class/style/mustUseProp attrs are handled correctly.\n    if (el.dynamicAttrs) {\n      data = \"_b(\" + data + \",\\\"\" + (el.tag) + \"\\\",\" + (genProps(el.dynamicAttrs)) + \")\";\n    }\n    // v-bind data wrap\n    if (el.wrapData) {\n      data = el.wrapData(data);\n    }\n    // v-on data wrap\n    if (el.wrapListeners) {\n      data = el.wrapListeners(data);\n    }\n    return data\n  }\n\n  function genDirectives (el, state) {\n    var dirs = el.directives;\n    if (!dirs) { return }\n    var res = 'directives:[';\n    var hasRuntime = false;\n    var i, l, dir, needRuntime;\n    for (i = 0, l = dirs.length; i < l; i++) {\n      dir = dirs[i];\n      needRuntime = true;\n      var gen = state.directives[dir.name];\n      if (gen) {\n        // compile-time directive that manipulates AST.\n        // returns true if it also needs a runtime counterpart.\n        needRuntime = !!gen(el, dir, state.warn);\n      }\n      if (needRuntime) {\n        hasRuntime = true;\n        res += \"{name:\\\"\" + (dir.name) + \"\\\",rawName:\\\"\" + (dir.rawName) + \"\\\"\" + (dir.value ? (\",value:(\" + (dir.value) + \"),expression:\" + (JSON.stringify(dir.value))) : '') + (dir.arg ? (\",arg:\" + (dir.isDynamicArg ? dir.arg : (\"\\\"\" + (dir.arg) + \"\\\"\"))) : '') + (dir.modifiers ? (\",modifiers:\" + (JSON.stringify(dir.modifiers))) : '') + \"},\";\n      }\n    }\n    if (hasRuntime) {\n      return res.slice(0, -1) + ']'\n    }\n  }\n\n  function genInlineTemplate (el, state) {\n    var ast = el.children[0];\n    if (el.children.length !== 1 || ast.type !== 1) {\n      state.warn(\n        'Inline-template components must have exactly one child element.',\n        { start: el.start }\n      );\n    }\n    if (ast && ast.type === 1) {\n      var inlineRenderFns = generate(ast, state.options);\n      return (\"inlineTemplate:{render:function(){\" + (inlineRenderFns.render) + \"},staticRenderFns:[\" + (inlineRenderFns.staticRenderFns.map(function (code) { return (\"function(){\" + code + \"}\"); }).join(',')) + \"]}\")\n    }\n  }\n\n  function genScopedSlots (\n    el,\n    slots,\n    state\n  ) {\n    // by default scoped slots are considered \"stable\", this allows child\n    // components with only scoped slots to skip forced updates from parent.\n    // but in some cases we have to bail-out of this optimization\n    // for example if the slot contains dynamic names, has v-if or v-for on them...\n    var needsForceUpdate = el.for || Object.keys(slots).some(function (key) {\n      var slot = slots[key];\n      return (\n        slot.slotTargetDynamic ||\n        slot.if ||\n        slot.for ||\n        containsSlotChild(slot) // is passing down slot from parent which may be dynamic\n      )\n    });\n\n    // #9534: if a component with scoped slots is inside a conditional branch,\n    // it's possible for the same component to be reused but with different\n    // compiled slot content. To avoid that, we generate a unique key based on\n    // the generated code of all the slot contents.\n    var needsKey = !!el.if;\n\n    // OR when it is inside another scoped slot or v-for (the reactivity may be\n    // disconnected due to the intermediate scope variable)\n    // #9438, #9506\n    // TODO: this can be further optimized by properly analyzing in-scope bindings\n    // and skip force updating ones that do not actually use scope variables.\n    if (!needsForceUpdate) {\n      var parent = el.parent;\n      while (parent) {\n        if (\n          (parent.slotScope && parent.slotScope !== emptySlotScopeToken) ||\n          parent.for\n        ) {\n          needsForceUpdate = true;\n          break\n        }\n        if (parent.if) {\n          needsKey = true;\n        }\n        parent = parent.parent;\n      }\n    }\n\n    var generatedSlots = Object.keys(slots)\n      .map(function (key) { return genScopedSlot(slots[key], state); })\n      .join(',');\n\n    return (\"scopedSlots:_u([\" + generatedSlots + \"]\" + (needsForceUpdate ? \",null,true\" : \"\") + (!needsForceUpdate && needsKey ? (\",null,false,\" + (hash(generatedSlots))) : \"\") + \")\")\n  }\n\n  function hash(str) {\n    var hash = 5381;\n    var i = str.length;\n    while(i) {\n      hash = (hash * 33) ^ str.charCodeAt(--i);\n    }\n    return hash >>> 0\n  }\n\n  function containsSlotChild (el) {\n    if (el.type === 1) {\n      if (el.tag === 'slot') {\n        return true\n      }\n      return el.children.some(containsSlotChild)\n    }\n    return false\n  }\n\n  function genScopedSlot (\n    el,\n    state\n  ) {\n    var isLegacySyntax = el.attrsMap['slot-scope'];\n    if (el.if && !el.ifProcessed && !isLegacySyntax) {\n      return genIf(el, state, genScopedSlot, \"null\")\n    }\n    if (el.for && !el.forProcessed) {\n      return genFor(el, state, genScopedSlot)\n    }\n    var slotScope = el.slotScope === emptySlotScopeToken\n      ? \"\"\n      : String(el.slotScope);\n    var fn = \"function(\" + slotScope + \"){\" +\n      \"return \" + (el.tag === 'template'\n        ? el.if && isLegacySyntax\n          ? (\"(\" + (el.if) + \")?\" + (genChildren(el, state) || 'undefined') + \":undefined\")\n          : genChildren(el, state) || 'undefined'\n        : genElement(el, state)) + \"}\";\n    // reverse proxy v-slot without scope on this.$slots\n    var reverseProxy = slotScope ? \"\" : \",proxy:true\";\n    return (\"{key:\" + (el.slotTarget || \"\\\"default\\\"\") + \",fn:\" + fn + reverseProxy + \"}\")\n  }\n\n  function genChildren (\n    el,\n    state,\n    checkSkip,\n    altGenElement,\n    altGenNode\n  ) {\n    var children = el.children;\n    if (children.length) {\n      var el$1 = children[0];\n      // optimize single v-for\n      if (children.length === 1 &&\n        el$1.for &&\n        el$1.tag !== 'template' &&\n        el$1.tag !== 'slot'\n      ) {\n        var normalizationType = checkSkip\n          ? state.maybeComponent(el$1) ? \",1\" : \",0\"\n          : \"\";\n        return (\"\" + ((altGenElement || genElement)(el$1, state)) + normalizationType)\n      }\n      var normalizationType$1 = checkSkip\n        ? getNormalizationType(children, state.maybeComponent)\n        : 0;\n      var gen = altGenNode || genNode;\n      return (\"[\" + (children.map(function (c) { return gen(c, state); }).join(',')) + \"]\" + (normalizationType$1 ? (\",\" + normalizationType$1) : ''))\n    }\n  }\n\n  // determine the normalization needed for the children array.\n  // 0: no normalization needed\n  // 1: simple normalization needed (possible 1-level deep nested array)\n  // 2: full normalization needed\n  function getNormalizationType (\n    children,\n    maybeComponent\n  ) {\n    var res = 0;\n    for (var i = 0; i < children.length; i++) {\n      var el = children[i];\n      if (el.type !== 1) {\n        continue\n      }\n      if (needsNormalization(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return needsNormalization(c.block); }))) {\n        res = 2;\n        break\n      }\n      if (maybeComponent(el) ||\n          (el.ifConditions && el.ifConditions.some(function (c) { return maybeComponent(c.block); }))) {\n        res = 1;\n      }\n    }\n    return res\n  }\n\n  function needsNormalization (el) {\n    return el.for !== undefined || el.tag === 'template' || el.tag === 'slot'\n  }\n\n  function genNode (node, state) {\n    if (node.type === 1) {\n      return genElement(node, state)\n    } else if (node.type === 3 && node.isComment) {\n      return genComment(node)\n    } else {\n      return genText(node)\n    }\n  }\n\n  function genText (text) {\n    return (\"_v(\" + (text.type === 2\n      ? text.expression // no need for () because already wrapped in _s()\n      : transformSpecialNewlines(JSON.stringify(text.text))) + \")\")\n  }\n\n  function genComment (comment) {\n    return (\"_e(\" + (JSON.stringify(comment.text)) + \")\")\n  }\n\n  function genSlot (el, state) {\n    var slotName = el.slotName || '\"default\"';\n    var children = genChildren(el, state);\n    var res = \"_t(\" + slotName + (children ? (\",\" + children) : '');\n    var attrs = el.attrs || el.dynamicAttrs\n      ? genProps((el.attrs || []).concat(el.dynamicAttrs || []).map(function (attr) { return ({\n          // slot props are camelized\n          name: camelize(attr.name),\n          value: attr.value,\n          dynamic: attr.dynamic\n        }); }))\n      : null;\n    var bind$$1 = el.attrsMap['v-bind'];\n    if ((attrs || bind$$1) && !children) {\n      res += \",null\";\n    }\n    if (attrs) {\n      res += \",\" + attrs;\n    }\n    if (bind$$1) {\n      res += (attrs ? '' : ',null') + \",\" + bind$$1;\n    }\n    return res + ')'\n  }\n\n  // componentName is el.component, take it as argument to shun flow's pessimistic refinement\n  function genComponent (\n    componentName,\n    el,\n    state\n  ) {\n    var children = el.inlineTemplate ? null : genChildren(el, state, true);\n    return (\"_c(\" + componentName + \",\" + (genData$2(el, state)) + (children ? (\",\" + children) : '') + \")\")\n  }\n\n  function genProps (props) {\n    var staticProps = \"\";\n    var dynamicProps = \"\";\n    for (var i = 0; i < props.length; i++) {\n      var prop = props[i];\n      var value = transformSpecialNewlines(prop.value);\n      if (prop.dynamic) {\n        dynamicProps += (prop.name) + \",\" + value + \",\";\n      } else {\n        staticProps += \"\\\"\" + (prop.name) + \"\\\":\" + value + \",\";\n      }\n    }\n    staticProps = \"{\" + (staticProps.slice(0, -1)) + \"}\";\n    if (dynamicProps) {\n      return (\"_d(\" + staticProps + \",[\" + (dynamicProps.slice(0, -1)) + \"])\")\n    } else {\n      return staticProps\n    }\n  }\n\n  // #3895, #4268\n  function transformSpecialNewlines (text) {\n    return text\n      .replace(/\\u2028/g, '\\\\u2028')\n      .replace(/\\u2029/g, '\\\\u2029')\n  }\n\n  /*  */\n\n\n\n  // these keywords should not appear inside expressions, but operators like\n  // typeof, instanceof and in are allowed\n  var prohibitedKeywordRE = new RegExp('\\\\b' + (\n    'do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' +\n    'super,throw,while,yield,delete,export,import,return,switch,default,' +\n    'extends,finally,continue,debugger,function,arguments'\n  ).split(',').join('\\\\b|\\\\b') + '\\\\b');\n\n  // these unary operators should not be used as property/method names\n  var unaryOperatorsRE = new RegExp('\\\\b' + (\n    'delete,typeof,void'\n  ).split(',').join('\\\\s*\\\\([^\\\\)]*\\\\)|\\\\b') + '\\\\s*\\\\([^\\\\)]*\\\\)');\n\n  // strip strings in expressions\n  var stripStringRE = /'(?:[^'\\\\]|\\\\.)*'|\"(?:[^\"\\\\]|\\\\.)*\"|`(?:[^`\\\\]|\\\\.)*\\$\\{|\\}(?:[^`\\\\]|\\\\.)*`|`(?:[^`\\\\]|\\\\.)*`/g;\n\n  // detect problematic expressions in a template\n  function detectErrors (ast, warn) {\n    if (ast) {\n      checkNode(ast, warn);\n    }\n  }\n\n  function checkNode (node, warn) {\n    if (node.type === 1) {\n      for (var name in node.attrsMap) {\n        if (dirRE.test(name)) {\n          var value = node.attrsMap[name];\n          if (value) {\n            var range = node.rawAttrsMap[name];\n            if (name === 'v-for') {\n              checkFor(node, (\"v-for=\\\"\" + value + \"\\\"\"), warn, range);\n            } else if (onRE.test(name)) {\n              checkEvent(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            } else {\n              checkExpression(value, (name + \"=\\\"\" + value + \"\\\"\"), warn, range);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (var i = 0; i < node.children.length; i++) {\n          checkNode(node.children[i], warn);\n        }\n      }\n    } else if (node.type === 2) {\n      checkExpression(node.expression, node.text, warn, node);\n    }\n  }\n\n  function checkEvent (exp, text, warn, range) {\n    var stipped = exp.replace(stripStringRE, '');\n    var keywordMatch = stipped.match(unaryOperatorsRE);\n    if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {\n      warn(\n        \"avoid using JavaScript unary operator as property name: \" +\n        \"\\\"\" + (keywordMatch[0]) + \"\\\" in expression \" + (text.trim()),\n        range\n      );\n    }\n    checkExpression(exp, text, warn, range);\n  }\n\n  function checkFor (node, text, warn, range) {\n    checkExpression(node.for || '', text, warn, range);\n    checkIdentifier(node.alias, 'v-for alias', text, warn, range);\n    checkIdentifier(node.iterator1, 'v-for iterator', text, warn, range);\n    checkIdentifier(node.iterator2, 'v-for iterator', text, warn, range);\n  }\n\n  function checkIdentifier (\n    ident,\n    type,\n    text,\n    warn,\n    range\n  ) {\n    if (typeof ident === 'string') {\n      try {\n        new Function((\"var \" + ident + \"=_\"));\n      } catch (e) {\n        warn((\"invalid \" + type + \" \\\"\" + ident + \"\\\" in expression: \" + (text.trim())), range);\n      }\n    }\n  }\n\n  function checkExpression (exp, text, warn, range) {\n    try {\n      new Function((\"return \" + exp));\n    } catch (e) {\n      var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);\n      if (keywordMatch) {\n        warn(\n          \"avoid using JavaScript keyword as property name: \" +\n          \"\\\"\" + (keywordMatch[0]) + \"\\\"\\n  Raw expression: \" + (text.trim()),\n          range\n        );\n      } else {\n        warn(\n          \"invalid expression: \" + (e.message) + \" in\\n\\n\" +\n          \"    \" + exp + \"\\n\\n\" +\n          \"  Raw expression: \" + (text.trim()) + \"\\n\",\n          range\n        );\n      }\n    }\n  }\n\n  /*  */\n\n  var range = 2;\n\n  function generateCodeFrame (\n    source,\n    start,\n    end\n  ) {\n    if ( start === void 0 ) start = 0;\n    if ( end === void 0 ) end = source.length;\n\n    var lines = source.split(/\\r?\\n/);\n    var count = 0;\n    var res = [];\n    for (var i = 0; i < lines.length; i++) {\n      count += lines[i].length + 1;\n      if (count >= start) {\n        for (var j = i - range; j <= i + range || end > count; j++) {\n          if (j < 0 || j >= lines.length) { continue }\n          res.push((\"\" + (j + 1) + (repeat$1(\" \", 3 - String(j + 1).length)) + \"|  \" + (lines[j])));\n          var lineLength = lines[j].length;\n          if (j === i) {\n            // push underline\n            var pad = start - (count - lineLength) + 1;\n            var length = end > count ? lineLength - pad : end - start;\n            res.push(\"   |  \" + repeat$1(\" \", pad) + repeat$1(\"^\", length));\n          } else if (j > i) {\n            if (end > count) {\n              var length$1 = Math.min(end - count, lineLength);\n              res.push(\"   |  \" + repeat$1(\"^\", length$1));\n            }\n            count += lineLength + 1;\n          }\n        }\n        break\n      }\n    }\n    return res.join('\\n')\n  }\n\n  function repeat$1 (str, n) {\n    var result = '';\n    if (n > 0) {\n      while (true) { // eslint-disable-line\n        if (n & 1) { result += str; }\n        n >>>= 1;\n        if (n <= 0) { break }\n        str += str;\n      }\n    }\n    return result\n  }\n\n  /*  */\n\n\n\n  function createFunction (code, errors) {\n    try {\n      return new Function(code)\n    } catch (err) {\n      errors.push({ err: err, code: code });\n      return noop\n    }\n  }\n\n  function createCompileToFunctionFn (compile) {\n    var cache = Object.create(null);\n\n    return function compileToFunctions (\n      template,\n      options,\n      vm\n    ) {\n      options = extend({}, options);\n      var warn$$1 = options.warn || warn;\n      delete options.warn;\n\n      /* istanbul ignore if */\n      {\n        // detect possible CSP restriction\n        try {\n          new Function('return 1');\n        } catch (e) {\n          if (e.toString().match(/unsafe-eval|CSP/)) {\n            warn$$1(\n              'It seems you are using the standalone build of Vue.js in an ' +\n              'environment with Content Security Policy that prohibits unsafe-eval. ' +\n              'The template compiler cannot work in this environment. Consider ' +\n              'relaxing the policy to allow unsafe-eval or pre-compiling your ' +\n              'templates into render functions.'\n            );\n          }\n        }\n      }\n\n      // check cache\n      var key = options.delimiters\n        ? String(options.delimiters) + template\n        : template;\n      if (cache[key]) {\n        return cache[key]\n      }\n\n      // compile\n      var compiled = compile(template, options);\n\n      // check compilation errors/tips\n      {\n        if (compiled.errors && compiled.errors.length) {\n          if (options.outputSourceRange) {\n            compiled.errors.forEach(function (e) {\n              warn$$1(\n                \"Error compiling template:\\n\\n\" + (e.msg) + \"\\n\\n\" +\n                generateCodeFrame(template, e.start, e.end),\n                vm\n              );\n            });\n          } else {\n            warn$$1(\n              \"Error compiling template:\\n\\n\" + template + \"\\n\\n\" +\n              compiled.errors.map(function (e) { return (\"- \" + e); }).join('\\n') + '\\n',\n              vm\n            );\n          }\n        }\n        if (compiled.tips && compiled.tips.length) {\n          if (options.outputSourceRange) {\n            compiled.tips.forEach(function (e) { return tip(e.msg, vm); });\n          } else {\n            compiled.tips.forEach(function (msg) { return tip(msg, vm); });\n          }\n        }\n      }\n\n      // turn code into functions\n      var res = {};\n      var fnGenErrors = [];\n      res.render = createFunction(compiled.render, fnGenErrors);\n      res.staticRenderFns = compiled.staticRenderFns.map(function (code) {\n        return createFunction(code, fnGenErrors)\n      });\n\n      // check function generation errors.\n      // this should only happen if there is a bug in the compiler itself.\n      // mostly for codegen development use\n      /* istanbul ignore if */\n      {\n        if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {\n          warn$$1(\n            \"Failed to generate render function:\\n\\n\" +\n            fnGenErrors.map(function (ref) {\n              var err = ref.err;\n              var code = ref.code;\n\n              return ((err.toString()) + \" in\\n\\n\" + code + \"\\n\");\n          }).join('\\n'),\n            vm\n          );\n        }\n      }\n\n      return (cache[key] = res)\n    }\n  }\n\n  /*  */\n\n  function createCompilerCreator (baseCompile) {\n    return function createCompiler (baseOptions) {\n      function compile (\n        template,\n        options\n      ) {\n        var finalOptions = Object.create(baseOptions);\n        var errors = [];\n        var tips = [];\n\n        var warn = function (msg, range, tip) {\n          (tip ? tips : errors).push(msg);\n        };\n\n        if (options) {\n          if (options.outputSourceRange) {\n            // $flow-disable-line\n            var leadingSpaceLength = template.match(/^\\s*/)[0].length;\n\n            warn = function (msg, range, tip) {\n              var data = { msg: msg };\n              if (range) {\n                if (range.start != null) {\n                  data.start = range.start + leadingSpaceLength;\n                }\n                if (range.end != null) {\n                  data.end = range.end + leadingSpaceLength;\n                }\n              }\n              (tip ? tips : errors).push(data);\n            };\n          }\n          // merge custom modules\n          if (options.modules) {\n            finalOptions.modules =\n              (baseOptions.modules || []).concat(options.modules);\n          }\n          // merge custom directives\n          if (options.directives) {\n            finalOptions.directives = extend(\n              Object.create(baseOptions.directives || null),\n              options.directives\n            );\n          }\n          // copy other options\n          for (var key in options) {\n            if (key !== 'modules' && key !== 'directives') {\n              finalOptions[key] = options[key];\n            }\n          }\n        }\n\n        finalOptions.warn = warn;\n\n        var compiled = baseCompile(template.trim(), finalOptions);\n        {\n          detectErrors(compiled.ast, warn);\n        }\n        compiled.errors = errors;\n        compiled.tips = tips;\n        return compiled\n      }\n\n      return {\n        compile: compile,\n        compileToFunctions: createCompileToFunctionFn(compile)\n      }\n    }\n  }\n\n  /*  */\n\n  // `createCompilerCreator` allows creating compilers that use alternative\n  // parser/optimizer/codegen, e.g the SSR optimizing compiler.\n  // Here we just export a default compiler using the default parts.\n  var createCompiler = createCompilerCreator(function baseCompile (\n    template,\n    options\n  ) {\n    var ast = parse(template.trim(), options);\n    if (options.optimize !== false) {\n      optimize(ast, options);\n    }\n    var code = generate(ast, options);\n    return {\n      ast: ast,\n      render: code.render,\n      staticRenderFns: code.staticRenderFns\n    }\n  });\n\n  /*  */\n\n  var ref$1 = createCompiler(baseOptions);\n  var compile = ref$1.compile;\n  var compileToFunctions = ref$1.compileToFunctions;\n\n  /*  */\n\n  // check whether current browser encodes a char inside attribute values\n  var div;\n  function getShouldDecode (href) {\n    div = div || document.createElement('div');\n    div.innerHTML = href ? \"<a href=\\\"\\n\\\"/>\" : \"<div a=\\\"\\n\\\"/>\";\n    return div.innerHTML.indexOf('&#10;') > 0\n  }\n\n  // #3663: IE encodes newlines inside attribute values while other browsers don't\n  var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;\n  // #6828: chrome encodes content in a[href]\n  var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;\n\n  /*  */\n\n  var idToTemplate = cached(function (id) {\n    var el = query(id);\n    return el && el.innerHTML\n  });\n\n  var mount = Vue.prototype.$mount;\n  Vue.prototype.$mount = function (\n    el,\n    hydrating\n  ) {\n    el = el && query(el);\n\n    /* istanbul ignore if */\n    if (el === document.body || el === document.documentElement) {\n      warn(\n        \"Do not mount Vue to <html> or <body> - mount to normal elements instead.\"\n      );\n      return this\n    }\n\n    var options = this.$options;\n    // resolve template/el and convert to render function\n    if (!options.render) {\n      var template = options.template;\n      if (template) {\n        if (typeof template === 'string') {\n          if (template.charAt(0) === '#') {\n            template = idToTemplate(template);\n            /* istanbul ignore if */\n            if (!template) {\n              warn(\n                (\"Template element not found or is empty: \" + (options.template)),\n                this\n              );\n            }\n          }\n        } else if (template.nodeType) {\n          template = template.innerHTML;\n        } else {\n          {\n            warn('invalid template option:' + template, this);\n          }\n          return this\n        }\n      } else if (el) {\n        template = getOuterHTML(el);\n      }\n      if (template) {\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile');\n        }\n\n        var ref = compileToFunctions(template, {\n          outputSourceRange: \"development\" !== 'production',\n          shouldDecodeNewlines: shouldDecodeNewlines,\n          shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,\n          delimiters: options.delimiters,\n          comments: options.comments\n        }, this);\n        var render = ref.render;\n        var staticRenderFns = ref.staticRenderFns;\n        options.render = render;\n        options.staticRenderFns = staticRenderFns;\n\n        /* istanbul ignore if */\n        if (config.performance && mark) {\n          mark('compile end');\n          measure((\"vue \" + (this._name) + \" compile\"), 'compile', 'compile end');\n        }\n      }\n    }\n    return mount.call(this, el, hydrating)\n  };\n\n  /**\n   * Get outerHTML of elements, taking care\n   * of SVG elements in IE as well.\n   */\n  function getOuterHTML (el) {\n    if (el.outerHTML) {\n      return el.outerHTML\n    } else {\n      var container = document.createElement('div');\n      container.appendChild(el.cloneNode(true));\n      return container.innerHTML\n    }\n  }\n\n  Vue.compile = compileToFunctions;\n\n  return Vue;\n\n}));\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../webpack/buildin/global.js */ \"./node_modules/webpack/buildin/global.js\"), __webpack_require__(/*! ./../../timers-browserify/main.js */ \"./node_modules/timers-browserify/main.js\").setImmediate))\n\n//# sourceURL=webpack:///./node_modules/vue/dist/vue.js?");

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n//# sourceURL=webpack:///(webpack)/buildin/global.js?");

/***/ }),

/***/ "./src/css/index.css":
/*!***************************!*\
  !*** ./src/css/index.css ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!./index.css */ \"./node_modules/css-loader/dist/cjs.js!./src/css/index.css\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\n\n//# sourceURL=webpack:///./src/css/index.css?");

/***/ }),

/***/ "./src/css/index.less":
/*!****************************!*\
  !*** ./src/css/index.less ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/less-loader/dist/cjs.js!./index.less */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/less-loader/dist/cjs.js!./src/css/index.less\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\n\n//# sourceURL=webpack:///./src/css/index.less?");

/***/ }),

/***/ "./src/css/index.scss":
/*!****************************!*\
  !*** ./src/css/index.scss ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("var content = __webpack_require__(/*! !../../node_modules/css-loader/dist/cjs.js!../../node_modules/sass-loader/lib/loader.js!./index.scss */ \"./node_modules/css-loader/dist/cjs.js!./node_modules/sass-loader/lib/loader.js!./src/css/index.scss\");\n\nif (typeof content === 'string') {\n  content = [[module.i, content, '']];\n}\n\nvar options = {}\n\noptions.insert = \"head\";\noptions.singleton = false;\n\nvar update = __webpack_require__(/*! ../../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js\")(content, options);\n\nif (content.locals) {\n  module.exports = content.locals;\n}\n\n\n//# sourceURL=webpack:///./src/css/index.scss?");

/***/ }),

/***/ "./src/images/timg.jpg":
/*!*****************************!*\
  !*** ./src/images/timg.jpg ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = \"data:image/jpeg;base64,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\"\n\n//# sourceURL=webpack:///./src/images/timg.jpg?");

/***/ }),

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _node_modules_vue_dist_vue_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/vue/dist/vue.js */ \"./node_modules/vue/dist/vue.js\");\n/* harmony import */ var _node_modules_vue_dist_vue_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_vue_dist_vue_js__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./css/index.css */ \"./src/css/index.css\");\n/* harmony import */ var _css_index_css__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_css_index_css__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _css_index_less__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./css/index.less */ \"./src/css/index.less\");\n/* harmony import */ var _css_index_less__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_css_index_less__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _css_index_scss__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./css/index.scss */ \"./src/css/index.scss\");\n/* harmony import */ var _css_index_scss__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_css_index_scss__WEBPACK_IMPORTED_MODULE_3__);\n//在webpack中尝试使用Vue；\r\n//注意：在webpack中，使用import Vue from 'vue'导入的Vue构造函数，功能不完整，只提供了runtime-only的方式，并没有提供像网页中那样的使用方式\r\n\r\n\r\n\r\n\r\n\r\n//包的查找规则：\r\n// 1.找项目根目录中有没有node_modules的文件夹\r\n// 2.在node_modules中根据包名，找对应的vue文件夹\r\n// 3.在vue文件夹中，找一个叫做package.json的包配置文件\r\n// 4.在package.json文件中，查找一个叫main属性[main属性指定了这个包在被加载的时候，的入口文件]\r\n\r\nvar vm = new _node_modules_vue_dist_vue_js__WEBPACK_IMPORTED_MODULE_0___default.a({\r\n    el:'#app',\r\n    data:{\r\n        msg:'123'\r\n    }\r\n})\r\n\n\n//# sourceURL=webpack:///./src/main.js?");

/***/ })

/******/ });